<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Shader入门精要 | Moony's World</title><meta name="author" content="Moony"><meta name="copyright" content="Moony"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第二章：渲染流水线概念：渲染需要CPU和GPU的配合共同完成，RTR 3rd将渲染分为应用阶段-&gt;几何阶段-&gt;光栅化阶段，其中： 应用阶段： 通常是由CPU的负责实现（开发者进行控制），确定例如：摄像机的设置、场景中的模型参数、光照信息等； 同时，为了提高渲染性能，需要进行粗粒度的culling，将相机不可见的物体剔除； 最后，需要为每一个模型设置渲染状态，包括：使用的材质、纹理、sh">
<meta property="og:type" content="article">
<meta property="og:title" content="Shader入门精要">
<meta property="og:url" content="http://example.com/2022/11/02/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/index.html">
<meta property="og:site_name" content="Moony&#39;s World">
<meta property="og:description" content="第二章：渲染流水线概念：渲染需要CPU和GPU的配合共同完成，RTR 3rd将渲染分为应用阶段-&gt;几何阶段-&gt;光栅化阶段，其中： 应用阶段： 通常是由CPU的负责实现（开发者进行控制），确定例如：摄像机的设置、场景中的模型参数、光照信息等； 同时，为了提高渲染性能，需要进行粗粒度的culling，将相机不可见的物体剔除； 最后，需要为每一个模型设置渲染状态，包括：使用的材质、纹理、sh">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-11-02T11:22:23.000Z">
<meta property="article:modified_time" content="2022-12-12T20:10:41.844Z">
<meta property="article:author" content="Moony">
<meta property="article:tag" content="Unity">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/11/02/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Shader入门精要',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-13 04:10:41'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Moony's World</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Shader入门精要</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-11-02T11:22:23.000Z" title="Created 2022-11-02 19:22:23">2022-11-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-12-12T20:10:41.844Z" title="Updated 2022-12-13 04:10:41">2022-12-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Shader入门精要"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="第二章：渲染流水线"><a href="#第二章：渲染流水线" class="headerlink" title="第二章：渲染流水线"></a>第二章：渲染流水线</h1><h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><p>渲染需要CPU和GPU的配合共同完成，RTR 3rd将渲染分为应用阶段-&gt;几何阶段-&gt;光栅化阶段，其中：</p>
<h3 id="应用阶段："><a href="#应用阶段：" class="headerlink" title="应用阶段："></a>应用阶段：</h3><ol>
<li>通常是由CPU的负责实现（开发者进行控制），确定例如：摄像机的设置、场景中的模型参数、光照信息等；</li>
<li>同时，为了提高渲染性能，需要进行粗粒度的culling，将相机不可见的物体剔除；</li>
<li>最后，需要为每一个模型设置渲染状态，包括：使用的材质、纹理、shader等。</li>
<li>这个阶段最重要的是输出渲染所需要的几何信息：渲染图元。</li>
</ol>
<h3 id="几何阶段："><a href="#几何阶段：" class="headerlink" title="几何阶段："></a>几何阶段：</h3><p>确定绘制的图元是什么、如何绘制、在哪里绘制；通常在GPU上进行。</p>
<ol>
<li>进行逐顶点、逐多边形操作；</li>
<li>将顶点左边变换到屏幕空间中，再交给光栅器进行处理；</li>
</ol>
<h3 id="光栅化阶段："><a href="#光栅化阶段：" class="headerlink" title="光栅化阶段："></a>光栅化阶段：</h3><p>在GPU上，使用上阶段传递的数据产生屏幕上的像素，绘制最终的图像。</p>
<ol>
<li>决定每个渲染图元中哪些像素需要被绘制在屏幕上；</li>
<li>对上一个阶段得到的逐顶点参数进行插值，然后进行逐像素处理。</li>
</ol>
<h2 id="CPU和GPU的通信："><a href="#CPU和GPU的通信：" class="headerlink" title="CPU和GPU的通信："></a>CPU和GPU的通信：</h2><h3 id="应用阶段：-1"><a href="#应用阶段：-1" class="headerlink" title="应用阶段："></a>应用阶段：</h3><ol>
<li><p>把数据加载到显存中。</p>
<p>硬盘-&gt;RAM-&gt;VRAM（显卡访问显存更快）</p>
</li>
<li><p>设置渲染状态。 </p>
<p>设置渲染状态，定义场景中的网格如何被渲染：使用哪个vs，fs，光源， 材质等。</p>
</li>
<li><p>调用 Draw Call。</p>
<p>CPU发起，GPU接收，指向一个需要被渲染的图元列表。</p>
</li>
</ol>
<h2 id="GPU流水线"><a href="#GPU流水线" class="headerlink" title="GPU流水线"></a>GPU流水线</h2><p>即几何阶段和光栅化阶段，开发者无法拥有绝对的控制权。</p>
<p><img src="/images/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/GPU%E6%B5%81%E6%B0%B4%E7%BA%BF.png" alt="GPU流水线"></p>
<h3 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h3><p>顶点着色器 (Vertex Shader) 是流水线的第 个阶段，它的输入来自于 CPU 。</p>
<ol>
<li>顶点着色器的处理单位是顶点，也就是说，输入进来的每个顶点都会调用一次顶点着色器。顶点着色器本身不可以创建或者销毁任何顶点，而且<strong>无法得到顶点与顶点之间的关系</strong>。例如，我们无法得知两个顶点是否属于同一个三角网格。但正是因为这样的相互独立性， GPU可以利用本身的特性并行化处理每一个顶点 ，这意味着这一阶段的处理速度会很快。</li>
<li>需要注意的是， OpenGL 同时也是 Unity 使用的 NDC, 它的分量 范围在[-1, 1] 之间，而在 DirectX 中， NDC 分量范围是[0, 1] 。</li>
</ol>
<h3 id="裁剪-Clipping"><a href="#裁剪-Clipping" class="headerlink" title="裁剪(Clipping)"></a>裁剪(Clipping)</h3><p>这一阶段的目的是将那些不在摄像机视野内的顶点裁剪掉，并剔除某些三角图元的面片。这个阶段是可配置的。 例如，我们可以使用自定义的裁剪平面来配置裁剪区域，也可以通过指令控制裁剪三角图元的正面还是背面。</p>
<p>裁剪的这一步不可编程。是硬件的固定操作。</p>
<p><em>ps: 不要把裁剪clipping和剔除culling弄混了，两者不是一个概念。</em></p>
<h3 id="屏幕映射"><a href="#屏幕映射" class="headerlink" title="屏幕映射"></a>屏幕映射</h3><p>屏幕坐标系在 OpenGL和DirectX之间的差异问题。 OpenGL把屏幕的左下角当成最小的窗口坐标值，而 DirectX 则定义了屏幕的左上角为最小的窗口坐标值。</p>
<h3 id="三角形设置"><a href="#三角形设置" class="headerlink" title="三角形设置"></a>三角形设置</h3><p>光栅化的目标：计算每个图元覆盖了哪些像素，以及为这些像素计算它们的颜色。</p>
<p>三角形设置 (Triangle Setup) 这个阶段会计算光栅化一个三角网格所需的信息。具体来说，上一个阶段输出的都是三角网格的顶点，即我们得到的是三角网格每条边的两个端点。但如果要得到整个三角网格对像素的覆盖情况 我们就必须计算每条边上的像素坐标。为了能够计算边界像素的坐标信息，我们就需要得到三角形边界的表示方式。</p>
<h3 id="三角形遍历"><a href="#三角形遍历" class="headerlink" title="三角形遍历"></a>三角形遍历</h3><p>三角形遍历 (Triangle Traversal) 阶段将会<strong>检查每个像素是否被一个三角网格所覆盖</strong>。如果被覆盖的话，就会生成一个片元 (fragment) 。而这样一个找到哪些像素被三角网格覆盖的过程就是三角形遍历，这个阶段也被称为扫描变换 (Scan Conversion) 。</p>
<p>三角形遍历阶段会根据上 个阶段的计算结果来判断一个三角网格覆盖了哪些像素，并使用三角网格3个顶点的顶点信息对整个覆盖区域的像素进行插值。</p>
<p>这一步的输出就是得到一个片元序列。需要注意的是，一个片元并不是真正意义上的像素 而是包含了很多状态的集合 这些状态用于计算每个像素的最终颜色。这些状态包括了（但不限于）它的屏幕坐标 深度信息，以及其他从几何阶段输出的顶点信息 例如法线、纹理坐标等。</p>
<h3 id="片元着色器"><a href="#片元着色器" class="headerlink" title="片元着色器"></a>片元着色器</h3><p>前面的光栅化阶段实际上并不会影响屏幕上每个像素的颜色值，而是会产生一系列的数据信息，用来表述一个三角网格是怎样覆盖每个像素的。而每个片元就负责存储这样一系列数据。</p>
<p>真正会对像素产生影响的阶段是下一个流水线阶段——逐片元操作 (Per-Fragment Operations)。</p>
<p>片元着色器的输入是上一个阶段对顶点信息插值得到的结果。更具体来说，是根据那些从顶点着色器中输出的数据插值得到的。而它的输出是一个或者多个颜色值。</p>
<p>虽然片元着色器可以完成很多重要效果，但它的局限在于，它仅可以影响单个片元。也就是说，当执行片元着色器时，<strong>它不可以将自己的任何结果直接发送给它的邻居们</strong>。有一个情况例外，就是片元着色器可以访问到导数信息 (gradient 或者说是 derivative) 。</p>
<h3 id="逐片元操作-x2F-输出合并"><a href="#逐片元操作-x2F-输出合并" class="headerlink" title="逐片元操作&#x2F; 输出合并"></a>逐片元操作&#x2F; 输出合并</h3><p>高度可配置。</p>
<ol>
<li>决定每个片元的可见性。这涉及了很多<strong>测试</strong>工作，例如深度测试、模板测试等（测试流程图：P15）;</li>
<li>如果一个片元通过了所有的测试，就需要把这个片元的颜色值和已经存储在颜色缓冲区中的颜色进行<strong>合并</strong>，或者说是混合（混合流程图：P16）。</li>
</ol>
<h3 id="提前深度测试-Early-Z"><a href="#提前深度测试-Early-Z" class="headerlink" title="提前深度测试(Early-Z)"></a>提前深度测试(Early-Z)</h3><p>在执行片元着色器之前进行测试，以免进行计算后才发现需要舍弃这个片元的情况。</p>
<p>在 Unity 给出的渲染流水线中，我们也可以发现它给出的深度测试是在片元着色器之前。这种将深度测试提 前执行的技术通常也被称为Early-Z技术。</p>
<p>但是，如果将这些测试提前的话，其检验结果可能会与片元着色器中的一些操作冲突。 例如，如果我们在片元着色器进行了透明度测试（我们将在8.3节 中具体讲到），而这个片元没有通过透明度测试， 我们会在着色器中调用 API（例如 clip 函数） 来手动将其舍弃掉。 这就导致GPU无法提前执行各种测试。因此，现代的GPU会判断片元着色器中的操作是否和提前测试发生冲突，如果有冲突，就会禁用提前测试。但是，这样也会造成性能上的下降， 因为有更多片元需要被处理了。 这也是透明度测试会导致性能下降的原因。</p>
<h3 id="双重缓冲"><a href="#双重缓冲" class="headerlink" title="双重缓冲"></a>双重缓冲</h3><p>对场景的渲染是在幕后发生的，即在后置缓冲 (Back Buffer) 中。 一旦场景已经被渲染到了后置缓冲中，GPU就会交换后置缓冲区和前置缓冲 (Front Buffer) 中的内容， 而前置缓冲区是之前显示在屏幕上的图像。 由此，保证了我们看到的图像总是连续的。</p>
<h3 id="Draw-Call"><a href="#Draw-Call" class="headerlink" title="Draw Call"></a>Draw Call</h3><p>Draw Call 本身的含义很简单，就 CPU 调用图像编程接口，如 OpenGL 中的 glDrawElements 命令或者 DirectX 中的 Drawlnde edPrimitive命令，以命令 GPU 进行渲染的操作。</p>
<p><strong>造成性能问题的主要是CPU而非GPU。</strong></p>
<p>流水线是通过CPU将渲染命令发送给命令缓冲区，从而实现并行工作。</p>
<p>命令缓区包含一个命令CPU向其中添加命令，而由GPU从中读取命令，添加和读取的过程是互相独立的。命令缓冲区使得CPU和GPU可以相互独立工作。当 CPU 渲染一些对象时，它可以向命令缓冲区中添加命令，而当 GPU 完成了上一次的渲染任务后，它就可以从命令队列中再取出一个命令并执行它。</p>
<p><strong>命令缓冲区中的命令有很多种类</strong>，Draw Call 是其中一种，其他命令还有<strong>改变渲染状态</strong>（例如改变使用着色器，使用不同的纹理等）。</p>
<p><strong>多个Draw Call会影响帧率。</strong></p>
<p>在每次调用 Draw Call 之前，CPU需要向GPU发送很多内容，包括数据、状态和命令等。在这一阶段，CPU 需要 完成很多工作，例如检查渲染状态等。而一旦CPU完成了这些准备工作，GPU 就可以开始本次 的渲染。GPU的渲染能力是很强的，渲染200个还是2000个三角网格通常没有什么区别，因此 渲染速度往往快于CPU提交命令的速度。如果Draw Call的数批太多，CPU就会把大量时间花费在提交Draw Call上，造成CPU的过载。</p>
<p><strong>如何减少Draw Call？</strong></p>
<p>批处理：是把很多小的 Draw Call 合并成一个大 Draw Call。</p>
<p>由于我们需要在CPU的内存中合并网格，而合并的过程是需要消耗时间的。 因此，批处理技术更加适合于那些静态的物体，例如不会移动的大地、石头等，对千这些静态物体我们只需要合并一次即可。当然，我们也可以对动态物体进行批处理。但是，由于这些物体是不断运动的，因此每一帧都需要重新进行合并然后再发送给 GPU, 这对空间和时间都会造成一定的影响。</p>
<ol>
<li>避免使用大量很小的网格。当不可避免地需要使用很小的网格结构时，考虑是否可以合并它们；</li>
<li>避免使用过多的材质。尽量在不同的网格之间共用同一个材质。</li>
</ol>
<h1 id="第三章：Unity-Shader与ShaderLab"><a href="#第三章：Unity-Shader与ShaderLab" class="headerlink" title="第三章：Unity Shader与ShaderLab"></a>第三章：Unity Shader与ShaderLab</h1><h2 id="Unity-Shader"><a href="#Unity-Shader" class="headerlink" title="Unity Shader"></a>Unity Shader</h2><ol>
<li>是一个文本文件，有对应的导入设置面板，可以设置着色器类型等信息；</li>
<li>在Compile and show code下拉列表可以让开发者检查该Unity Shader针对不同图像编程接口（例如OpenGL、D3D9  D3Dll等）最终编译成的Shader代码；</li>
<li>Unity Shader Unity 为开发者提供的高层级的渲染抽象层，而我们和这层抽象打交道的途径就是使用 Unity 提供的一种专门为 Unity Shader 服务的语言——ShaderLab；</li>
<li>定义了要显示这个材质所需的所有东西，不仅仅是着色器代码，Unity根据使用的平台将这些结构编译成真正的代码和Shader文件，对应的平台编译成汇编语言，驱动将汇编语言编译成供GPU运行的机器码；</li>
</ol>
<h2 id="ShaderLab：-shader文件"><a href="#ShaderLab：-shader文件" class="headerlink" title="ShaderLab：.shader文件"></a>ShaderLab：.shader文件</h2><ol>
<li><p>名字(name)</p>
</li>
<li><p>属性(properties)：显示在材质面板上的供shader使用的属性，但是并不是所有属性都需要写在这里；可以自定义类型变量（重载磨人的材质编辑面板）。</p>
</li>
<li><p>SubShader：</p>
<blockquote>
<ol>
<li>≥ 1个；</li>
<li>不同SubShader提供给不同的目标平台；</li>
<li>pass：定义一次完整的渲染流程，但是数目不宜过多；UsePass必须用大写的名字。</li>
<li>渲染状态（可在pass单独设置）</li>
<li>标签（有些可以在pass单独设置，有些不可以）</li>
</ol>
</blockquote>
</li>
<li><p>FallBack：</p>
<blockquote>
<ol>
<li>如果所有的SubShader都不能在这个显卡上运行，那么就试试这个最低级的shader；</li>
<li>影响阴影的投射。</li>
</ol>
</blockquote>
</li>
<li><p>着色器代码可以写在SubShader或Pass语义块中。</p>
</li>
<li><p>Surface Shader：</p>
<blockquote>
<ol>
<li>定义在SubShader内；</li>
<li>Unity自定义的着色器代码类型，是更高层的抽象，处理了很多光照相关的细节；</li>
<li>会转换成对应的Vertex&#x2F;Fragment Shader；</li>
<li>CGPROGRAM、ENDCG 之间的代码是使用 CG&#x2F;HLSL 编写的；</li>
</ol>
</blockquote>
</li>
<li><p><strong>Vertex&#x2F;Fragment Shader</strong>：</p>
</li>
</ol>
<blockquote>
<ol>
<li>定义在Pass语义块内；</li>
<li>CGPROGRAM、ENDCG 之间，依旧是CG&#x2F;HLSL 编写。</li>
</ol>
</blockquote>
<h2 id="Unity-Shader和真正的Shader有什么不同？"><a href="#Unity-Shader和真正的Shader有什么不同？" class="headerlink" title="Unity Shader和真正的Shader有什么不同？"></a>Unity Shader和真正的Shader有什么不同？</h2><ol>
<li>而在Unity Shader中，可以在同个文件里同时包含需要的顶点着色器和片元着色器代码。</li>
<li>传统Shader中不能开启渲染设置，需要在另外的代码设置，但是Unity Shader中可以。</li>
<li>传统的Shader需要一一对应输入输出的位置关系，但Unity Shader中只需要声明属性就可以用材质修改；模型自带的数据也可以直接访问。</li>
</ol>
<h1 id="第四章：数学"><a href="#第四章：数学" class="headerlink" title="第四章：数学"></a>第四章：数学</h1><ol>
<li>笛卡尔坐标系</li>
<li>标准正交基</li>
<li>左&#x2F;右手坐标系（<strong>Unity中，世界&#x2F;模型空间是左手坐标系，观察空间中是右手坐标系</strong>）</li>
</ol>
<blockquote>
<ol>
<li>所有二维笛卡尔坐标系都是等价的，因为可以通过旋转和反转平面来将一个坐标系变为另一个坐标系；</li>
<li>2个三维坐标系如果不具有相同的<strong>旋向性</strong>，就无法重合；</li>
<li>判断左右手坐标系有两种方法：手指or身体的朝向。</li>
<li>左右手坐标系对于<strong>正向旋转</strong>的定义不同：右手坐标系逆时针为正，左手坐标系顺时针为正。</li>
<li>将其中一个轴反转，另外两个轴不变，左右手坐标系之间就可以进行相互转换。</li>
<li>如果想要在两个不同的坐标系中得到相同的视觉效果，需要进行一些转换。</li>
</ol>
</blockquote>
<ol start="4">
<li>矢量和点</li>
</ol>
<blockquote>
<ol>
<li><p>矢量不可以和一个变量相加减，只能是同维度的矢量和矢量相加减；</p>
</li>
<li><p>用一个点相对于原点的位移所表示的矢量，进行相加减，而不是点与点相减。</p>
</li>
<li><p><strong>点积</strong>，dot(a, b) &#x3D; a1 * b1 + a2 * b2 + a3 * b3 … ：</p>
<ol>
<li>其中一个几何意义是投影，符号可以表示两个矢量的方向关系。</li>
<li>可以用于计算矢量的模。</li>
<li>两个单位矢量点乘的结果等于<strong>夹角的cos</strong>，因此可以用于计算角度（arccos）。</li>
</ol>
</li>
<li><p><strong>叉积</strong>：</p>
<ol>
<li><p>得到一个垂直于这两个矢量的新矢量。</p>
</li>
<li><p>新的矢量的模 &#x3D; 两个矢量的模的乘积 * <strong>夹角的sin</strong>；<strong>方向根据坐标系是左手坐标系还是右手坐标系决定：如果是右手坐标系，则通过右手法则判断，反之则反</strong>。</p>
</li>
<li><p>当矢量的表达和计算方式保持不变（计算结果是一样的），将坐标系进行转换后，图像可能会反向。</p>
</li>
<li><p>给定一个坐标系、人眼位置以及观察方向，如何判断三角形是正面还是背面？</p>
<blockquote>
<p>假设给定的是左手坐标系，那么叉积方向是通过左手定则判断，且左手定则正好是以顺时针为正。</p>
<p>则：如果p1-&gt;p2，p2-&gt;p3的<strong>叉积</strong>结果生成的新的矢量v1，与人眼观察方向矢量v2的<strong>点积</strong> &lt; 0，说明v1与v2反向，可以通过<strong>左手定则</strong>推出旋转方向是顺时针；反之则反。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
</blockquote>
<ol start="5">
<li><p>矩阵</p>
<ol>
<li><p>转置</p>
<blockquote>
<p>$$<br>(A<em>B)^T &#x3D; A^T</em>B^T\<br>A<em>B &#x3D; (A^T</em>B^T)^T<br>$$</p>
</blockquote>
</li>
<li><p>逆</p>
</li>
<li><p>正交矩阵：<br>$$<br>A*A^T&#x3D;I\<br>A^{-1}&#x3D;A^T<br>$$</p>
<ol>
<li>矩阵的转置为矩阵的逆。</li>
<li>因为计算矩阵的逆非常麻烦，因此如果这个矩阵是正交矩阵就可以通过转置计算逆了。</li>
<li><strong>判断正交矩阵</strong>：几何定义，矩阵的每一行&#x2F;列都是单位矢量（点积结果为1），不同行&#x2F;列之间相互垂直（点积结果为0）。</li>
</ol>
</li>
<li><p><strong>行矩阵还是列矩阵</strong></p>
<blockquote>
<p>Unity中常规是把矢量放在矩阵右侧，将矢量转为列矩阵来计算，即<strong>右乘</strong>。<strong>左&#x2F;右乘就是把左&#x2F;右边的矩阵当做系数来乘对应矩阵内的行&#x2F;列。</strong></p>
</blockquote>
</li>
</ol>
</li>
<li><p>变换</p>
<ol>
<li>缩放、旋转是<strong>线性变换</strong>，可以用3 * 3的矩阵对一个3维矢量表示所有的线性变换；平移不是线性变换，而是<strong>仿射变换</strong>。需要用齐次坐标系空间将矢量拓展到4维空间下。</li>
<li>特殊：<strong>绕任意轴旋转的旋转矩阵是正交矩阵</strong>，因此求它的逆变换就可以直接用转置。</li>
<li>齐次坐标：点的w是1，矢量的w是0；因此，平移的效果并不会对矢量产生影响。</li>
<li>将变换矩阵分解成4个部分。<ol>
<li>平移矩阵不是正交矩阵；</li>
<li>缩放矩阵通常不是正交矩阵；</li>
<li>旋转矩阵，多个旋转矩阵之间的串联同样是正交矩阵。</li>
</ol>
</li>
<li><strong>列</strong>向量，<strong>从右到左</strong>进行变换（如果是行向量，那么就需要从左到右变换，且变换矩阵是列向量对应的变换矩阵的转置）；一般，<strong>变换的顺序都是先缩放，再旋转，最后平移</strong>；旋转时，顺序是<strong>zxy</strong>。</li>
</ol>
</li>
<li><p>对<strong>坐标空间</strong>进行变换</p>
<ol>
<li><p>已知一个坐标空间B的三个轴以及原点在另一个坐标空间A中的表达，以及点P在B中的位置，可以求出变换矩阵<code>Mb-&gt;a</code>（在对应位置放入B在A中三个轴以及原点的坐标），以及P在A中的坐标；</p>
</li>
<li><p>同理，如果已知P在A中的坐标和变换矩阵<code>Mb-&gt;a</code>，直接乘M的逆<code>Ma-&gt;b</code>就可以得到P在B中的位置了（从A-&gt;B和从B-&gt;A是互逆的两个过程）；</p>
</li>
<li><p>已知变换矩阵<code>Ma-&gt;b</code>，可以反向<strong>提取</strong>出A空间在B空间中的三个轴的表示。</p>
<blockquote>
<p>口诀：已知A在B下的表达，可求得<code>Ma-&gt;b</code>和A下某点坐标在B的表达。</p>
</blockquote>
</li>
<li><p>方向矢量的空间变换不受平移的影响，因此该空间变换可以用只用3 * 3的矩阵来表示（截取变换矩阵的前3行3列来对法线方向、光照方向进行空间变换）。</p>
</li>
<li><p>如果<code>Ma-&gt;b</code>是一个正交矩阵，那么第一列就是空间A的x轴在空间B下的表示，第一行就是第一行就是空间B的x轴在空间A下的表示（转置）。</p>
</li>
<li><p>回顾：OpenGL中，LookAt矩阵是将世界坐标系变换到相机坐标系的矩阵。它是怎么推导出来的呢？</p>
</li>
</ol>
<p><img src="/images/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/LookAt.png" alt="LookAt"></p>
<blockquote>
<p>如果已知相机坐标轴和原点以及一个点p在世界坐标系下的表示，那么可以直接表达出<code>M相机-&gt;世界</code>（包含了平移变换），我们需要的是p点在相机坐标系下的表示，因此可以对这个矩阵求逆得到<code>M世界-&gt;相机</code>，但是这个矩阵<strong>不是正交矩阵，所以直接求逆很麻烦</strong>。<br>因此需要简化计算方式。<br>首先，<code>M相机-&gt;世界</code>的推导过程中可以看做是先旋转<code>R</code>（相机坐标轴在世界坐标系下的表达按列排序得到的矩阵<code>M</code>就是旋转矩阵<code>R</code>；因为相机在世界坐标系下的三个轴(forward, up, right)组成<code>R</code>）后平移<code>T</code>。直觉上，先旋转<code>R</code>后平移<code>T</code>的逆变换就是先平移<code>T^-1</code>后旋转<code>R^-1</code>。数学上<code>(A*B)^-1 ＝ B^-1 * A^-1</code>，如果A是平移，那么直觉上A的逆就是<strong>平移部分取反</strong>，通过验证可以发现，取反之后的矩阵和原矩阵相乘正好为I，说明<strong>取反得到的矩阵确实就是是逆矩阵</strong>。而旋转矩阵<code>R</code>本身就是正交矩阵，因此直接取转置即可。<br>结合物理意义，我们可以发现逆矩阵相当于就是把相机和p同时平移到原点，然后再把相机坐标轴同时绕原点旋转到与世界坐标系重合。这样就<strong>等价于</strong>将p变换到了相机坐标系下。因此，只要将旋转矩阵的逆矩阵和平移矩阵的逆矩阵求出来即可得到<code>M世界-&gt;相机</code>。</p>
</blockquote>
<p>$$<br>世界坐标轴x,y,z分别&#x3D;{(1, 0, 0)^T, (0, 1, 0)^T, (0, 0, 1)^T}\<br>\<br>∵[?]<em>{3*3}<em>x&#x3D;x’\<br>∴[?]的第一列&#x3D;x’\<br>以此类推[?]的第二、三列，得到R\<br>\<br>R</em>世界坐标轴x,y,z&#x3D;新的轴在世界坐标系下的表示x’,y’,z’\<br>R&#x3D;[x’,y’,z’按列排序]&#x3D;&gt;可以直接提取R中新轴的表示\<br>\<br>世界p&#x3D;M</em>{相机-&gt;世界}*相机p\<br>相机p&#x3D;M_{世界-&gt;相机}<em>世界p\<br>\<br>M_{相机-&gt;世界}&#x3D;T</em>R\<br>M_{世界-&gt;相机}&#x3D;R^{-1}*T^{-1}&#x3D;[x’,y’,z’按列排序]^{-1}*T^{-1}\<br>\<br>R是正交矩阵，则R^{-1}&#x3D;&#x3D;R^{T}\<br>[x’,y’,z’按列排序]^{-1}&#x3D;[x’,y’,z’按行排序]\<br>\<br>M_{世界-&gt;相机}&#x3D;[x’,y’,z’按行排序]*T^{-1}&#x3D;LookAt<br>$$</p>
</li>
<li><p>从模型坐标系到屏幕坐标系（<strong>到裁剪空间的变换需要自己在shader定义</strong>，之后的都是unity的底层自动完成）</p>
<ol>
<li>如果一个Transform组件有父节点，那么它的位置是在其父节点模型空间中的位置；如果没有父节点，那么它的位置是在世界空间中的位置。</li>
<li>投影矩阵只是在为投影做准备，真正的投影发生在<code>透视除法</code>中。</li>
<li>透视投影：fov，near，far平面的位置决定了两个平面的高度，摄像机的横纵比Aspect决定两个平面的宽度。且观察空间是右手坐标系，因此得出投影矩阵，变换到<strong>裁剪空间</strong>中。变换后的w分量是原来z分量取反的结果。且裁剪矩阵改变了空间的旋向性，从右手坐标系变换到了左手坐标系。（<strong>这个透视投影矩阵和OpenGL以及GAMES101的不太一样，似乎是直接在这一步做了透视除法，之后再裁剪</strong>）</li>
<li>在此基础上，如果一个顶点在是椎体内，它在裁剪空间中的坐标必须满足-w ≤ x or y or z ≤ w，否则将其<strong>剔除</strong>。</li>
<li><strong>透视除法</strong>之后得到的是<strong>NDC</strong>坐标系下的坐标，裁剪空间将会变换到一个立方体内，这个立方体在OpenGL中x、y、z分量的范围是[-1, 1]，DirectX中是[0, 1]。</li>
<li><strong>视口变换</strong>之后，就是<strong>屏幕空间</strong>上的坐标，z分量通常用于深度缓冲，范围是[0, 1]（传统上是把裁剪空间透视除法之后的z直接存进深度缓冲中）。w分量值取决于投影类型，如果是透视投影，范围为[1&#x2F;near, 1&#x2F; far]，正交投影恒为1。</li>
<li>屏幕空间除以屏幕分辨率得到<strong>视口空间</strong>的坐标，左下是(0, 0)，右上是(1, 1)；若已知屏幕坐标，将x&#x2F;y值除以屏幕分辨率即可。</li>
<li>裁剪空间中的w还会用来对插值进行透视矫正（和重心坐标有关，参考：<a target="_blank" rel="noopener" href="http://t.csdn.cn/MZSN4%EF%BC%89%E3%80%82">http://t.csdn.cn/MZSN4）。</a></li>
</ol>
</li>
<li><p>法线变换</p>
<blockquote>
<p>主要是要注意经过变换矩阵后，法线在世界000坐标系中的方向可能并不和平面垂直（主要是因为<strong>非统一变换</strong>），那么就必须要通过求解<strong>逆转置矩阵</strong>来求变换法线的矩阵，否则如果变换矩阵是正交矩阵，那么则直接用原来的变换矩阵进行变换即可。</p>
</blockquote>
</li>
<li><p>Unity内置变换矩阵</p>
<ol>
<li>提取坐标空间的坐标轴（这个有点容易搞混，<strong>列向量</strong>是变换<strong>前</strong>空间在变换<strong>后</strong>空间下的坐标轴）。</li>
<li>判断是否是<strong>正交矩阵</strong>，使用转置充当逆。如果只包含旋转和统一缩放，那么基本是一个正交矩阵：统一缩放的系数k不为1，那么就统一除以这个统一缩放系数，将它变成正交矩阵，然后取转置。</li>
<li>方向矢量变换，不用考虑平移，只用截取左上角的3 * 3进行判断即可。</li>
<li>mul函数参数的位置需要注意。</li>
</ol>
</li>
<li><p>其他需要注意的</p>
<ol>
<li><p>矩阵乘法，<strong>参数的位置</strong>将决定是按列矩阵还是行矩阵进行乘法：mul函数中，如果vector在左，那么它就是行矩阵与M想成，反之，若是在右，则是当做列矩阵相乘（两种算法结果不一样！）。</p>
<blockquote>
<p>mul(M, v) &#x3D;&#x3D; mul(v, transpose(M))<br>mul(v, M) &#x3D;&#x3D; mul(transpose(M), v)</p>
</blockquote>
</li>
<li><p>通常变换顶点时都是使用右乘，按<strong>列矩阵</strong>进行乘法，这是因为Unity提供的内置矩阵都是<strong>按列存储</strong>的。</p>
</li>
<li><p>Cg是<strong>行优先</strong>矩阵，如果要自定义一个矩阵，要注意初始化的顺序。Unity脚本中提供的矩阵Matrix4*4是<strong>列优先</strong>的，和Unity Shader中的不一样。</p>
</li>
<li><p>屏幕坐标：<strong>像素中心</strong>对应的是浮点值0.5。</p>
</li>
<li><p>在fs中使用VPOS&#x2F;WPOS语义得到<strong>屏幕坐标</strong>，然后除以屏幕分辨率；或者使用Unity提供的ComputeScreenPos函数（手动实现屏幕映射得到视口空间种的坐标，将<strong>裁剪空间</strong>下的坐标进行<strong>透视除法</strong>，得到[-1, 1]的<strong>NDC</strong>，然后再映射到[0, 1]的<strong>视口空间</strong>）。</p>
</li>
</ol>
</li>
</ol>
<h1 id="第五章：Unity-Shader与内置属性及函数"><a href="#第五章：Unity-Shader与内置属性及函数" class="headerlink" title="第五章：Unity Shader与内置属性及函数"></a>第五章：Unity Shader与内置属性及函数</h1><p>Properties类似OpenGL中的uniform参数，从CPU端传给Shader；Properties中的属性名称和类型必须和Pass中的一样，否则无法传输；</p>
<p>Shader代码一般都在Pass中，一个Pass代表一个渲染流程；</p>
<p>SV_POSITION必须要在vs中定义并输出，即裁剪坐标系；</p>
<p>一般fs输出直接赋值给SV_Target，默认的渲染目标中；</p>
<p>着色器的输入&#x2F;输出类型（超过两种数据类型），需要使用结构体封装；同时，必须要声明数据类型的语义，这样Unity才能将对应的数据传输过去；</p>
<p>Unity内置文件，尤其是UnityCG.cginc内置了多种函数；</p>
<p>Unity中的Frame Debugger是非常好的调试工具；</p>
<p>不同渲染平台会出现一些差异，比如当使用渲染纹理保存渲染结果的时候，如果开启了抗锯齿，并且同时处理多张渲染图像，那么就需要在顶点着色器中自行反转某些渲染纹理的纵坐标（因为OpenGL和DirectX的屏幕坐标系的起点不一样）；</p>
<blockquote>
<p>尽量选择精度低的数据类型（P106\110\117）；</p>
<p>GPU的寄存器有限，如果可以预计算的，请先预计算（尽量在<strong>流水线的上层</strong>完成计算，比如fs中的数据移到vs或者CPU中）；</p>
<p>分支判断语句中使用的条件变量最好是常数，即在 Shader 运行过程中不会发生变化； </p>
<p>每个分支中包含的操作指令数尽可能少； </p>
<p>分支的嵌套层数尽可能少。</p>
</blockquote>
<h1 id="第六章：光照模型"><a href="#第六章：光照模型" class="headerlink" title="第六章：光照模型"></a>第六章：光照模型</h1><p>本章的shader不能直接用在实际项目。</p>
<p>BRDF可以给出在给定入射光线的方向和辐照度后，某个出射方向上光照的能量分布。</p>
<p>**经验(并不能反映物体和光线之间的真实交互)**光照模型Blinn-Phong（早于BRDF的提出）模型：</p>
<ol>
<li>环境光</li>
<li>漫反射</li>
<li>镜面反射</li>
<li>自发光</li>
</ol>
<p>它是各向同性（固定视角和光源方向旋转这个着色表面，反射不会发生任何改变）的，并且没有考虑Fresnel反射。</p>
<p>给Pass定义合适的LightMode以获得Unity内置的关于光照的变量，从而得到光源的颜色和强度信息。</p>
<h2 id="计算diffuse分量"><a href="#计算diffuse分量" class="headerlink" title="计算diffuse分量"></a>计算diffuse分量</h2><p>需要：</p>
<ol>
<li>光源颜色</li>
<li>光源方向</li>
<li>法线方向</li>
<li>材质的diffuse颜色</li>
</ol>
<p>输入vs的顶点法线是模型坐标系下的，需要先转换到世界坐标系下才可以进行光照模型的计算（比如方向的点积）。</p>
<p>法线转换到世界坐标系下，需要得到顶点变换矩阵的逆转置矩阵：们首先得到模型空间到世 界空间的变换矩阵的逆矩阵_World20bject（截取前3*3）, 然后通过调换它在 mul 函数中的位置，得到和转置矩阵相同的矩阵乘法。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点着色器 lambertian定律</span></span><br><span class="line">v2f vert(a2v v) &#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    <span class="comment">// Transform the vertex from object space to projection space</span></span><br><span class="line">    o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get ambient term</span></span><br><span class="line">    fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Transform the normal from object space to world space</span></span><br><span class="line">    fixed3 worldNormal = <span class="built_in">normalize</span>(mul(v.normal, (float3x3)unity_WorldToObject));</span><br><span class="line">    <span class="comment">// Get the light direction in world space</span></span><br><span class="line">    fixed3 worldLight = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">    <span class="comment">// Compute diffuse term</span></span><br><span class="line">    fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(<span class="built_in">dot</span>(worldNormal, worldLight));</span><br><span class="line"></span><br><span class="line">    o.color = ambient + diffuse;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 片元着色器</span></span><br><span class="line">fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">    <span class="comment">// Get ambient term</span></span><br><span class="line">    fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the normal in world space</span></span><br><span class="line">    fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">    <span class="comment">// Get the light direction in world space</span></span><br><span class="line">    fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute diffuse term</span></span><br><span class="line">    fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(<span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">    fixed3 color = ambient + diffuse;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是上述的光照模型会导致，在光线无法直接到达的区域通常是全黑的，没有任何明暗变化，失去了模型的细节。</p>
<p>Half Lambert光照模型（没有物理依据，只是视觉加强的效果）被提出来解决这个问题。</p>
<p>主要区别在于，没有将法线和入射方向的点积结果的负值截取为0，而是缩小到0.5倍之后+0.5，将范围从[-1, 1]映射到[0, 1]。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// half lambert</span></span><br><span class="line">fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line"><span class="comment">// Get ambient term</span></span><br><span class="line">fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the normal in world space</span></span><br><span class="line">fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line"><span class="comment">// Get the light direction in world space</span></span><br><span class="line">fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compute diffuse term</span></span><br><span class="line">fixed halfLambert = <span class="built_in">dot</span>(worldNormal, worldLightDir) * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line">fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * halfLambert;</span><br><span class="line"></span><br><span class="line">fixed3 color = ambient + diffuse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="计算specular分量"><a href="#计算specular分量" class="headerlink" title="计算specular分量"></a>计算specular分量</h2><p>首先使用Phong光照模型中关于specular分量的计算。</p>
<p>这里只记录<strong>逐像素光照</strong>。</p>
<p>首先，先把WorldSpace下的Normal和着色点Position计算出来然后传递给fs。即，vs传递给fs的向量和坐标尽量都是已经变换到worldSpace下的。</p>
<p>在fs中对这两个值插值，然后计算得出viewDir，而不是在vs中计算出viewDir后给fs插值。这是因为fs中可以直接获取camera的世界坐标，所以这样计算比插值更准确。</p>
<p>然后使用Blinn-Phong光照模型进行计算，关键在于计算入射光方向与观察方向的半角方向。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get the half direction in world space</span></span><br><span class="line">fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line"><span class="comment">// Compute specular term</span></span><br><span class="line">fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br></pre></td></tr></table></figure>

<h2 id="光源类型（9-2：判断光源类型）"><a href="#光源类型（9-2：判断光源类型）" class="headerlink" title="光源类型（9.2：判断光源类型）"></a>光源类型（9.2：判断光源类型）</h2><p>_WorldSpace  LightPosO.xyz只适合<strong>平行光</strong>的方向，<strong>点光源</strong>不能这样计算（因为方向还和着色点位置有关）。</p>
<p><img src="/images/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/%E8%AE%A1%E7%AE%97%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B%E6%97%B6%E5%B8%B8%E7%94%A8%E7%9A%84%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0.png" alt="计算光照模型时常用的内置函数"></p>
<p>这些内置函数可以用于直接计算例如viewDir在世界&#x2F;模型坐标中的方向。</p>
<p>函数结果没有归一化，需要自行归一化。</p>
<p>9.1：<strong>前向渲染</strong></p>
<h2 id="使用内置函数进行计算"><a href="#使用内置函数进行计算" class="headerlink" title="使用内置函数进行计算"></a>使用内置函数进行计算</h2><ol>
<li>vs: 计算法线在世界空间下的方向；</li>
<li>fs: 计算世界坐标系下光源到着色点的方向（不同类型光源的通用函数）、着色点到相机的方向。</li>
</ol>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vs</span></span><br><span class="line"><span class="comment">// Use the build-in funtion to compute the normal in world space</span></span><br><span class="line">o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line"></span><br><span class="line"><span class="comment">// fs</span></span><br><span class="line"><span class="comment">// Remember to normalize the result</span></span><br><span class="line">fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line"><span class="comment">// Remember to normalize the result</span></span><br><span class="line">fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));</span><br></pre></td></tr></table></figure>

<h1 id="第七章：纹理"><a href="#第七章：纹理" class="headerlink" title="第七章：纹理"></a>第七章：纹理</h1><p>纹理坐标不一定在[0, 1]之间，需要设置纹理的平铺模式决定不在这个范围时如何采样。</p>
<p>Unity的纹理坐标和OpenGL是一样的，在左下角。</p>
<p>Shader不可直接用于项目，9.5会有。</p>
<h2 id="单张纹理-gt-diffuse"><a href="#单张纹理-gt-diffuse" class="headerlink" title="单张纹理-&gt;diffuse"></a>单张纹理-&gt;diffuse</h2><p>Blinn-Phong</p>
<p>需要在vert中使用TEXCOORD0声明texcoord变量，让Unity把模型的第一组纹理坐标储存到该变量中。</p>
<p>采样纹理，计算uv坐标：</p>
<ol>
<li>_ MainTex_ST.xy是纹理面板上设置的Tiling平铺&#x2F;缩放系数；</li>
<li>_ MainTex_ST.zw是纹理面板上设置的offset系数；</li>
</ol>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line"><span class="comment">// o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span></span><br></pre></td></tr></table></figure>

<p>可以自行对uv计算属性值_ MainTex_ ST对顶点纹理坐标进行的变换，也可以使用TRANSFORM_TEX内置宏来帮助计算。</p>
<h3 id="面板属性"><a href="#面板属性" class="headerlink" title="面板属性"></a>面板属性</h3><p>Unity中纹理有不同的类型，比如NormalMap，Texture，cubemap等，Unity针对不同类型进行了优化。</p>
<p>Alpha Source处可以选择From Gray Scale来使用每个像素的灰度值生成透明通道的值。</p>
<p>Wrap Mode决定了uv不在[0, 1]之间如何进行平铺，需要在shader中使用纹理的属性，例如变量_MainTex_ST（用于计算纹理平铺和位移后的纹理坐标）。</p>
<blockquote>
<p>clamp是直接截取，&gt;1的&#x3D;1，&lt;0的&#x3D;0。</p>
</blockquote>
<p>offset属性决定了纹理的偏移。</p>
<p>Filter Mode决定当纹理产生拉伸的时候使用哪种滤波模式（放大纹理：就近，二次线性插值，三次线性插值；缩小纹理：mipmapping，一般会多1&#x2F;3的存储空间）。</p>
<blockquote>
<p>trilinear &#x3D; bilinear + mipmap</p>
</blockquote>
<h3 id="最大尺寸和存储格式"><a href="#最大尺寸和存储格式" class="headerlink" title="最大尺寸和存储格式"></a>最大尺寸和存储格式</h3><p>长宽应该是2的次幂；</p>
<p>format：存储格式可选，与Texture Type的选择有关；例如漫反射这类纹理，不用精度太高的存储格式；</p>
<h2 id="凹凸贴图"><a href="#凹凸贴图" class="headerlink" title="凹凸贴图"></a>凹凸贴图</h2><p>用于更改模型表面的<strong>法线</strong>，然而并不会真的修改顶点的<strong>位置</strong>。</p>
<p>两种方法：</p>
<blockquote>
<ol>
<li><strong>height map</strong>: 模拟表面位移，得到一个修改后的法线值，存储的是强度值。颜色越浅说明越向外凸，越深说明越向内凹。计算更<strong>复杂</strong>，无法在实时渲染中得到表面法线，<strong>需要由像素的灰度值计算得到</strong>。</li>
<li><strong>normal map</strong>: 直接存储法线。法线方向的分量∈[-1, 1]，像素的分量∈[0, 1]，因此需要进行一个映射：pixel &#x3D; (normal + 1) &#x2F; 2；normal &#x3D; 2 * pixel - 1。通常存储的是<strong>切线空间的法线纹理</strong>，以该顶点的切线为x轴，法线为z轴，y可以通过叉乘得到；采样得到的颜色的rgb分别对应xyz轴的坐标。如果<strong>顶点的法线和模型本身的法线一样</strong>，那么新的法线依旧是切线空间下的(0, 0, 1)，映射过去之后就是rgb(0.5, 0.5, 1)浅蓝色。</li>
<li><strong>模型空间</strong>下法线纹理&amp; <strong>切线空间</strong>的法线纹理各自的优点。</li>
</ol>
<p>高度贴图和法线贴图两者经常一起使用。</p>
</blockquote>
<h3 id="切线空间下的光照计算"><a href="#切线空间下的光照计算" class="headerlink" title="切线空间下的光照计算"></a>切线空间下的光照计算</h3><ol>
<li><p>切线空间下进行光照计算效率更高；在世界空间下进行光照计算通用性更高。</p>
</li>
<li><p>Unity中，顶点<strong>模型空间</strong>下的法线和切线都是可以直接传输给vs的，TANGENT语义传输的是float4，其中w用于决定副切线的方向。因此，可以通过切线x、副切线y、法线z<strong>按行排序</strong>得到<code>M模型空间-&gt;切线空间</code>，这个矩阵可以通过内置宏TANGENT_SPACE_ROTATION得到。</p>
<blockquote>
<p>注意，案例代码中将模型空间下的法线和切线变换到了世界空间下，以变化世界空间中的Light和View；因此按行排列得到的是<code>M世界空间-&gt;切线空间</code>。</p>
</blockquote>
</li>
<li><p>同时使用漫反射贴图和法线贴图，因为它们通常使用同一套纹理贴图，因此为了减少插值寄存器的使用数量，往往只需要计算和存储一个纹理坐标即可。</p>
</li>
<li><p><strong>副切线的方向</strong>由法线和切线叉乘（叉乘结果有两个方向）之后与v.tangent.w相乘得到。</p>
</li>
<li><p>先得到模型空间下的light和view方向，然后乘<code>M模型空间-&gt;切线空间</code>得到它们切线空间下的表达。</p>
</li>
<li><p>如果没有把纹理类型设置为normal map（<strong>7.2.4</strong>），就需要在fs中对法线贴图进行采样得到pixel值后，手动<strong>反映射</strong>为实际的法线方向；若已经设置了，就可以直接用内置函数UnpackNormal()进行映射。</p>
</li>
<li><p>Unity 为了方便 Unity 对法线纹理的存储进行了优化，我通常会将法线纹理的纹理类型标识成 Normal map, Unity 会根据平台来选择不同的压缩方法。这时，若再使用上述方法来计算就会得到错误的结果 ，因为此时 BumpMap rgb 分量并不再是切线空间下法线方向的 xyz 值了。在 <strong>7.2.4</strong> 中有具体解释。在这种情况下，可以使用 Unity 的内置函数 UnpackNormal 来得到正确的法线方向。</p>
</li>
</ol>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算切线空间下的法线，注意，并没有直接使用采样得到的pixel映射后的rgb，而是通过缩放后的xy，使用勾股定理计算z分量</span></span><br><span class="line"><span class="comment">// Get the texel in the normal map</span></span><br><span class="line">fixed4 packedNormal = tex2D(_BumpMap, i.uv.zw);</span><br><span class="line">fixed3 tangentNormal;</span><br><span class="line"><span class="comment">// If the texture is not marked as &quot;Normal map&quot;</span></span><br><span class="line"><span class="comment">//				tangentNormal.xy = (packedNormal.xy * 2 - 1) * _BumpScale;</span></span><br><span class="line"><span class="comment">//				tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy)));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Or mark the texture as &quot;Normal map&quot;, and use the built-in funciton</span></span><br><span class="line">tangentNormal = UnpackNormal(packedNormal);</span><br><span class="line">tangentNormal.xy *= _BumpScale;</span><br><span class="line">tangentNormal.z = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - saturate(<span class="built_in">dot</span>(tangentNormal.xy, tangentNormal.xy)));</span><br></pre></td></tr></table></figure>

<h3 id="世界空间下的光照计算"><a href="#世界空间下的光照计算" class="headerlink" title="世界空间下的光照计算"></a>世界空间下的光照计算</h3><ol>
<li><p>vs: 先计算<code>M切线空间-&gt;世界空间</code>，然后按行存储在float4中，因为插值寄存器最多只能存储float4的大小（将worldPos放在float4.w中，以便充分利用寄存器空间）。</p>
</li>
<li><p>fs: 通过点乘操作，实现矩阵的每一行和法线的相乘：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bump = <span class="built_in">normalize</span>(half3(<span class="built_in">dot</span>(i.TtoW0.xyz, bump), <span class="built_in">dot</span>(i.TtoW1.xyz, bump), <span class="built_in">dot</span>(i.TtoW2.xyz, bump)));</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="UnpackNormal"><a href="#UnpackNormal" class="headerlink" title="UnpackNormal"></a>UnpackNormal</h3><p>在将纹理标识为Normal Map的时候，必须要用UnpackNormal才可以对纹理进行正确的采样。这是因为Unity会<strong>对不同的平台对纹理进行压缩</strong>，必须要通过这个函数才可以实现正确的采样。</p>
<p>这是因为在压缩的时候，法线的z信息会被舍弃，因此通过采样只能获得法线的xy信息，然后通过<strong>推导得到z分量</strong>（因为切线空间下法线的z分量始终为正，且法线是单位向量）：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tangentNormal.z = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - saturate(<span class="built_in">dot</span>(tangentNormal.xy, tangentNormal.xy)));</span><br></pre></td></tr></table></figure>

<p>Normal Map设置后，选择create from grayscale可以用于从<strong>高度图</strong>(height map)生成法线纹理。高度图记录的是<strong>相对高度</strong>。然后设置bumpiness和filtering，其中filtering决定使用smooth或者sharp的方式用于法线的生成；sharp使用的是sobel滤波器，是一种边缘检测时使用的滤波器，<strong>用于计算x和y方向上的导数</strong>，然后从中得到法线。</p>
<h2 id="渐变纹理：使用halfLambert作为纹理坐标"><a href="#渐变纹理：使用halfLambert作为纹理坐标" class="headerlink" title="渐变纹理：使用halfLambert作为纹理坐标"></a>渐变纹理：使用halfLambert作为纹理坐标</h2><p>纹理贴图可以用于存储任何表面属性，比如使用渐变纹理来控制漫反射光照的结果，这种方式可以得到一种插画（卡通）风格的渲染效果，保证物体的<strong>轮廓更加明显</strong>，并且能够提供多种<strong>色调变化</strong>。</p>
<p>使用<strong>halfLambert</strong>作为纹理坐标(所以代码中实际的uv坐标根本没有用到)；因为RamTexture实际上是一个<strong>一维纹理</strong>，因此纹理坐标的u &#x3D; v &#x3D; halfLambert（实际v &#x3D; 0似乎没区别）。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fixed halfLambert  = <span class="number">0.5</span> * <span class="built_in">dot</span>(worldNormal, worldLightDir) + <span class="number">0.5</span>;</span><br><span class="line">fixed3 diffuseColor = tex2D(_RampTex, fixed2(halfLambert, halfLambert)).rgb * _Color.rgb;</span><br></pre></td></tr></table></figure>

<p>注意：渐变纹理的warp mode要设置为clamp，防止由于浮点数精度造成的问题。</p>
<h2 id="遮罩纹理"><a href="#遮罩纹理" class="headerlink" title="遮罩纹理"></a>遮罩纹理</h2><p><strong>作用</strong>：保护某些区域，免于某些修改。</p>
<p><strong>应用</strong>：模型表面的某些区域反光强烈，而某些区域弱一些；地形材质需要混合多张图片，这张纹理可以控制如何混合这些纹理。</p>
<p><strong>流程</strong>：通过采样得到遮罩纹理的texel值，然后使用其中<strong>某些通道的值</strong>，与某种<strong>表面属性</strong>进行相乘；<strong>若该通道&#x3D;0，那么就可以使得着色结果不受与之相乘的属性的影响</strong>。</p>
<p><strong>tips</strong>: 该案例对多个纹理使用了同一个纹理属性变量_MainTex_ST，如果所有的纹理不需要平铺或者位移，或是使用同一平铺或者位移，那么只需要一个变换后的纹理坐标即可。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// specular分量的计算</span></span><br><span class="line"><span class="comment">// Get the mask value</span></span><br><span class="line"><span class="comment">// 先对遮罩贴图进行采样，只使用r通道的值</span></span><br><span class="line">fixed specularMask = tex2D(_SpecularMask, i.uv).r * _SpecularScale;</span><br><span class="line"><span class="comment">// Compute specular term with the specular mask</span></span><br><span class="line">fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(tangentNormal, halfDir)), _Gloss) * specularMask;</span><br></pre></td></tr></table></figure>

<p>上述这种遮罩贴图的其他通道都被浪费了，一般实际游戏制作中，<strong>遮罩纹理中的每一个颜色通道都会用来存储不同的表面属性</strong>。如：</p>
<ol>
<li>高光反射的强度存储在R通道；</li>
<li>边缘光照强度存储在G通道；</li>
<li>高光反射的指数部分存储在B通道；</li>
<li>自发光强度存储在A通道…</li>
</ol>
<h1 id="第八章：透明物体"><a href="#第八章：透明物体" class="headerlink" title="第八章：透明物体"></a>第八章：透明物体</h1><p><strong>透明</strong>：在实时渲染中实现透明，通常是通过控制透明(alpha)通道，开启透明混合后实现的。</p>
<p><strong>实现方式</strong>：</p>
<ol>
<li>透明度测试：小于阈值的直接丢弃，满足条件的按照不透明物体处理，因此只能实现部分完全透明，其余的完全不透明的效果；</li>
<li>透明度混合：<strong>真正的半透明效果</strong>。是与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。通常需要<strong>关闭深度写入</strong>。</li>
</ol>
<h2 id="渲染顺序很重要！"><a href="#渲染顺序很重要！" class="headerlink" title="渲染顺序很重要！"></a>渲染顺序很重要！</h2><ol>
<li>对于不透明物体，不用在意渲染顺序，因为深度缓冲（开启<strong>深度测试</strong>）是用于解决可见性问题的：在判断该片元需要更新颜色缓冲时，若<strong>开启了深度写入</strong>，那么它的深度值也需要写入到深度缓冲中。</li>
<li>当使用透明度混合时，需要<strong>关闭深度写入</strong>（这个部分不再赘述），因此<strong>渲染顺序</strong>也就非常重要。</li>
</ol>
<h3 id="warning："><a href="#warning：" class="headerlink" title="warning："></a>warning：</h3><p>按照<strong>物体</strong>进行排序并不能解决问题，因为如果物体本身存在自身的遮挡或者存在循环遮挡，并没有办法按照<strong>像素</strong>级别进行排序。</p>
<p>如何排序？如何选择一个物体的深度值？（见<strong>OpenGL.md&#x2F;规定模型原点.png</strong>）</p>
<ol>
<li>让模型尽可能是凸面体；</li>
<li>将复杂模型拆分成可以独立排序的多个子模型；</li>
<li>让透明通道更加柔和；</li>
<li>开启深度写入的半透明效果近似模拟物体的半透明。</li>
</ol>
<h2 id="Unity中的渲染排序"><a href="#Unity中的渲染排序" class="headerlink" title="Unity中的渲染排序"></a>Unity中的渲染排序</h2><h3 id="渲染队列"><a href="#渲染队列" class="headerlink" title="渲染队列"></a>渲染队列</h3><ol>
<li>系列整数索引代表每个渲染队列，越小表示越早被渲染。</li>
<li>SubShader中的Queue标签，决定模型归于哪个渲染队列。</li>
<li>Unity预先定义了5个渲染队列（<strong>见书p165</strong>）。</li>
<li>本例选择在Pass中写入ZWrite off。</li>
</ol>
<h2 id="Alpha-Test"><a href="#Alpha-Test" class="headerlink" title="Alpha Test"></a>Alpha Test</h2><p>clip函数：如果给定参数的<strong>任何一个分量是负数</strong>，就会<strong>舍弃当前像素的输出颜色</strong>。</p>
<p>属性中需要添加判断的阈值：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_Cutoff (&quot;Alpha Cutoff&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0.5</span></span><br></pre></td></tr></table></figure>

<p>通常，使用了透明度测试的 Shader 应该在 SubShader 中设置这三个标签：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tags &#123;&quot;Queue&quot;=&quot;AlphaTest&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;TransparentCutout&quot;&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>渲染队列：AlphaTest</li>
<li>Render Type：让 Unity 把这个 Shader 归入到提前定义的组（这里就是 TransparentCutout 组）中，以指明该 Shader 是个使用了透明度测试。Shader RenderType 标签通常被用于着色器替换功能。</li>
<li>IgnoreProjector：设置为 True, 这意味着这个 Shader 不会受到投影器 (Projectors) 的影响。</li>
</ol>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clip (texColor.a - _Cutoff);</span><br></pre></td></tr></table></figure>

<p> clip()：判断texColor.a - _ Cutoff 是否为负数，如果是就会舍弃该片元的输出。也就是说，当 texColor.a 小千材质参数_Cutoff 时，该片元就 会产生完全透明的效果。使用 clip 函数等同于先判断参数是否小于零，如果是就使用 discard 指令 来显式剔除该片元。</p>
<p>Fallback：Transparent&#x2F;Cutout&#x2F;Vertex.Lit，保证可以使用透明度测试的物体正确地向其他物体投射阴影。</p>
<p>缺点：边缘参差不齐，有锯齿（纹理透明度的变化精度问题）。</p>
<h2 id="Alpha-Blend"><a href="#Alpha-Blend" class="headerlink" title="Alpha Blend"></a>Alpha Blend</h2><p>基本和OpenGL的一致，都是将颜色缓冲已有的值和当前片元的颜色值用混合因子进行混合。</p>
<p>使用Unity提供的混合命令：Blend（p169）</p>
<ol>
<li>开启混合</li>
<li>在Pass中使用Blend命令</li>
<li>设置混合因子</li>
</ol>
<p>添加控制整体透明度的属性：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_AlphaScale (&quot;Alpha Scale&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>通常，使用了透明度混合的 Shader 都应该在 SubShader 中设置这3个标签：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>在Pass中设置禁止深度写入以及混合模式：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZWrite Off</span><br><span class="line">Blend SrcAlpha OneMinusSrcAlpha</span><br></pre></td></tr></table></figure>

<p>最后返回值，需要设置正确的alpha通道值：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> fixed4(ambient + diffuse, texColor.a * _AlphaScale);</span><br></pre></td></tr></table></figure>

<p>然后，Unity会根据设置好的<strong>blend模式</strong>以及返回值中该片元的<strong>alpha值</strong>进行混合，得到应该修改的颜色缓冲的值。</p>
<p>使用这种方法，无法解决模型自身有复杂的遮挡关系、包含非凸网格的情况。</p>
<p>如果直接开启深度写入进行复杂半透明模型的渲染，由于物体自身的渲染没有先后顺序，无法控制哪个部分先渲染，哪个部分后渲染，那么有可能会导致：如果物体<strong>自身靠后</strong>的部分先渲染，那么这部分就会被blend；但是如果<strong>自身靠前</strong>的部分先渲染，那么就看不到自身后面的那部分。（本书下节希望的结果是无法看到自身靠后的部分）</p>
<h2 id="自身复杂的模型：开启深度写入的半透明效果"><a href="#自身复杂的模型：开启深度写入的半透明效果" class="headerlink" title="自身复杂的模型：开启深度写入的半透明效果"></a>自身复杂的模型：开启深度写入的半透明效果</h2><p>使用两个Pass来渲染模型：</p>
<ol>
<li>第一个 Pass 开启深度写入，但不输出颜色，它的目的仅仅是为了把该模型的深度值写入深度缓冲中；</li>
<li>第二个 Pass 进行正常的透明度混合，由于上一个 Pass 得到了逐像素的正确的深度信息，该 Pass 就可以按照像素级别的深度排序结果进行透明渲染。</li>
</ol>
<p>上述的操作相当于可以按照这个模型最靠前的部分来渲染，<strong>后面被自身遮挡的都无法通过深度测试</strong>。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line">			ZWrite On</span><br><span class="line">			ColorMask <span class="number">0</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在上节代码的Pass前加上该Pass，用于将模型的深度信息写入到深入缓冲：</p>
<ol>
<li>打开深度写入；</li>
<li>ColorMask用于<strong>设置颜色通道的写掩码</strong>，意味着该Pass不写入任何颜色通道，即不会输出任何颜色。</li>
</ol>
<h2 id="ShaderLab的混合命令"><a href="#ShaderLab的混合命令" class="headerlink" title="ShaderLab的混合命令"></a>ShaderLab的混合命令</h2><p>进行混合的时候，需要使用2个混合等式：</p>
<ol>
<li>混合RGB通道；</li>
<li>混合A通道。</li>
</ol>
<p>每个等式需要2个混合因子，因此一共需要4个混合因子需要设置。<br>$$<br>O_{rgb} &#x3D; SrcFactor<em>S_{rgb}+DstFactor</em>D_{rgb}\<br>O_{a} &#x3D; SrcFactor<em>S_{a}+DstFactor</em>D_{a}<br>$$<br>混合因子可以设置为哪些值？（P174）</p>
<p>下面代码中，逗号前是rgb的混合因子，后面是a通道的混合因子：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Blend SrcAlpha OneMinusSrcAlpha, One Zero</span><br></pre></td></tr></table></figure>

<p>BlendOp BlendOperation：用于设置<strong>混合等式</strong>。（P174）</p>
<p>一些常见的<strong>混合效果</strong>（P175）</p>
<h2 id="双面渲染的透明效果"><a href="#双面渲染的透明效果" class="headerlink" title="双面渲染的透明效果"></a>双面渲染的透明效果</h2><p>前面的shader都是在默认背面剔除的效果下进行的，也就是只渲染了物体的前面，导致没有办法看到透明物体的内部结构。</p>
<p>因此，如果要实现双面渲染的透明效果，那么可以使用cull命令设置剔除哪个面。</p>
<h3 id="Alpha-Test的双面渲染"><a href="#Alpha-Test的双面渲染" class="headerlink" title="Alpha Test的双面渲染"></a>Alpha Test的双面渲染</h3><p>在Pass渲染设置中使用cull关闭剔除。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cull off</span><br></pre></td></tr></table></figure>

<h3 id="Alpha-Blend的双面渲染"><a href="#Alpha-Blend的双面渲染" class="headerlink" title="Alpha Blend的双面渲染"></a>Alpha Blend的双面渲染</h3><p>把双面渲染的工作分成两个 Pass：</p>
<ol>
<li>第一个 Pass 渲染背面；</li>
<li>第二个 Pass 只渲染正面。</li>
</ol>
<p>其实也就是Alpha Blend案例的流程中，再加一个一样的Pass，不过一个先把Front剔除，后一个把Back剔除。</p>
<h1 id="第九章：多光源，阴影，光线衰减"><a href="#第九章：多光源，阴影，光线衰减" class="headerlink" title="第九章：多光源，阴影，光线衰减"></a>第九章：多光源，阴影，光线衰减</h1><p>阐述原理，不能直接用在项目中。</p>
<h2 id="渲染路径"><a href="#渲染路径" class="headerlink" title="渲染路径"></a>渲染路径</h2><p>渲染路径决定了<strong>光照</strong>如何应用到untiy shader中，需要给每个Pass指定它使用的渲染路径，因此Unity才能将所需的<strong>光源</strong>和<strong>处理后的光照</strong>信息放到内置的数据中，使得shader可以访问。</p>
<p>通常使用2种渲染路径：</p>
<ol>
<li>前向渲染路径</li>
<li>延迟渲染路径</li>
</ol>
<blockquote>
<p>大多数情况，一个项目只使用一种渲染路径。在Unity中可以直接设置。  </p>
<p>如果需要使用多个渲染路径，则直接在对应的摄像机中进行设置。  </p>
<p>如果显卡不支持当前所选择的渲染路径，则会自动使用更低一级的渲染路径。  </p>
</blockquote>
<h3 id="设置Pass中的LightMode（P181）"><a href="#设置Pass中的LightMode（P181）" class="headerlink" title="设置Pass中的LightMode（P181）"></a>设置Pass中的LightMode（P181）</h3><p>通过设置渲染路径，可以告诉Unity这个Pass在渲染流程中的位置和次序，以及它在光照计算中所需要的光照信息。底层的渲染引擎则会进行相关的计算并填充一些内置的变量。</p>
<h3 id="前向渲染"><a href="#前向渲染" class="headerlink" title="前向渲染"></a>前向渲染</h3><p>需要在每个Pass中使用标签来指定该Pass使用的渲染路径。使Unity将前向渲染流程中所需要的光照属性准备好。（P181）</p>
<p>如果一个物体在<strong>多个逐像素光源</strong>的影响区域内，那么该物体就需要执行多个 Pass, 每个 Pass 计算一个逐像素光源的光照结果，然后在帧缓冲中把这些光照结果混合起来得到最终的颜色值。假设，场景中有 N个物体，每个物体受 M个光源的影响，那么要渲染整个场景一共需要 N*M个 Pass。</p>
<p>前向渲染的<strong>三种处理光照的方式</strong>，由<strong>光源类型</strong>（平行光、点光源、聚光灯）和<strong>渲染模式</strong>（该光源是否是Important）所决定：</p>
<ol>
<li><p>逐顶点处理</p>
</li>
<li><p>逐像素处理</p>
</li>
<li><p>球谐函数</p>
<p>在前向渲染中，当渲染一个物体时，Unity会根据场景中各个光源的设置以及这些光源对物体的影响程度（距离该物体的远近、 光源强度等）对这些光源进行一个重要度排序。（<strong>判断规则</strong>：P183）</p>
</li>
</ol>
<p>前向渲染的两种Pass（通过标签LightMode来指定）：</p>
<ol>
<li><p>Base Pass：</p>
<ol>
<li>实现光照纹理、环境光、自发光、平行光的阴影；</li>
<li>光照计算：一个最亮的<strong>逐像素</strong>的<strong>平行光</strong>、所有<strong>逐顶点</strong>和<strong>SH</strong>光源。</li>
</ol>
</li>
<li><p>Additional Pass：</p>
<ol>
<li>默认不支持阴影，但是可以通过使用编译指令开启。</li>
<li>光照计算：其他影响该物体的<strong>逐像素</strong>光源，每一个光源执行一次Pass。</li>
</ol>
</li>
</ol>
<blockquote>
<p>需要设置<strong>编译指令</strong>；</p>
<p>环境观和自发光是在Base Pass中计算；</p>
<p>多个逐像素光源会执行一次Additional Pass，所以需要开启和设置混合模式。</p>
<p>通常一个Unity Shader定义一个Base Pass和一个AdditionalPass。</p>
</blockquote>
<p>可以在Shader中访问的内置光照变量以及函数（P184-185）。</p>
<h3 id="顶点照明渲染（略）"><a href="#顶点照明渲染（略）" class="headerlink" title="顶点照明渲染（略）"></a>顶点照明渲染（略）</h3><h3 id="延迟渲染"><a href="#延迟渲染" class="headerlink" title="延迟渲染"></a>延迟渲染</h3><p>前向渲染的问题：若有大量实时光源，针对每个物体需要执行多个Pass，很多计算是重复的。</p>
<p>延迟渲染除了frame buffer和depth buffer，还会使用额外的缓冲：G-buffer，用于存储离摄像机<strong>最近的表面</strong>的包括法线、位置、<strong>用于光照计算的</strong>材质属性等信息。</p>
<p>延迟渲染路径包括两个Pass：</p>
<ol>
<li>第一个Pass不进行光照计算，只将可见的片元的相关信息存储到G缓冲中。渲染每个物体时，这个Pass只会执行一次；</li>
<li>利用G缓冲中的信息进行真正的光照计算。</li>
</ol>
<p>因此，延迟渲染中的Pass数目<strong>和场景中包含的光源数目是没有关系</strong>的，它的效率不依赖于场景的复杂度，而是使用的<strong>屏幕空间的大小</strong>。</p>
<p><strong>缺点</strong>：</p>
<ol>
<li>不支持真正的抗锯齿</li>
<li>不能处理半透明物体</li>
<li>对显卡有要求（P187）</li>
</ol>
<p>G-buffer中的渲染纹理有几种不同的类型（P188）：</p>
<ol>
<li>RT0：存储漫反射颜色，A通道没有被使用；</li>
<li>RT1：存储高光反射颜色，A通道用于存储高光反射的指数部分；</li>
<li>RT2：存储法线，A通道没有被使用；</li>
<li>RT3：用于存储自发光+lightmap+反射探针；</li>
<li>深度缓冲、模板缓冲。</li>
</ol>
<p>可以在Shader中访问的内置光照变量以及函数（P188）。</p>
<h2 id="Unity的光源类型（P189）"><a href="#Unity的光源类型（P189）" class="headerlink" title="Unity的光源类型（P189）"></a>Unity的光源类型（P189）</h2><p>光照的<strong>属性</strong>：位置、方向（针对某点）、颜色、强度、衰减（针对某点）。</p>
<ol>
<li>平行光：_WorldSpaceLightPos0.w&#x3D;0；只有方向，没有位置，没有衰减，光强不会随着距离发生改变；</li>
<li>点光源：有衰减，光强可以根据Unity面板中球体半径Range来调整。</li>
<li>聚光灯：追星区域定义，有半径Range和张开角度Spot Angle所决定。</li>
<li>面光源（仅用于烘焙）</li>
</ol>
<h2 id="案例1-0：前向渲染"><a href="#案例1-0：前向渲染" class="headerlink" title="案例1.0：前向渲染"></a>案例1.0：前向渲染</h2><h3 id="Base-Pass"><a href="#Base-Pass" class="headerlink" title="Base Pass"></a>Base Pass</h3><ol>
<li>设置标签：ForwardBase；</li>
<li>使用#pragma编译指令保证在Shader中使用的光线衰减等光照变量被正确赋值；</li>
<li>fs中计算场景中的环境光；</li>
<li>处理最重要的平行光（<strong>它处理的逐像素光源一定是平行光</strong>，如果没有任何平行光，那么就会当成全黑的光源处理）。<ol>
<li>_WorldSpaceLightPos0得到平行光的方向；</li>
<li>_LightColor0得到颜色和强度相乘后的结果；</li>
<li>没有衰减，atten设置为1.0。</li>
</ol>
</li>
</ol>
<h3 id="Additional-Pass"><a href="#Additional-Pass" class="headerlink" title="Additional Pass"></a>Additional Pass</h3><ol>
<li>设置标签：ForwardAdd；</li>
<li>使用#pragma编译指令；</li>
<li>使用Blend命令开启和设置混合模式，使得该Pass计算得到的光照结果可以在帧缓冲中与之前的光照结果进行叠加，否则，该Pass的光照计算结果会直接覆盖掉帧缓冲已经存入的结果；</li>
<li>一般Additional Pass中的计算和Base Pass中的计算是相同的，只需要把环境光、自发光、逐顶点光照、SH光照的部分去掉，再添加一些对不同光源类型的支持即可。<ol>
<li>AP中处理的光源可以是平行光、点光源或聚光灯；每个逐像素光源按照重要度排序依次调用。</li>
<li>使用#ifdef、#else、#endif进行<strong>不同逐像素光源类型</strong>的处理（Unity会根据当前Pass处理的光源类型进行<strong>相应的宏定义</strong>）。</li>
<li>处理不同光源的衰减：平行光的衰减值为1.0，其他光源涉及到开根、除法等计算量较大的操作，因此Unity选择使<strong>用一张纹理作为查找表</strong>（9.3），在fs中得到光源的衰减。（需要先得到光源空间下的坐标，然后使用该坐标对衰减纹理进行采样得到衰减值）</li>
</ol>
</li>
</ol>
<h3 id="利用frame-debugger来查看渲染事件"><a href="#利用frame-debugger来查看渲染事件" class="headerlink" title="利用frame debugger来查看渲染事件"></a>利用frame debugger来查看渲染事件</h3><p><img src="/images/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/BasePass.png" alt="BasePass"></p>
<p>![frame debugger](images&#x2F;Shader入门精要&#x2F;frame debugger.png)</p>
<p>渲染顺序：</p>
<ol>
<li>clear</li>
<li>Base Pass</li>
<li>Additional Pass</li>
</ol>
<p>Unity处理点光源的<strong>顺序</strong>是按照他们的<strong>重要度排序</strong>的，因为这几个平行光的颜色和强度都相同，因此它们的重要度取决于它们距离胶囊体的远近。</p>
<p>若一个物体不在一个光源的光照范围中，那么Unity是不会为这个物体调用Pass来处理这个光源的。</p>
<p>如果逐像素光源数目很多，那么AP会被调用很多次，<strong>影响性能</strong>。因此如果不想让某个光源被当成逐像素处理，则可以将其Render Mode设置为<strong>Not Important（逐顶点光源）</strong>；但是因为本例没有在Base Pass中计算逐顶点和SH光源，因此场景中的点光源不会对物体产生影响。</p>
<p>如何计算逐顶点和SH光源？利用9.1.1的内置变量和函数进行计算。</p>
<h2 id="Unity的光照衰减"><a href="#Unity的光照衰减" class="headerlink" title="Unity的光照衰减"></a>Unity的光照衰减</h2><p>Unity默认使用<strong>纹理查找</strong>的方式来计算<strong>逐像素的点光源和聚光灯的衰减</strong>。衰减查找纹理的缺点：需要预计算、不直观，无法使用其他数学公式来计算衰减。</p>
<ol>
<li>_LightTexture0对角线上的纹理颜色值，代表在光源空间中不同位置的点的衰减值。</li>
<li>首先需要得到点在光源空间中的位置，通过_LightMatrix0变换矩阵（将顶点从世界空间变换到光源空间）得到。</li>
<li>然后用这个坐标的模（dot，不使用距离值从而避免开方）的平方对衰减纹理进行采样，得到衰减值。</li>
</ol>
<p><strong>warnings</strong>：Unity对使用数学函数进行衰减计算的支持度很低（没有内置光源范围、聚光灯朝向、张开角度等信息），如果用脚本传到Shader，灵活度很低。</p>
<h2 id="Unity的阴影"><a href="#Unity的阴影" class="headerlink" title="Unity的阴影"></a>Unity的阴影</h2><p>让一个物体向其他物体投射阴影；</p>
<p>让一个物体接收来自其他物体的阴影。</p>
<h3 id="Shadow-Map"><a href="#Shadow-Map" class="headerlink" title="Shadow Map"></a>Shadow Map</h3><p>将摄像机<strong>放置于与光源重合的位置</strong>，场景中的该光源的阴影区域就是那些摄像机看不到的地方。如果场景中<strong>最重要的平行光开启了阴影</strong>，那么Unity就会为该光源计算它的shadowMap。它本质上就是一张<strong>深度图</strong>，记录了从该光源的位置出发，能看到的场景中距离它最近的表面的深度信息。</p>
<p>一个额外的ShadowCaster Pass：</p>
<ol>
<li>将摄像机放置于光源位置上；</li>
<li>调用该Pass：通过对顶点变换后得到<strong>光源空间</strong>下的位置，根据该位置输出<strong>深度信息</strong>到Shadow Map中，实现该物体向其他物体投射阴影。</li>
</ol>
<p>传统的shadow map的使用（顶点的采样是在光源空间下的）：</p>
<ol>
<li>在正常Pass中，先计算顶点在光源空间中的三维位置信息；</li>
<li>然后使用xy分量对shadow map进行采样，得到该位置的深度信息。如果得到的值小于该顶点的深度值（通常是z分量），那么说明该点位于阴影中。</li>
</ol>
<h3 id="Screenspace-Shadow-Map（需要显卡支持MRT）"><a href="#Screenspace-Shadow-Map（需要显卡支持MRT）" class="headerlink" title="Screenspace Shadow Map（需要显卡支持MRT）"></a>Screenspace Shadow Map（需要显卡支持MRT）</h3><p>脱胎于延迟渲染。</p>
<ol>
<li>得到可投射阴影的光源的<strong>shadow map</strong>以及摄像机的<strong>深度纹理</strong>；</li>
<li>根据光源的shadow map和摄像机的深度纹理得到<strong>屏幕空间的shadow map</strong>。</li>
</ol>
<p>阴影图的使用（顶点的采样是在屏幕空间中的）：</p>
<ol>
<li>将顶点坐标从模型空间变换到屏幕空间；</li>
<li>利用这个坐标对阴影图进行采样。若摄像机的深度图中记录的表面深度 &gt; 转换到shadow map中的深度值，则说明虽然该表面可见，但是处于该光源的阴影中。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>若一个物体需要接收来自其他物体的阴影，则需要在shader中对shadow map进行采样，并将采样结果和光照计算的最终结果<strong>相乘</strong>；</li>
<li>若想要让一个物体对其他物体投射阴影，就需要将该物体加入到<strong>得到光源对应的shadow map的计算中</strong>，这个过程对应于Unity中的LightMode &#x3D; ShadowCaster的Pass中的渲染流程。如果使用的是Screenspace Shadow Map，那么Unity还会在这个Pass产生一张摄像机的深度纹理。</li>
</ol>
<h2 id="案例2-0：不透明物体的阴影"><a href="#案例2-0：不透明物体的阴影" class="headerlink" title="案例2.0：不透明物体的阴影"></a>案例2.0：不透明物体的阴影</h2><p>Unity中的设置：</p>
<ol>
<li>让平行光可以收集阴影；</li>
<li>设置物体是否cast或receive阴影。<ol>
<li>如果cast shadow &#x3D;&#x3D; on，则该物体会执行ShadowCaster的Pass；</li>
<li>开启receive shadows，调用Unity内置宏和变量计算阴影。</li>
</ol>
</li>
</ol>
<h3 id="ShadowCaster（生成shadow-map）"><a href="#ShadowCaster（生成shadow-map）" class="headerlink" title="ShadowCaster（生成shadow map）"></a>ShadowCaster（生成shadow map）</h3><p>没有自行实现ShadowCaster的Pass时，Fallback会回调到内置“specular”中回调的VertexLit，里面有内置的ShadowCaster的Pass。</p>
<p>因此！为了在不用shader中更加<strong>通用</strong>，因此使用<strong>Fallback</strong>更好（而不是自己实现ShadowCaster）。</p>
<h4 id="现象："><a href="#现象：" class="headerlink" title="现象："></a>现象：</h4><p>竖直的墙没有向下投影，是因为在计算shadow map时会<strong>剔除物体的背面</strong>，而内置的平面只有一个面，在<strong>光源空间</strong>下它没有任何正面，因此需要将其设置为two sided。</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>一个开启阴影生成的光源 + 需要对其他物体投射阴影的物体设置好cast shadow &#x3D;&#x3D; on &#x3D;&gt; shadow map ( + camera depth map)</p>
<h3 id="接收阴影（使用内置宏，在自定义的shader中的pass处理）"><a href="#接收阴影（使用内置宏，在自定义的shader中的pass处理）" class="headerlink" title="接收阴影（使用内置宏，在自定义的shader中的pass处理）"></a>接收阴影（使用内置宏，在自定义的shader中的pass处理）</h3><p><strong>目前只在Base Pass中进行了修改</strong>（9.4.4包含了Additional Pass对阴影的处理）。</p>
<p>在已有的ForwardBase基础上，包含一个新的内置文件：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br></pre></td></tr></table></figure>

<p>顶点输出结构中添加一个内置宏，<strong>声明一个用于shadow map采样的坐标</strong>，参数为<strong>下一个可用的插值寄存器的索引值</strong>：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHADOW_COORDS(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>在vs返回之前添加另一个内置宏，用于计算在vs中<strong>计算上一步中声明的shadow map的坐标</strong>：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRANSFER_SHADOW(o);</span><br></pre></td></tr></table></figure>

<p>在fs中计算阴影值，同样使用一个内置宏：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fixed shadow = SHADOW_ATTENUATION(i);</span><br></pre></td></tr></table></figure>

<p>SHADOW_ COORDS、TRANSFER_SHADOW、SHADOW_ATTENUATION是计算阴影 时的“三剑客”。这些内置宏用于在必要时计算光源的阴影。</p>
<ol>
<li>SHADOW_ COORDS声明一个名为 _ShadowCoord 的阴影纹理坐标变量；</li>
<li>TRANSFER_SHADOW是根据平台的不同计算 _ShadowCoord；</li>
<li>SHADOW_ATTENUATION负责使用 _ShadowCoord 对相关纹理进行采样，得到阴影信息。</li>
</ol>
<h3 id="！宏定义中的变量名匹配"><a href="#！宏定义中的变量名匹配" class="headerlink" title="！宏定义中的变量名匹配"></a>！宏定义中的变量名匹配</h3><p>为了使这些宏正确工作， 需要保证自定义的变量名和这些宏中使用的变量名<strong>相匹配</strong>：</p>
<ol>
<li>a2v结构体中的顶点坐标变量名必须是vertex；</li>
<li>vs输入的结构体a2v必须命名为v；</li>
<li>v2f结构体中顶点位置变量必须命名为pos。</li>
</ol>
<h2 id="统一管理光照衰减和阴影"><a href="#统一管理光照衰减和阴影" class="headerlink" title="统一管理光照衰减和阴影"></a>统一管理光照衰减和阴影</h2><p><strong>光照衰减和阴影都是一个数值与光照结果相乘的到最终的渲染结果</strong>，因此，可以通过内置的UNITY_LIGHT_ATTENUATION宏来同时计算这两个信息。</p>
<p><strong>回顾</strong>一下此前的分开计算的方法：</p>
<blockquote>
<p><strong>光照衰减</strong>，atten因子与光照计算结果相乘：</p>
<p>Base Pass中只有平行光，atten &#x3D; 1.0；</p>
<p>Additional Pass中有点光源、聚光灯，对衰减纹理采样得到atten。</p>
<p><strong>阴影</strong>，阴影因子与光照计算结果相乘：</p>
<p>Base Pass中通过内置宏和函数对Base Pass中对应光源生成的shadow map进行采样得到shadow系数。</p>
</blockquote>
<h3 id="案例3-0"><a href="#案例3-0" class="headerlink" title="案例3.0"></a>案例3.0</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br></pre></td></tr></table></figure>

<ol>
<li>UNITY_LIGHT_ATTENUATION内置宏，用于计算光照衰减和阴影。</li>
<li>Unity针对不同光源类型、是否启用cookie等不同情况声明了多个版本的UNITY_LIGHT_ATTENUATION。</li>
<li>统一了Base Pass和Additional Pass，不需要在Additional Pass中单独处理光照衰减，也不需要在Base Pass中单独处理阴影。</li>
</ol>
<p>现在已经可以实现在Base Pass和Additional Pass中进行<strong>统一的光照衰减因子以及阴影因子的计算</strong>。</p>
<p>但是若是想要<strong>添加Additional Pass中光源的阴影效果</strong>（生成对应的shadow map），那么就需要使用 #pragma multi_compile _ fwdadd _ fullshadows 编译指令来代替 Additional Pass #pragma multi_ compile_ fwdadd 指令。这样一来 Unity 也会为这些额外的逐像素光源计算阴影，并传递给 Shader。</p>
<h2 id="透明物体的阴影"><a href="#透明物体的阴影" class="headerlink" title="透明物体的阴影"></a>透明物体的阴影</h2><p>对大部分不透明物体：Fallback设置为VertexLit就可以得到正确的阴影，但是对于不透明物体，因为它们通常要使用透明度测试和透明度混合，所以要小心设置Fallback。</p>
<h3 id="案例4-0：AlphaTest"><a href="#案例4-0：AlphaTest" class="headerlink" title="案例4.0：AlphaTest"></a>案例4.0：AlphaTest</h3><p>沿用AlphaTest的shader代码，向内加入接收shadow的相关函数。</p>
<p>将Fallback改为VertexLit，镂空区域会出现不正常的阴影。因此，需要一个有透明度测试功能的ShadowCaster Pass：Unity内置Shader——Transparent&#x2F;Cutout&#x2F;VertexLit。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通的ShadowCaster Pass</span></span><br><span class="line">FallBack &quot;VertexLit&quot;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有透明度测试功能的ShadowCaster Pass</span></span><br><span class="line"><span class="comment">// 需要提供名为_Cutoff的属性来进行透明度测试</span></span><br><span class="line">FallBack &quot;Transparent/Cutout/VertexLit&quot;</span><br></pre></td></tr></table></figure>

<p>有些不应该透光的部分透过了光，这是因为渲染得到的深度图和shadow map<strong>只考虑了对应参考系下物体的正面</strong>，但是本例中的物体应该看做一个双面的物体，背面也不应该透光，因此将Cast Shadows属性设置为Two Sided，强制计算所有面的深度信息。</p>
<h3 id="案例5-0：AlphaBlend"><a href="#案例5-0：AlphaBlend" class="headerlink" title="案例5.0：AlphaBlend"></a>案例5.0：AlphaBlend</h3><p><strong>因为透明混合需要关闭深度写入，并且必须按照从后至前的顺序进行渲染，因此阴影的计算是一件非常麻烦的事情。</strong>因此，Unity没有针对这类物体内置Fallback shader，如果<strong>强制设置为不透明物体的Fallback shader</strong>，并不会实现穿透物体投影到下放平面的效果，这是不正确的。</p>
<h1 id="第十章：高级贴图"><a href="#第十章：高级贴图" class="headerlink" title="第十章：高级贴图"></a>第十章：高级贴图</h1><h2 id="立方体纹理"><a href="#立方体纹理" class="headerlink" title="立方体纹理"></a>立方体纹理</h2><p>作用：是<strong>环境映射</strong>的一种实现方法。</p>
<p>使用：需要一个世界空间下的三位纹理坐标用于采样。</p>
<p>优缺点：</p>
<ol>
<li>简单快速；</li>
<li>场景发生了<strong>变化</strong>时，就需要重新生成立方体纹理；</li>
<li>立方体纹理只能反映环境，但不能反应使用了该立方体纹理的物体本身，它<strong>无法模拟多次反射的结果</strong>（18章GI全局光照可以实现自反射效果）。因此，尽量不要对凹面体使用立方体纹理。</li>
</ol>
<h3 id="天空盒"><a href="#天空盒" class="headerlink" title="天空盒"></a>天空盒</h3><p><strong>Unity设置：</strong></p>
<p>Unity-&gt;Material-&gt;Unity Shader-&gt;Skybox-&gt;6 Sided</p>
<p>Wrap Mpde &#x3D; Clamp</p>
<p>Tint Color：整体颜色</p>
<p>Exposure：天空盒亮度</p>
<p>Rotation：调整天空盒沿+y轴方向的旋转角度</p>
<p><strong>相机设置：</strong></p>
<ol>
<li>clear flags &#x3D; skybox</li>
<li>不同的camera若要使用不同的skybox，可以添加skybox component</li>
</ol>
<p><strong>渲染顺序：</strong></p>
<p>天空盒在所有不透明物体后渲染的，使用的mesh是一个立方体或一个细分后的球体。</p>
<h3 id="环境映射"><a href="#环境映射" class="headerlink" title="环境映射"></a>环境映射</h3><p><strong>作用：</strong></p>
<p>模拟出<strong>金属质感</strong>的材质。</p>
<p><strong>创建方法：</strong></p>
<ol>
<li>要提供一张具有特殊布局的纹理，例如类似立方体展开图的交叉布局、全景布局等。然后，我们只需要把该纹理的 Texture type 设置为 Cubemap 即可， Unity 会为我们做好剩下的事情。在基于物理的渲染中，我们通常会使用 HDR 图像来生成高质 Cubemap( 详见第 18 章）。读者可在官方文档(<a target="_blank" rel="noopener" href="http://docs.unity3d.com/Manual/class-Cubemap.html">http://docs.unity3d.com/Manual/class-Cubemap.html</a>) 中找到更多的资料。</li>
<li>Unity5之前的方法，略。</li>
<li>希望根据物体在场景中位置的不同，生成它们各自不同的立方体纹理，这时，可以在 Unity 中使用脚本来创建。这是通过利用 Unity 提供的 Camera.RenderToCubemap 函数来实现的，该函数可以把<strong>从任意位置观察到的场景图像存储到6张图像中，从而创建出该位置上对应的立方体纹理</strong>。</li>
</ol>
<p>根据第三种方法：在renderFromPosition (由用户指定）位置处动态创建一个摄像机，并调用 Camera.RenderToCubemap 函数把从当前位置观察到的图像渲染到用户指定的立方体纹理 cubemap 中，完成后再销毁临时摄像机。（具体流程见P212-213）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnWizardCreate</span> ()</span> &#123;</span><br><span class="line"><span class="comment">// create temporary camera for rendering</span></span><br><span class="line">GameObject go = <span class="keyword">new</span> GameObject( <span class="string">&quot;CubemapCamera&quot;</span>);</span><br><span class="line">go.AddComponent&lt;Camera&gt;();</span><br><span class="line"><span class="comment">// place it on the object</span></span><br><span class="line">go.transform.position = renderFromPosition.position;</span><br><span class="line"><span class="comment">// render into cubemap		</span></span><br><span class="line">go.GetComponent&lt;Camera&gt;().RenderToCubemap(cubemap);</span><br><span class="line"></span><br><span class="line"><span class="comment">// destroy temporary camera</span></span><br><span class="line">DestroyImmediate( go );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>方法：通过入射光线和表面法线方向计算反射方向，然后利用反射方向对立方体纹理采样。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// properties</span></span><br><span class="line">_ReflectColor (&quot;Reflection Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 反射颜色</span></span><br><span class="line">_ReflectAmount (&quot;Reflect Amount&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span> <span class="comment">// 反射程度</span></span><br><span class="line">_Cubemap (&quot;Reflection Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125; <span class="comment">// 用于模拟反射的环境映射纹理</span></span><br></pre></td></tr></table></figure>

<h4 id="计算反射方向："><a href="#计算反射方向：" class="headerlink" title="计算反射方向："></a>计算反射方向：</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o.worldRefl = <span class="built_in">reflect</span>(-o.worldViewDir, o.worldNormal);</span><br></pre></td></tr></table></figure>

<h4 id="采样："><a href="#采样：" class="headerlink" title="采样："></a>采样：</h4><p>用反射方向对立方体纹理采样（采样用的方向向量不用归一化），使用_ReflectAmount <strong>混合</strong>漫反射颜色和反射颜色，并和环境光照相加后返回：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fixed3 reflection = texCUBE(_Cubemap, i.worldRefl).rgb * _ReflectColor.rgb;</span><br><span class="line">fixed3 color = ambient + lerp(diffuse, reflection, _ReflectAmount) * atten;</span><br></pre></td></tr></table></figure>

<p>什么时候计算反射方向？vs计算反射方向：效率高；fs计算反射方向：更细腻。</p>
<h4 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h4><ol>
<li>先在<strong>物体处放置摄像头</strong>，用Camera.RenderToCubemap(cubemap)<strong>生成需要使用的立方体纹理</strong>；</li>
<li><strong>然后在物体需要使用的材质shader中导入该立方体贴图</strong>。</li>
</ol>
<h3 id="折射"><a href="#折射" class="headerlink" title="折射"></a>折射</h3><p>利用斯涅耳定律计算反射角：<br>$$<br>n_1sinθ_1&#x3D;n_2sinθ_2\<br>n_1和n_2分别是两个介质的折射率<br>$$<br>两次折射比较复杂，因此只模拟一次进入物体的折射（因为看起来是对的，那么它就是对的）。</p>
<p>计算折射方向，refract函数的第一个参数即为入射光线的方向，它必须是归一化后的矢量；第二个参数是表面法线，法线方向同样需要是归一化后的；第三个参数是入射光线所在介质的折射率和折射光线所在介质的折射率之间的比值，例如如果光是从空气射到 玻璃表面，那么这个参数应该是空气的折射率和玻璃的折射率之间的比值 1&#x2F;1.5 。它的返回值 就是计算而得的折射方向，它的模则等于入射光线的模：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o.worldRefr = <span class="built_in">refract</span>(-<span class="built_in">normalize</span>(o.worldViewDir), <span class="built_in">normalize</span>(o.worldNormal), _RefractRatio);</span><br></pre></td></tr></table></figure>

<p>对立方体贴图在折射方向上采样（采样用的方向向量不用归一化），然后用_RefractAmount将漫反射颜色和折射颜色进行混合：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fixed3 refraction = texCUBE(_Cubemap, i.worldRefr).rgb * _RefractColor.rgb;</span><br><span class="line">fixed3 color = ambient + lerp(diffuse, refraction, _RefractAmount) * atten;</span><br></pre></td></tr></table></figure>

<h3 id="菲涅尔反射"><a href="#菲涅尔反射" class="headerlink" title="菲涅尔反射"></a>菲涅尔反射</h3><p>可用于根据视角控制反射的程度，是基于物理的渲染中非常重要的一项高光反射计算因子（Chapter18）。</p>
<p>其中一个著名的近似公式就 Schlick 菲涅耳近似等式：<br>$$<br>F_{schlick}(v,n)&#x3D;F_0+(1-F_0)(1-v·n)^5<br>$$<br>其中，F0是一个反射系数，用于控制菲涅耳反射的强度， v是视角方向， n是表面法线。另一个应用比较广泛的等式是 Empricial 菲涅耳近似等式：<br>$$<br>F_{Empricial}(v,n)&#x3D;max(0,min(1,bias+scale×(1-v·n)^{power}))<br>$$<br>其中， bias scale power 是控制项。 使用上面的菲涅耳近似等式，我们可以在边界处模拟反射光强和折射光强／漫反射光强之间的变化。在许多车漆、水面等材质的渲染中，我们会经常使用菲涅耳反射来模拟更加真实的反 射效果。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用Schlick近似等式计算fresnel项，并用其混合diffuse和reflction颜色</span></span><br><span class="line">fixed fresnel = _FresnelScale + (<span class="number">1</span> - _FresnelScale) * <span class="built_in">pow</span>(<span class="number">1</span> - <span class="built_in">dot</span>(worldViewDir, worldNormal), <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">fixed3 diffuse = _LightColor0.rgb * _Color.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">fixed3 color = ambient + lerp(diffuse, reflection, saturate(fresnel)) * atten;</span><br></pre></td></tr></table></figure>

<p>当我们把_ Fresnel Scale &#x3D; 1时，物体将完全反射 cubemap 中的图像；当_FresnelScale &#x3D; 0 时，则是一个具有边缘光照效果的漫反射物体。</p>
<h2 id="渲染纹理"><a href="#渲染纹理" class="headerlink" title="渲染纹理"></a>渲染纹理</h2><p>（应该是类似opengl中渲染附件中的纹理）</p>
<ol>
<li>之前的学习中，一个摄像机的渲染结果直接输出到颜色缓冲，并显示到屏幕上；</li>
<li>现代GPU允许把整个场景渲染到渲染目标纹理中（RTT），而不是传统的帧缓冲；</li>
<li>多重渲染目标（MRT）指GPU允许将场景同时渲染到多个渲染目标纹理中，而不需要为每个渲染目标纹理单独渲染完整的场景；延迟渲染是MRT的一个应用。</li>
</ol>
<p>渲染纹理（Render Texture）是Unity专门为渲染目标纹理定义的一种纹理类型，有<strong>两种使用方法</strong>：</p>
<ol>
<li>是在 Project 目录下Create-&gt;Render Texture创建一个<strong>渲染纹理</strong>，然后把某个摄像机的渲染目标设置成该渲染纹理，这样一来该摄像机的渲染结果就会实时更新到渲染纹理中， 而不会显示在屏幕上。使用这种方法，我们还可以选择渲染纹理的分辨率、滤波模式等纹理属性；</li>
<li>是在屏幕后处理时使用 <strong>GrabPass</strong> 命令或 <strong>OnRenderimage</strong> 函数来<strong>获取当前屏幕图像</strong>， Unity 会把这个屏幕图像放到一张和屏幕分辨率等同的渲染纹理中，之后可以在自定义的 Pass 中把它们当成普通的纹理来处理，从而实现各种屏幕特效。</li>
</ol>
<p>我们将依次学习这两种方法在 Unity 中的实现，OnRenderlmage 函数会在第 12 章中讲到）。</p>
<h3 id="镜子效果"><a href="#镜子效果" class="headerlink" title="镜子效果"></a>镜子效果</h3><p><strong>流程</strong>：</p>
<ol>
<li>新建一个render texture；</li>
<li>新建一个camera，将其Target Texture设置为上面这个texture；调整摄像机，将它渲染得到的内容作为镜子显示的内容；</li>
<li>编写shader，将这个render texture作为输入属性，并将其在水平方向反转后直接显示在物体上。</li>
</ol>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">o.uv = v.texcoord;</span><br><span class="line"><span class="comment">// Mirror needs to filp x</span></span><br><span class="line">o.uv.x = <span class="number">1</span> - o.uv.x;</span><br></pre></td></tr></table></figure>

<p>在上面的实现中，我们把渲染纹理的分辨率大小设置为 256*256 。有时，这样的分辨率会使图像模糊不清。此时我们可以使用更高的分辨率或更多的抗锯齿采样等。但需要注意的是，更高的分辨率会影响带宽和性能，我们应当尽量使用较小的分辨率。</p>
<h3 id="玻璃效果"><a href="#玻璃效果" class="headerlink" title="玻璃效果"></a>玻璃效果</h3><p>GrabPass 可以完成获取屏幕图像的目的，Unity 会把当前屏幕的图像绘制在 一张纹理中 ，以便我们在后续的 Pass 中访问它 。</p>
<p>我们通常会使用 GrabPass 来实现诸如玻璃等透明材质的模拟，与使用简单的透明混合不同，<strong>使用 GrabPass 可以让我们对该物体后面的图像进行更复杂的处理，例如使用法线来模拟折射效果，而不再是简单的和原屏幕颜色进行混合。</strong></p>
<p>需要将渲染队列设置为Transparent，这样可以保证当渲染该物体时，不透明的物体已经被绘制。</p>
<p><strong>总结</strong>：</p>
<ol>
<li><p>定义主纹理、法线纹理、用于反射的CubeMap（用脚本在球所在的位置生成）；</p>
</li>
<li><p>定义GrabPass，并定义GrabPass需要生成的sampler2D纹理；随后通过o.scrPos &#x3D; ComputeGrabScreenPos(o.pos);得到被抓取的屏幕图像的采样坐标；</p>
</li>
<li><p>因为需要用到法线纹理，进行<strong>世界空间</strong>下的光照计算，故在vs中：</p>
<ol>
<li>先将切线，法线从模型空间转换到世界空间中，然后推算出副切线；</li>
<li>然后将<code>M切线-&gt;世界</code>通过切线，副切线，法线按列排列得到；</li>
<li>w轴存储世界坐标系下的顶点坐标；</li>
</ol>
</li>
<li><p>在fs中：</p>
<ol>
<li><p>通过对法线纹理采样得到值，然后通过UnpackNormal得到切线空间下的法线方向；</p>
</li>
<li><p>使用切线空间下的法线方向来进行偏移，从而反应顶点局部空间下的法线方向。随后对scrPos进行透视除法得到真正的屏幕坐标，再根据这个坐标<strong>对抓取的屏幕图像进行采样</strong>，得到模拟的<strong>折射</strong>颜色：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float2 <span class="keyword">offset</span> = bump.xy * _Distortion * _RefractionTex_TexelSize.xy;</span><br><span class="line">i.scrPos.xy = <span class="keyword">offset</span> * i.scrPos.z + i.scrPos.xy;</span><br><span class="line">fixed3 refrCol = tex2D(_RefractionTex, i.scrPos.xy/i.scrPos.w).rgb;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将法线变换到世界坐标系下，计算得到反射方向，然后用该方向对<strong>CubeMap</strong>进行采样，将其与主纹理采样得到的颜色相乘，得到<strong>反射</strong>颜色。</p>
</li>
<li><p>最后，使用_RefractAmount将反射、折射颜色混合，作为最后输出的颜色。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fixed3 finalColor = reflCol * (<span class="number">1</span> - _RefractAmount) + refrCol * _RefractAmount;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h4 id="GrabPass的名字，是空还是自定义？"><a href="#GrabPass的名字，是空还是自定义？" class="headerlink" title="GrabPass的名字，是空还是自定义？"></a>GrabPass的名字，是空还是自定义？</h4><p>各有有优缺点（P224）</p>
<h3 id="渲染纹理vs-GrabPass"><a href="#渲染纹理vs-GrabPass" class="headerlink" title="渲染纹理vs. GrabPass"></a>渲染纹理vs. GrabPass</h3><ol>
<li>GrabPass 的好处在于实现简单，我们只需要在 Shader 中写几行代码 就可以实现抓取屏幕的目的（在shader中，在每一帧第一个使用该纹理的物体执行一次抓取屏幕的操作）。而要使用渲染纹理的话，我们首先需要创建一个渲染纹理和一个额外的摄像机，再把该摄像机的 Render Target 设置为新建的渲染纹理对象，最后把该渲染纹理传递 给相应的 Shader。</li>
<li>但从效率上来讲，使用渲染纹理的效率往往要好于 GrabPass, 尤其在移动设备上，可自定义渲染纹理大小，但GrabPass确不可以。</li>
<li>拓展：Command Buffers，也可以实现类似抓屏的效果。</li>
</ol>
<h2 id="程序纹理"><a href="#程序纹理" class="headerlink" title="程序纹理"></a>程序纹理</h2><p>用特定的算法创造图案，这些属性不只是颜色属性，甚至可以是完全不同类型的图案属性。</p>
<p><strong>制作方法</strong>：</p>
<ol>
<li><p>使用c#脚本给材质赋予程序生成的纹理；</p>
<ol>
<li>新建mat文件，绑定singleTextureShader，但Texture需要在脚本中生成；</li>
<li>c#脚本的编写需要使用一个开源插件<code>SetProperty</code>，从而在面板上修改属性时仍可以执行set函数（但是修改属性之后依旧需要play之后，才能在editor上看到修改后的效果）；</li>
<li>声明material -&gt; 声明renderer并绑定component中的renderer -&gt; 使用sharedMaterial绑定material -&gt; <strong>自行实现生成纹理的算法</strong> -&gt; 使用material.SetTexture绑定生成的程序纹理（需要指定shader中的材质属性，类似OpenGL）。</li>
</ol>
</li>
<li><p>Substance Designer&#x2F; Substance Painter</p>
<ol>
<li><p>专用程序纹理的材质：程序材质，使用Substance Designer生成.sbsar文件；</p>
</li>
<li><p>需要在Assets Store中导入<code>Substance in Unity</code>插件（<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/99362830">Substance in Unity - 知乎 (zhihu.com)</a>）目前已经被弃用，换用<code>Substance 3D for Unity</code>（<a target="_blank" rel="noopener" href="https://github.com/candycat1992/Unity_Shaders_Book/issues/258">程序材质在unity2019.1.0被废弃了 · Issue #258 · candycat1992&#x2F;Unity_Shaders_Book · GitHub</a>），然后将.sbsar文件导入unity后，生成一个程序纹理资源，一个资源可以包含一个或多个程序材质；</p>
</li>
<li><p>我们可以在Unity中以两种方式来使用SD生成的纹理：</p>
<ol>
<li><strong>直接以传统纹理的方式</strong><br>利用SD直接导出纹理或者在Unity中从sbsar上导出纹理都可以，这种方式只是把SD当成<strong>纯作图工具</strong>来使用，并没有使用到程序化参数的概念。</li>
<li><strong>程序化纹理使用的方式</strong><br>利用Allegorithmic官方出品的插件，集成进Unity中，在Unity中使用<strong>可动态调整的程序化纹理</strong>。</li>
</ol>
</li>
<li><p>可以通过调整程序纹理的属性来控制纹理的外观，非常多变，比如在程序运行时动态修改纹理的属性，生成动画等。<strong>运行时动态生成</strong>：</p>
<p>除了在Unity编缉器下控制参数以外，我们还可以在游戏打包到指定平台上运行时通过代码动态的去调整参数。</p>
<p>控制的脚本须引入Substance的命名空间</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Substance.Game;</span><br></pre></td></tr></table></figure>

<p>然后通过以下方法来动态更改：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mySubstance.Set... <span class="comment">//有好多Set，自己看着用</span></span><br><span class="line">mySubstance.QueueForRender ();</span><br><span class="line">Substance.Game.Substance.RenderSubstancesAsync ();</span><br></pre></td></tr></table></figure>

<p>不过这种情况下，会产生延迟，具体时间取决于你的硬件性能，因为图片的动态生成需要时间。</p>
<p>如果你需要在游戏运行时生成纹理的话，那么一定要注意SD中节点的耗时，这会直接影响运行时生成的时间。</p>
<p>SD虽说是程序化的数据，但是在游戏运行时，内存中还是一张张的纹理，这和传统的纹理内存并没有什么不一样。</p>
</li>
</ol>
</li>
</ol>
<h2 id="回顾："><a href="#回顾：" class="headerlink" title="回顾："></a>回顾：</h2><p>材质 &#x3D; 贴图 + shader，其中，shader利用输入的贴图和一些其他的材质属性进行shading光照计算，得出像素的颜色值；（言外之意：尽管使用同一个shader，也即使用相同的shading光照计算，但使用不同的贴图、shader参数值 &#x3D; 一个新的material）。</p>
<p><strong>传统的材质</strong>虽然可以在shader中修改贴图的颜色，但是需要外置参数的传入才可以进行控制修改的程度（不会生成新的贴图），相对来说不够统一；</p>
<p>而<strong>程序材质</strong>是根据打包好的算法，根据设定的参数生成程序纹理后给shader用，虽然也需要脚本对参数的修改（生成新的贴图），但是相对而言更加统一，贴图的管理更加方便。</p>
<h1 id="第十一章：纹理动画"><a href="#第十一章：纹理动画" class="headerlink" title="第十一章：纹理动画"></a>第十一章：纹理动画</h1><p>在shader中引入<strong>时间变量</strong>，实现<strong>动画</strong>效果。</p>
<h2 id="shader中的内置时间变量"><a href="#shader中的内置时间变量" class="headerlink" title="shader中的内置时间变量"></a>shader中的内置时间变量</h2><p>内置函数：P230</p>
<h2 id="纹理动画"><a href="#纹理动画" class="headerlink" title="纹理动画"></a>纹理动画</h2><p>使用纹理动画代替粒子系统等模拟动画效果，效率更高。</p>
<h3 id="序列帧动画"><a href="#序列帧动画" class="headerlink" title="序列帧动画"></a>序列帧动画</h3><ol>
<li>播放关键帧图像，调整播放速度，达到连续动画的效果。</li>
<li>灵活性强，不需要物理计算，但美术工作量大。</li>
<li>需要提供一张包含了关键帧图像的图像。</li>
</ol>
<h4 id="案例1-0"><a href="#案例1-0" class="headerlink" title="案例1.0"></a>案例1.0</h4><p>将序列帧纹理当做透明物体、关闭深度写入、设置混合模式。</p>
<p>_HorizontalAmount和 _VerticalAmount的设置会影响纹理采样的结果，渲染结果的行列数 &#x3D; 序列帧纹理的行列数 &#x2F; 这个amount参数。</p>
<p>注意，序列帧纹理的warp mode是<strong>repeat</strong>，重点在于<strong>fs</strong>中的uv坐标的计算：</p>
<ol>
<li>先将内置时间和speed相乘后取整，得到整数的模拟时间；</li>
<li>然后用时间除以_HorizontalAmount得到行序数，余数为列序数；</li>
<li>根据索引构建真正的采样坐标：<ol>
<li>首先将uv坐标除以Amount得到左下角那一块的坐标值；</li>
<li>然后通过计算出的索引得到应该移动的offset（小块的间隔是1 &#x2F; Amount，因为uv坐标单位是1）得到真正的采样坐标；</li>
<li>注意：uv在y方向上是减，因为uv坐标从左下开始，序列帧纹理索引从左上开始。</li>
<li>然后根据计算出来的坐标对序列帧纹理进行采样；</li>
</ol>
</li>
<li>Fallback设置为Tansparent&#x2F; VertexLit。</li>
</ol>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target &#123;</span><br><span class="line"><span class="type">float</span> time = <span class="built_in">floor</span>(_Time.y * _Speed);  </span><br><span class="line"><span class="type">float</span> row = <span class="built_in">floor</span>(time / _HorizontalAmount);</span><br><span class="line"><span class="type">float</span> column = time - row * _HorizontalAmount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//				half2 uv = float2(i.uv.x /_HorizontalAmount, i.uv.y / _VerticalAmount);</span></span><br><span class="line"><span class="comment">//				uv.x += column / _HorizontalAmount;</span></span><br><span class="line"><span class="comment">//				uv.y -= row / _VerticalAmount;</span></span><br><span class="line">half2 uv = i.uv + half2(column, -row);</span><br><span class="line">uv.x /=  _HorizontalAmount;</span><br><span class="line">uv.y /= _VerticalAmount;</span><br><span class="line"></span><br><span class="line">fixed4 c = tex2D(_MainTex, uv);</span><br><span class="line">c.rgb *= _Color;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="滚动的背景"><a href="#滚动的背景" class="headerlink" title="滚动的背景"></a>滚动的背景</h3><p>正交投影、多层不同速度滚动模拟视差。</p>
<h4 id="案例2-0"><a href="#案例2-0" class="headerlink" title="案例2.0"></a>案例2.0</h4><p>在vs中修改uv，<strong>uv的x增大，在视觉上相当于图片从右至左移动</strong>，因此也要把纹理的warp mode设置为repeat。</p>
<p>_ScrollX， _Scroll2X控制移动速度，一般背景移动慢一些（本例为0.1），前景移动快一些（本例为0.15）。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (a2v v) &#123;</span><br><span class="line">v2f o;</span><br><span class="line">o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex) + frac(float2(_ScrollX, <span class="number">0.0</span>) * _Time.y);</span><br><span class="line">o.uv.zw = TRANSFORM_TEX(v.texcoord, _DetailTex) + frac(float2(_Scroll2X, <span class="number">0.0</span>) * _Time.y);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在fs中用lerp函数决定采样的颜色（secondLayer.a是lerp的系数，0的时候取背景firstLayer，1的时候取前层secondLayer），_Multiplier调整亮度：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fixed4 c = lerp(firstLayer, secondLayer, secondLayer.a);</span><br><span class="line">c.rgb *= _Multiplier;</span><br></pre></td></tr></table></figure>

<h3 id="顶点动画"><a href="#顶点动画" class="headerlink" title="顶点动画"></a>顶点动画</h3><p>模拟飘动的旗帜、流动的小溪。</p>
<h4 id="案例3-0：流动的河流"><a href="#案例3-0：流动的河流" class="headerlink" title="案例3.0：流动的河流"></a>案例3.0：流动的河流</h4><p>用案例给的物体模型，直接用quad会有问题。</p>
<p>camera设置<strong>正交</strong>投影；纹理warp mode &#x3D; <strong>repeat</strong>，当做<strong>透明</strong>物体处理。</p>
<p>需要加入一个新标签：<strong>DisableBatching</strong>，用于<strong>取消批处理</strong>，因为批处理会合并所有相关模型（生成一个大模型），导致这些模型各自的模型空间的丢失。</p>
<p>因为本例需要在物体的模型空间下对顶点的位置进行偏移，因此需要取消对该shader的批处理。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot; &quot;DisableBatching&quot;=&quot;True&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>关闭深度写入，设置混合模式，<strong>关闭剔除（水流的每个面都显示）</strong>。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZWrite Off</span><br><span class="line">Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">Cull Off</span><br></pre></td></tr></table></figure>

<ol>
<li>在<strong>vs</strong>中<strong>改变顶点在模型空间下的位置，从而直接影响裁剪空间中的位置</strong>；</li>
<li>更改uv的坐标，用于移动河流纹理（<strong>原本物体建模时短边为x，长边为y，导入unity之后旋转了90度</strong>，因此offset是在y方向上变化）：</li>
</ol>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">v2f vert(a2v v) &#123;</span><br><span class="line">v2f o;</span><br><span class="line"></span><br><span class="line">float4 <span class="keyword">offset</span>;</span><br><span class="line"><span class="keyword">offset</span>.yzw = float3(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="keyword">offset</span>.x = <span class="built_in">sin</span>(_Frequency * _Time.y + v.vertex.x * _InvWaveLength + v.vertex.y * _InvWaveLength + v.vertex.z * _InvWaveLength) * _Magnitude;<span class="comment">// 更改x的位置，是因为案例中给出的物体的模型空间下，长对应着z轴，宽对应着x轴（推理并测试过了）</span></span><br><span class="line">o.pos = UnityObjectToClipPos(v.vertex + <span class="keyword">offset</span>);</span><br><span class="line"></span><br><span class="line">o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">o.uv +=  float2(<span class="number">0.0</span>, _Time.y * _Speed);<span class="comment">// y方向上变化是因为纹理的y方向上是竖条</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="广告牌"><a href="#广告牌" class="headerlink" title="广告牌"></a>广告牌</h3><p><strong>根据视角方向旋转</strong>一个被纹理着色的多边形，使得多边形<strong>看起来总是面对摄像机</strong>。可用于渲染烟雾、云朵、闪光效果等。</p>
<p>本质是构建<strong>旋转矩阵</strong>：</p>
<ol>
<li>一个变换矩阵需要三个基向量，通常是normal、up、right。一般是通过指定normal和up其中的一个<strong>固定</strong>。若假设normal固定：首先，需要根据初始表面的normal和指向上的方向up叉乘出right；归一化后，再用normal和right叉乘得到up。</li>
<li>同时还需要制定一个锚点，这个锚点在旋转过程中是固定不变的，以此确定多边形在空间中的位置。</li>
</ol>
<h4 id="案例4-0"><a href="#案例4-0" class="headerlink" title="案例4.0"></a>案例4.0</h4><p>camera设置<strong>正交</strong>投影；纹理warp mode &#x3D; <strong>repeat</strong>，当做<strong>透明</strong>物体处理。</p>
<p>需要加入一个新标签：<strong>DisableBatching</strong>，用于<strong>取消批处理</strong>，因为批处理会合并所有相关模型（生成一个大模型），导致这些模型各自的模型空间的丢失。</p>
<p>因为本例需要在<strong>物体在模型空间下的位置作为锚点</strong>进行计算，因此需要取消对该shader的批处理。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot; &quot;DisableBatching&quot;=&quot;True&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>关闭深度写入，设置混合模式，<strong>关闭剔除（广告牌的每个面都显示）</strong>。</p>
<p><strong>vs</strong>中进行核心计算，所有计算都是在<strong>物体的模型空间</strong>下进行的：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (a2v v) &#123;</span><br><span class="line">    v2f o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Suppose the center in object space is fixed</span></span><br><span class="line">    float3 center = float3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    float3 viewer = mul(unity_WorldToObject,float4(_WorldSpaceCameraPos, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    float3 normalDir = viewer - center;</span><br><span class="line">    <span class="comment">// If _VerticalBillboarding equals 1, we use the desired view dir as the normal dir</span></span><br><span class="line">    <span class="comment">// Which means the normal dir is fixed</span></span><br><span class="line">    <span class="comment">// Or if _VerticalBillboarding equals 0, the y of normal is 0</span></span><br><span class="line">    <span class="comment">// Which means the up dir is fixed</span></span><br><span class="line">    normalDir.y = normalDir.y * _VerticalBillboarding;</span><br><span class="line">    normalDir = <span class="built_in">normalize</span>(normalDir);</span><br><span class="line">    <span class="comment">// Get the approximate up dir</span></span><br><span class="line">    <span class="comment">// If normal dir is already towards up, then the up dir is towards front</span></span><br><span class="line">    float3 upDir = <span class="built_in">abs</span>(normalDir.y) &gt; <span class="number">0.999</span> ? float3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>) : float3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    float3 rightDir = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(upDir, normalDir));</span><br><span class="line">    upDir = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(normalDir, rightDir));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the three vectors to rotate the quad</span></span><br><span class="line">    float3 centerOffs = v.vertex.xyz - center;</span><br><span class="line">    float3 localPos = center + rightDir * centerOffs.x + upDir * centerOffs.y + normalDir * centerOffs.z;</span><br><span class="line"></span><br><span class="line">    o.pos = UnityObjectToClipPos(float4(localPos, <span class="number">1</span>));</span><br><span class="line">    o.uv = TRANSFORM_TEX(v.texcoord,_MainTex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>将模型空间下的(0, 0, 0)作为锚点；</li>
<li>计算模型空间下的camera位置；</li>
<li>将从锚点指向camera的方向作为normal方向；</li>
<li>根据_VerticalBillboarding控制垂直方向上的约束度：<ol>
<li>等于1时意味着将法线方向固定位视角方向；</li>
<li>等于0时意味着将向上方向固定为(0, 1, 0)；接着对normal归一化；</li>
<li>因为<strong>quad并没有旋转</strong>，正面朝向x正方向，因此<strong>camera需要放到一个比较高的地方，并向下旋转才可以看到比较明显的区别</strong>。</li>
</ol>
</li>
<li>然后判断normal是否几乎和up平行，如果是，那么up等于(0, 0, 1)；否则为(0, 1, 0)；</li>
<li>然后根据normal和up的叉乘得到right；</li>
<li>再由normal和right叉乘得到up；</li>
<li>最后根据顶点原始位置相对于锚点的偏移量以及三个正交基，得到新的顶点位置；最后将这个位置变换到裁剪空间中。<ol>
<li>这一步相当于就是将物体从模型空间变换到三个正交基构成的空间下。</li>
<li>不能用plane是只能用quad是因为代码是建立在一个<strong>竖直摆放</strong>的多边形的基础上，多边形的顶点结构需要满足在模型空间下是竖直排列的。</li>
</ol>
</li>
<li>添加了c#脚本控制camera视角移动，查看固定法线为视角方向时的结果。</li>
</ol>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ol>
<li>取消批处理会增加Draw Call导致性能下降，所以应该尽量避免使用模型空间下的一些绝对位置和方向来进行计算。比如广告牌案例中，为了避免显式使用模型空间的中心来作为锚点，我们可以<strong>利用顶点颜色来存储每个顶点到锚点的距离值</strong>（应该也是先预计算存储相关数据）， 这种做法在商业游戏中很常见。</li>
<li>如果使用了顶点动画，并且需要对其添加<strong>阴影</strong>，那么不能调用Unity自带的Pass，而是要自己<strong>编写进行同样顶点变换过程的ShadowCaster Pass</strong>来生成正确的Shadow Map。</li>
</ol>
<h3 id="案例5-0：给顶点动画投射阴影"><a href="#案例5-0：给顶点动画投射阴影" class="headerlink" title="案例5.0：给顶点动画投射阴影"></a>案例5.0：给顶点动画投射阴影</h3><p>经过测试，直接修改Base Pass中的v.vertex，然后设置Fallback &#x3D; VertexLitb并不会修改生成阴影的顶点坐标，必须要通过自定义ShadowCaster Pass修改v.vertex从而给流动的河流生成相同顶点动画的阴影。</p>
<p>同时，需要注意宏定义TRANSFER_SHADOW_CASTER_NORMALOFFSET的使用，需要固定名称的变量v为输入结构体，v中需要包含顶点位置v.vertex 和顶点法线 v.normal 的信息，我们可以直接使用内置的 appdata_ base 结构体，它包含了这些必需的顶点变量。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line">    Tags &#123; &quot;LightMode&quot; = &quot;ShadowCaster&quot; &#125;</span><br><span class="line"></span><br><span class="line">    CGPROGRAM</span><br><span class="line"></span><br><span class="line">    <span class="meta">#pragma vertex vert</span></span><br><span class="line">    <span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#pragma multi_compile_shadowcaster</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> _Magnitude;</span><br><span class="line">    <span class="type">float</span> _Frequency;</span><br><span class="line">    <span class="type">float</span> _InvWaveLength;</span><br><span class="line">    <span class="type">float</span> _Speed;</span><br><span class="line"></span><br><span class="line">    struct v2f &#123; </span><br><span class="line">        V2F_SHADOW_CASTER;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">        v2f vert(appdata_base v) &#123;</span><br><span class="line">            v2f o;</span><br><span class="line"></span><br><span class="line">            float4 <span class="keyword">offset</span>;</span><br><span class="line">            <span class="keyword">offset</span>.yzw = float3(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">            <span class="keyword">offset</span>.x = <span class="built_in">sin</span>(_Frequency * _Time.y + v.vertex.x * _InvWaveLength + v.vertex.y * _InvWaveLength + v.vertex.z * _InvWaveLength) * _Magnitude;</span><br><span class="line">            v.vertex = v.vertex + <span class="keyword">offset</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 该处宏定义中使用了用名称v为输入结构体，v中需要包含顶点位置v.vertex 和顶点法线 v.normal 的信息，我们可以直接使用内置的 appdata_ base 结构体，它包含了这些必需的顶点变量。</span></span><br><span class="line">            TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">        SHADOW_CASTER_FRAGMENT(i)</span><br><span class="line">            &#125;</span><br><span class="line">    ENDCG</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h1 id="第十二章：屏幕后处理"><a href="#第十二章：屏幕后处理" class="headerlink" title="第十二章：屏幕后处理"></a>第十二章：屏幕后处理</h1><h2 id="建立一个基本的屏幕后处理脚本系统"><a href="#建立一个基本的屏幕后处理脚本系统" class="headerlink" title="建立一个基本的屏幕后处理脚本系统"></a>建立一个基本的屏幕后处理脚本系统</h2><p>前提：所有的后处理效果都需要绑定在某个<strong>相机</strong>上。</p>
<p>使用Unity内置的接口MonoBehavior.OnRenderImage得到渲染后的屏幕图像（抓取屏幕），然后对这个图像进行一系列操作，实现各种屏幕特效。</p>
<ol>
<li><p>需要实现的内置函数：OnRenderImage(RenderTexture src, RenderTexture dest);</p>
<blockquote>
<p>默认情况下<strong>该函数会在不透明、透明的Pass执行完毕后被调用</strong>，以便对场景中所有游戏对象都产生影响；</p>
<p>若希望在不透明的Pass (即渲染队列小于等于 2500 Pass, Background、Geometry、AlphaTest 渲染队列均在此范围内）执行完毕后调用 OnRenderlmage 函数，从而不对透明物体产生任何影响。此时，可以在 OnRenderlmage 函数前添 ImageEffectOpaque 属性来实现这样的目的。 （13.4有案例）</p>
</blockquote>
</li>
<li><p>该函数中，一般使用直接和shader以及渲染纹理打交道的内置函数：</p>
<ol>
<li>Graphics.Blit(RenderTexture src, RenderTexture dest);</li>
<li>Graphics.Blit(RenderTexture src, RenderTexture dest, Material mat, int pass &#x3D; -1);</li>
<li>Graphics.Blit(RenderTexture src, Material mat, int pass &#x3D; -1);</li>
</ol>
<blockquote>
<ol>
<li>第一个参数src传输给了mat.shader中的_MainTex纹理属性，因此必须在实现的shader中声明这个属性。</li>
<li>第二个参数dest即指定fs中的SV_Target。dest &#x3D;&#x3D; null的时候，就直接将shader渲染结果输出到屏幕。而不是存储到指定的dest渲染纹理中，再显示到屏幕上。</li>
<li>pass &#x3D;&#x3D; -1是指执行所有mat绑定的shader的pass，否则需要指定pass索引。</li>
</ol>
</blockquote>
</li>
</ol>
<h3 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h3><ol start="0">
<li>屏幕后处理之前需要检查当前屏幕是否支持渲染纹理、屏幕特效以及当前使用的Unity Shader。</li>
<li>在camera添加一个用于屏幕后处理的脚本，脚本中实现OnRenderImage函数来获取当前屏幕的渲染纹理；</li>
<li>调用Graphics.Blit函数使用特定的Unity Shader来对当前的图像进行处理，再把返回的渲染纹理显示到屏幕上；</li>
<li>复杂的屏幕特效可能需要多次调用Graphics.Blit来对上一步的输出进行下一步的处理。</li>
</ol>
<p>创建一个屏幕后处理<strong>基类</strong> -&gt; 实现各种不同特效时继承该基类，在<strong>派生类中进行不同的操作</strong>。</p>
<h2 id="案例1-0：调整屏幕的亮度、饱和度和对比度"><a href="#案例1-0：调整屏幕的亮度、饱和度和对比度" class="headerlink" title="案例1.0：调整屏幕的亮度、饱和度和对比度"></a>案例1.0：调整屏幕的亮度、饱和度和对比度</h2><p>图片的纹理类型已经被设置为了<strong>sprite</strong>，因此可以直接拖拽到场景中。</p>
<h3 id="c-："><a href="#c-：" class="headerlink" title="c#："></a>c#：</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在编辑器也能执行脚本查看效果</span></span><br><span class="line">[<span class="meta">ExecuteInEditMode</span>]</span><br><span class="line"><span class="comment">// 需要组件类型：Camera</span></span><br><span class="line">[<span class="meta">RequireComponent(typeof(Camera))</span>]</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Called when need to create the material used by this effect</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Material <span class="title">CheckShaderAndCreateMaterial</span>(<span class="params">Shader shader, Material material</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (shader == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shader.isSupported &amp;&amp; material &amp;&amp; material.shader == shader)</span><br><span class="line">        <span class="keyword">return</span> material;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!shader.isSupported)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        material = <span class="keyword">new</span> Material(shader);</span><br><span class="line">        material.hideFlags = HideFlags.DontSave;</span><br><span class="line">        <span class="keyword">if</span> (material)</span><br><span class="line">            <span class="keyword">return</span> material;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BrightnessSaturationAndContrast</span> : <span class="title">PostEffectsBase</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader briSatConShader;</span><br><span class="line">    <span class="keyword">private</span> Material briSatConMaterial;</span><br><span class="line">    <span class="keyword">public</span> Material material</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            briSatConMaterial = CheckShaderAndCreateMaterial(briSatConShader, briSatConMaterial);</span><br><span class="line">            <span class="keyword">return</span> briSatConMaterial;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> brightness = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> saturation = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> contrast = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// OnRenderImage: 需要自行实现的Unity内置接口。</span></span><br><span class="line">    <span class="comment">// Unity将当前渲染得到的图像储存在src渲染纹理，再把后处理的结果渲染纹理dest显示到屏幕上。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture src, RenderTexture dest</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 先检查材质是否可用</span></span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 绑定shader的参数</span></span><br><span class="line">            material.SetFloat(<span class="string">&quot;_Brightness&quot;</span>, brightness);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_Saturation&quot;</span>, saturation);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_Contrast&quot;</span>, contrast);</span><br><span class="line"></span><br><span class="line">            Graphics.Blit(src, dest, material);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>继承PostEffectsBase；</li>
<li>声明该后处理类需要使用的public shader，临时创建一个内置的material（CheckShaderAndCreateMaterial中生成的）；</li>
<li>声明该后处理类的内置属性亮度、饱和度以及对比度；</li>
<li>OnRenderImage中将属性值与material使用的shader中的属性进行绑定（类似OpenGL在c++绑定属性到shader）。</li>
<li>Graphics.Blit()<strong>将当前屏幕的渲染结果作为src，输入到material使用的shader中的_MainTex中</strong>。</li>
<li>将该脚本绑定至camera。</li>
</ol>
<h3 id="Shader："><a href="#Shader：" class="headerlink" title="Shader："></a>Shader：</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZTest Always Cull Off ZWrite Off <span class="comment">// 用于屏幕后处理的标配</span></span><br></pre></td></tr></table></figure>

<p>其实可以<strong>不用在properties声明</strong>属性亮度、饱和度以及对比度，因为不需要在临时生成的material面板进行调整，只需要在摄像机绑定的后处理类实例进行调整。</p>
<p>vs中使用Unity内置的结构体<strong>appdata_img</strong>，只需要position和uv即可（屏幕后处理实际上是在场景中绘制了一个与屏幕同宽同高的四边形面片，和OpenGL处理一致）：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">v2f vert(appdata_img v) &#123;</span><br><span class="line">    v2f o;</span><br><span class="line"></span><br><span class="line">    o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">    o.uv = v.texcoord;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在fs中分别调整亮度、饱和度以及对比度：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">    fixed4 renderTex = tex2D(_MainTex, i.uv);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Apply brightness</span></span><br><span class="line">    fixed3 finalColor = renderTex.rgb * _Brightness;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Apply saturation</span></span><br><span class="line">    fixed luminance = <span class="number">0.2125</span> * renderTex.r + <span class="number">0.7154</span> * renderTex.g + <span class="number">0.0721</span> * renderTex.b;</span><br><span class="line">    fixed3 luminanceColor = fixed3(luminance, luminance, luminance);</span><br><span class="line">    finalColor = lerp(luminanceColor, finalColor, _Saturation);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Apply contrast</span></span><br><span class="line">    fixed3 avgColor = fixed3(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">    finalColor = lerp(avgColor, finalColor, _Contrast);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fixed4(finalColor, renderTex.a);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>最后关闭Fallback：Fallback Off</p>
<h3 id="与之前的案例对比"><a href="#与之前的案例对比" class="headerlink" title="与之前的案例对比"></a>与之前的案例对比</h3><ol>
<li>之前的案例都是将shader绑定到一个手动创建的material上，material面板出现可以设置的<strong>shaderLab</strong>内置属性（properties），通过在面板上调整属性实现不同的渲染效果；</li>
<li>后处理是通过在c#脚本中<strong>生成</strong>（本案例）或者<strong>直接使用</strong>（比如<strong>程序纹理</strong>案例中的ProceduralTextureGeneration.cs）一个绑定了某个shader的material，然后通过调用<strong>material.SetFloat()<strong>等函数将</strong>c#中声明在面板</strong>上的可调节属性绑定到shader中，实现不同的渲染效果。</li>
</ol>
<h3 id="和OpenGL对比"><a href="#和OpenGL对比" class="headerlink" title="和OpenGL对比"></a>和OpenGL对比</h3><ol>
<li>OpenGL是分别编译两个shader。第一个shader正常渲染，但是需要将渲染的target设置为自定义的帧缓冲，附件类型为纹理；第二个shader使用上一步生成的texture进行后处理，然后渲染对处理后的纹理进行采样的2个三角形组成的正方形中（需要自定义position），顶点的position就是ndc空间下的坐标（所以shader中vs直接把pos输出到gl_Position中，不进行MVP变换），renderTarget就是自带的frameBuffer，所以直接将结果显示到屏幕。</li>
<li>Unity中，也是分成两个shader。第一个shader正常渲染，需要用一个相机绑定c#脚本，实现OnRenderImage完成屏幕捕捉，也就是生成一个纹理；第二个shader就是c#脚本中的material使用的shader（Graphics.Blit函数只能通过实例化一个绑定了该shader的material来调用shader），传入内置appdata_img结构体对象所带的四边形面片信息（shader中需要mvp变换），实现后处理，然后将结果显示到屏幕。</li>
</ol>
<h2 id="案例2-0：边缘检测"><a href="#案例2-0：边缘检测" class="headerlink" title="案例2.0：边缘检测"></a>案例2.0：边缘检测</h2><h3 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h3><ol>
<li>使用卷积核对一张图像中的每个像素进行卷积操作：将卷积核的<strong>中心</strong>放置于需要计算的像素上，计算每个元素和其覆盖的图像像素值的<strong>乘积再加和</strong>，得到的结果就是该像素的新像素值。</li>
<li>边缘检测的卷积核：主要在于提取相邻像素之间的差值（<strong>梯度</strong>：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/113397988">CV学习笔记（十三）：图像梯度 - 知乎 (zhihu.com)</a>）。以下三种卷积核都有水平和竖直两个方向上的卷积核。<ol>
<li>Roberts</li>
<li>Prewitt</li>
<li>Sobel（<a target="_blank" rel="noopener" href="https://blog.csdn.net/poem_qianmo/article/details/25560901">(77条消息) 【OpenCV入门教程之十二】OpenCV边缘检测：Canny算子,Sobel算子,Laplace算子,Scharr滤波器合辑_浅墨_毛星云的博客-CSDN博客_opencv 边缘平滑</a>）</li>
</ol>
</li>
<li>先得到一个像素对应的两个卷积结果，即两个方向上的梯度值，然后用平方根计算整体的梯度；出于性能的考虑，一般用绝对值代替开根计算。得到的整体梯度值越大，越有可能是边缘。</li>
</ol>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>本案例使用Sobel卷积核实现边缘检测。</p>
<h4 id="c-：-1"><a href="#c-：-1" class="headerlink" title="c#："></a>c#：</h4><p>和上一个例子基本一样。</p>
<h4 id="shader："><a href="#shader：" class="headerlink" title="shader："></a>shader：</h4><p>声明一个新变量_ MainTex_ TexelSize，该变量是Unity内置的可以访问xxx纹理的纹素大小（比如512*512大小的纹理，纹素大小是1&#x2F;512）。因为卷积需要对相邻区域内的纹理进行采样，因此需要使用该变量来<strong>计算各个相邻区域的纹理坐标</strong>。</p>
<p>先在<strong>vs</strong>中计算<strong>以当前uv坐标为中心的3*3的纹理坐标数组</strong>（先根据当前uv计算邻域uv，再插值邻域uv）；将从fs中的计算采样纹理坐标（先插值当前uv，再根据当前uv计算领域uv）转移到vs中，可以<strong>减少运算</strong>，<strong>提高性能</strong>；因为插值是<strong>线性</strong>的，因此在fs中插值并不会影响计算结果：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct v2f &#123;</span><br><span class="line">    float4 pos : SV_POSITION;</span><br><span class="line">    half2 uv[<span class="number">9</span>] : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">v2f vert(appdata_img v) &#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">    half2 uv = v.texcoord;</span><br><span class="line"></span><br><span class="line">    o.uv[<span class="number">0</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">    o.uv[<span class="number">1</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">    o.uv[<span class="number">2</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    o.uv[<span class="number">3</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    o.uv[<span class="number">4</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    o.uv[<span class="number">5</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    o.uv[<span class="number">6</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">    o.uv[<span class="number">7</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    o.uv[<span class="number">8</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fs中实现卷积，是重点：</p>
<p>当edgesOnly值为0时，边缘将会叠加在原渲染图像上；当edgesOnly值为1时，则会只显示边缘，不显示原渲染图像。</p>
<p>其中，背景颜色由backgroundColor指定，边缘颜色由edgeColor决定。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fixed4 fragSobel(v2f i) : SV_Target &#123;</span><br><span class="line">    half edge = Sobel(i);</span><br><span class="line"></span><br><span class="line">    fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[<span class="number">4</span>]), edge); <span class="comment">// 边缘叠加在原渲染图像上</span></span><br><span class="line">    fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge); <span class="comment">// 只显示边缘，不现实原渲染图像（叠加在指定颜色的背景上）</span></span><br><span class="line">    <span class="keyword">return</span> lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先使用sobel函数进行卷积计算当前像素的梯度edge：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">half Sobel(v2f i) &#123;</span><br><span class="line">    <span class="comment">// 定义水平方向和竖直方向的卷积核</span></span><br><span class="line">    <span class="keyword">const</span> half Gx[<span class="number">9</span>] = &#123;<span class="number">-1</span>,  <span class="number">0</span>,  <span class="number">1</span>,</span><br><span class="line">                        <span class="number">-2</span>,  <span class="number">0</span>,  <span class="number">2</span>,</span><br><span class="line">                        <span class="number">-1</span>,  <span class="number">0</span>,  <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> half Gy[<span class="number">9</span>] = &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-1</span>,</span><br><span class="line">                        <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,</span><br><span class="line">                        <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">1</span>&#125;;		</span><br><span class="line"></span><br><span class="line">    half texColor;</span><br><span class="line">    half edgeX = <span class="number">0</span>;</span><br><span class="line">    half edgeY = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> it = <span class="number">0</span>; it &lt; <span class="number">9</span>; it++) &#123;</span><br><span class="line">        <span class="comment">// 计算亮度值</span></span><br><span class="line">        texColor = luminance(tex2D(_MainTex, i.uv[it]));</span><br><span class="line">        <span class="comment">// 卷积</span></span><br><span class="line">        edgeX += texColor * Gx[it];</span><br><span class="line">        edgeY += texColor * Gy[it];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// edge 值越小，表明该位置越可能是一个边缘点</span></span><br><span class="line">    half edge = <span class="number">1</span> - <span class="built_in">abs</span>(edgeX) - <span class="built_in">abs</span>(edgeY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> edge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关闭该 Shader的Fallback。</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>需要注意的是，本节实现的边缘检测仅仅利用了屏幕颜色信息，而在实际应用中，物体的纹理、阴影等信息均会影响边缘检测 的结果，使得结果包含许多非预期的描边。为了得到更加准确的边缘信息，我们往往会在屏幕的深度纹理和法线纹理上进行边缘检测。我们将会在13.4节中实现这种方法。</p>
<h2 id="在一个摄像机上挂载多个后处理脚本"><a href="#在一个摄像机上挂载多个后处理脚本" class="headerlink" title="在一个摄像机上挂载多个后处理脚本"></a>在一个摄像机上挂载多个后处理脚本</h2><p>将1.0和2.0的脚本都挂载在同一个相机上，也可输出叠加的效果。</p>
<p>因为shader的执行有先后顺序，先执行了的后处理效果在后一个后处理脚本中会成为抓取屏幕的输入。</p>
<h2 id="案例3-0：高斯模糊"><a href="#案例3-0：高斯模糊" class="headerlink" title="案例3.0：高斯模糊"></a>案例3.0：高斯模糊</h2><p>卷积的另一个常见应用，类似的还有均值模糊等。</p>
<p>高斯核：一个方形大小的滤波核，每个元素的计算都是基于一个高斯方程（P253）。计算高斯核中各个位置对应的高斯值，从而构建高斯核，为了防止滤波后图像变暗，需要对高斯核中的权值进行归一化。</p>
<p>领域像素对当前处理像素的影响程度是：距离越近，影响越大；高斯核的维数越高，模糊程度越大。</p>
<h3 id="简化"><a href="#简化" class="headerlink" title="简化"></a>简化</h3><p>可以将一个2D高斯核拆分成2个1D高斯核先后对图像进行滤波，得到的结果和直接用2D高斯核（采样次数是N * N * W * H）是一样的，但采样次数为2 * N * W * H。</p>
<p>因此，需要两个Pass：</p>
<ol>
<li>第一个 Pass 将会使用竖直方向的一维高斯核对图像进行滤波，得到中间结果图像；</li>
<li>第二个 Pass 再使用水平方向的一维高斯核对中间结果图像进行滤波，得到最终的目标图像。</li>
</ol>
<p>同时，利用图像缩放来进一步提高性能，并通过调整高斯滤波的应用次数来控制模糊程度（次数越多，图像越模糊）。</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>属性：高斯模糊迭代次数、模糊范围、缩放系数。</p>
<p>blurSpread和downSample 都是出于性能的考虑。在高斯核维数不变的情况下 BlurSize越大，模糊程度越高，但采样数却不会受到影响。但过大的 BlurSize 值会造成虚影，这可能并不是我们希望的。而 downSample 越大，需要处理的像素数越少，同时也能进一步提高模糊程度，但过大的 downSample 可能会使图像像素化。</p>
<h4 id="c-：-2"><a href="#c-：-2" class="headerlink" title="c#："></a>c#：</h4><h5 id="第一个版本的实现："><a href="#第一个版本的实现：" class="headerlink" title="第一个版本的实现："></a>第一个版本的实现：</h5><p>OnRenderImage()的实现和前两个案例有所不同，需要利用 RenderTexture.GetTemporary()函数分配了一块与屏幕图像大小相同的缓冲区。这是因为 高斯模糊需要调用同一个shader的两个Pass, 我们需要使用一块<strong>中间缓存</strong>来存储第一个 Pass 执行完毕后得到的模糊结果，<strong>这块中间缓存也即改变了fs中的SV_Target</strong>。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> 1st edition: just apply blur</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="built_in">int</span> rtW = src.width;</span><br><span class="line">		<span class="built_in">int</span> rtH = src.height;</span><br><span class="line">		RenderTexture buffer = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Render the vertical pass（竖直方向高斯核）</span></span><br><span class="line">		Graphics.Blit(src, buffer, material, <span class="number">0</span>);</span><br><span class="line">		<span class="comment">// Render the horizontal pass（水平方向高斯核）</span></span><br><span class="line">		Graphics.Blit(buffer, dest, material, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要释放之前分配的缓存</span></span><br><span class="line">		RenderTexture.ReleaseTemporary(buffer);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		Graphics.Blit(src, dest);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h5 id="第二个版本的实现："><a href="#第二个版本的实现：" class="headerlink" title="第二个版本的实现："></a>第二个版本的实现：</h5><ol>
<li>利用<strong>缩放</strong>对图像进行<strong>降采样</strong>，从而减少需要处理的像素个数，提高性能；有时还可以得到更好的模糊效果；但<strong>downSample太大会导致图像像素化</strong>。</li>
<li>将临时渲染纹理的滤波模式设置为双线性Bilinear。</li>
</ol>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="built_in">int</span> rtW = src.width/downSample;</span><br><span class="line">		<span class="built_in">int</span> rtH = src.height/downSample;</span><br><span class="line">		RenderTexture buffer = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">		buffer.filterMode = FilterMode.Bilinear;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Render the vertical pass</span></span><br><span class="line">		Graphics.Blit(src, buffer, material, <span class="number">0</span>);</span><br><span class="line">		<span class="comment">// Render the horizontal pass</span></span><br><span class="line">		Graphics.Blit(buffer, dest, material, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		RenderTexture.ReleaseTemporary(buffer);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		Graphics.Blit(src, dest);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第三个版本的实现："><a href="#第三个版本的实现：" class="headerlink" title="第三个版本的实现："></a>第三个版本的实现：</h5><ol>
<li>考虑降采样 + Bilinear滤波。</li>
<li>考虑迭代次数：<ol>
<li>现将src存储到buffer0；</li>
<li>每次迭代都根据当前迭代次数i增加_BlurSize &#x3D; 1.0f + i * blurSpread（模糊范围的增量成倍增加）。</li>
<li>每一次迭代都新建一个buffer1，执行pass1，得到渲染结果；</li>
<li>将buffer0中内容释放，然后将buffer1中的渲染结果转存到buffer0；</li>
<li>重新分配buffer1，执行pass2，再将buffer0中内容释放，然后将buffer1中的渲染结果转存到buffer0；</li>
<li>最后将buffer0的结果输出到dest。</li>
</ol>
</li>
</ol>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture src, RenderTexture dest</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (material != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> rtW = src.width / downSample;</span><br><span class="line">        <span class="built_in">int</span> rtH = src.height / downSample;</span><br><span class="line"></span><br><span class="line">        RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">        buffer0.filterMode = FilterMode.Bilinear;</span><br><span class="line"></span><br><span class="line">        Graphics.Blit(src, buffer0);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; iterations; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_BlurSize&quot;</span>, <span class="number">1.0f</span> + i * blurSpread);</span><br><span class="line"></span><br><span class="line">            RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Render the vertical pass</span></span><br><span class="line">            Graphics.Blit(buffer0, buffer1, material, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">            buffer0 = buffer1;</span><br><span class="line">            buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Render the horizontal pass</span></span><br><span class="line">            Graphics.Blit(buffer0, buffer1, material, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">            buffer0 = buffer1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Graphics.Blit(buffer0, dest);</span><br><span class="line">        RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Graphics.Blit(src, dest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="shader：-1"><a href="#shader：-1" class="headerlink" title="shader："></a>shader：</h4><p>首次使用<strong>CGINCLUDE</strong>，和ENDCG语义一起，在SubShader块中用于定义一系列代码。</p>
<p>作用：类似于头文件，因为两个Pass中用的fs是完全一样的，所以使用CGINCLUDE可以避免编写完全一样的fs函数，只需要在Pass中直接指定需要使用的vs或fs即可。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;</span></span><br><span class="line"></span><br><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Gaussian Blur&quot; &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">		_BlurSize (&quot;Blur Size&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		CGINCLUDE</span><br><span class="line">		</span><br><span class="line">		<span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">sampler2D</span> _MainTex;  </span><br><span class="line">		half4 _MainTex_TexelSize;</span><br><span class="line">		<span class="type">float</span> _BlurSize;</span><br><span class="line">		  </span><br><span class="line">		struct v2f &#123;</span><br><span class="line">			float4 pos : SV_POSITION;</span><br><span class="line">			half2 uv[<span class="number">5</span>]: TEXCOORD0;</span><br><span class="line">		&#125;;</span><br><span class="line">		  </span><br><span class="line">		v2f vertBlurVertical(appdata_img v) &#123;</span><br><span class="line">			v2f o;</span><br><span class="line">			o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">			</span><br><span class="line">			half2 uv = v.texcoord;</span><br><span class="line">			</span><br><span class="line">			o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">			o.uv[<span class="number">1</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">1.0</span>) * _BlurSize;</span><br><span class="line">			o.uv[<span class="number">2</span>] = uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">1.0</span>) * _BlurSize;</span><br><span class="line">			o.uv[<span class="number">3</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">2.0</span>) * _BlurSize;</span><br><span class="line">			o.uv[<span class="number">4</span>] = uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">2.0</span>) * _BlurSize;</span><br><span class="line">					 </span><br><span class="line">			<span class="keyword">return</span> o;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		v2f vertBlurHorizontal(appdata_img v) &#123;</span><br><span class="line">			v2f o;</span><br><span class="line">			o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">			</span><br><span class="line">			half2 uv = v.texcoord;</span><br><span class="line">			</span><br><span class="line">			o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">			o.uv[<span class="number">1</span>] = uv + float2(_MainTex_TexelSize.x * <span class="number">1.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">			o.uv[<span class="number">2</span>] = uv - float2(_MainTex_TexelSize.x * <span class="number">1.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">			o.uv[<span class="number">3</span>] = uv + float2(_MainTex_TexelSize.x * <span class="number">2.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">			o.uv[<span class="number">4</span>] = uv - float2(_MainTex_TexelSize.x * <span class="number">2.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">					 </span><br><span class="line">			<span class="keyword">return</span> o;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		fixed4 fragBlur(v2f i) : SV_Target &#123;</span><br><span class="line">			<span class="type">float</span> weight[<span class="number">3</span>] = &#123;<span class="number">0.4026</span>, <span class="number">0.2442</span>, <span class="number">0.0545</span>&#125;;</span><br><span class="line">			</span><br><span class="line">			fixed3 sum = tex2D(_MainTex, i.uv[<span class="number">0</span>]).rgb * weight[<span class="number">0</span>];</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> it = <span class="number">1</span>; it &lt; <span class="number">3</span>; it++) &#123;</span><br><span class="line">				sum += tex2D(_MainTex, i.uv[it*<span class="number">2</span><span class="number">-1</span>]).rgb * weight[it];</span><br><span class="line">				sum += tex2D(_MainTex, i.uv[it*<span class="number">2</span>]).rgb * weight[it];</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> fixed4(sum, <span class="number">1.0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		    </span><br><span class="line">		ENDCG</span><br><span class="line">		</span><br><span class="line">		ZTest Always Cull Off ZWrite Off</span><br><span class="line">		</span><br><span class="line">		Pass &#123;</span><br><span class="line">			NAME &quot;GAUSSIAN_BLUR_VERTICAL&quot;</span><br><span class="line">			</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			  </span><br><span class="line">			<span class="meta">#pragma vertex vertBlurVertical  </span></span><br><span class="line">			<span class="meta">#pragma fragment fragBlur</span></span><br><span class="line">			  </span><br><span class="line">			ENDCG  </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Pass &#123;  </span><br><span class="line">			NAME &quot;GAUSSIAN_BLUR_HORIZONTAL&quot;</span><br><span class="line">			</span><br><span class="line">			CGPROGRAM  </span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma vertex vertBlurHorizontal  </span></span><br><span class="line">			<span class="meta">#pragma fragment fragBlur</span></span><br><span class="line">			</span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SubShader：</p>
<ol>
<li>分别在两个vs中定义vertical和horizontal两个方向上的uv坐标数组。</li>
<li>然后定义两个Pass共用的fs：<ol>
<li>5D的卷积核只需要3个值（P254：有对称性，0、4位置以及1、3位置的系数是一样的），注意uv纹理坐标值的数组中的位置和下标的关系（P257）；</li>
<li>_ BlurSize用于控制采样距离，维数不变，若_ BlurSize越大，那么模糊程度越高，但采样数不会受到影响。不过，_BlurSize过大，<strong>可能会造成虚影</strong>。</li>
</ol>
</li>
</ol>
<p>Pass：</p>
<p>用NAME语义定义了它们的<strong>名字</strong>，这是因为很多其他效果是基于高斯模糊的，比如Bloom，因此可以在<strong>其他Shader</strong>中<strong>直接通过它们的名字来使用（调用）该Pass</strong>。</p>
<h2 id="案例4-0：Bloom效果"><a href="#案例4-0：Bloom效果" class="headerlink" title="案例4.0：Bloom效果"></a>案例4.0：Bloom效果</h2><p>可以使画面中<strong>较亮的区域“扩散”到周围区域</strong>，营造朦胧的效果。</p>
<h3 id="原理（共4个Pass）"><a href="#原理（共4个Pass）" class="headerlink" title="原理（共4个Pass）"></a>原理（共4个Pass）</h3><ol>
<li>根据一个阈值提取出图像中较亮的区域，把它们存储在一张渲染纹理中；（1Pass）</li>
<li>再利用高斯模糊对这张渲染纹理进行模糊处理，模拟光线扩散的效果；（2Pass）</li>
<li>将这张图和原图像进行混合，得到最终的结果。（1Pass）</li>
</ol>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><h4 id="c-：-3"><a href="#c-：-3" class="headerlink" title="c#："></a>c#：</h4><p>在高斯模糊的代码基础上，加了一个luminanceThreshold属性用于控制提取较量区域时使用的阈值大小，并在OnRenderImage中将其传给Shader。</p>
<p>尽管在绝大多数情况下，图像的亮度值不会超过1 。但如果我们开启了 HDR, 硬件会允许我们把颜色值存储在一个更高精度范围的缓冲中，此时像素的亮度值可能会超过1。</p>
<ol>
<li>先使用第一个Pass来提取图像中较亮的区域存储在buffer0，而不是直接把src转存在buffer0；</li>
<li>再使用第二、第三个Pass进行迭代，和高斯模糊过程一样。</li>
<li>最后，将buffer0作为纹理传递给第四个Pass的_Bloom属性，将src与buffer0混合，最后输出给dest。</li>
</ol>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture src, RenderTexture dest</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (material != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        material.SetFloat(<span class="string">&quot;_LuminanceThreshold&quot;</span>, luminanceThreshold);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> rtW = src.width / downSample;</span><br><span class="line">        <span class="built_in">int</span> rtH = src.height / downSample;</span><br><span class="line"></span><br><span class="line">        RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">        buffer0.filterMode = FilterMode.Bilinear;</span><br><span class="line"></span><br><span class="line">        Graphics.Blit(src, buffer0, material, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; iterations; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_BlurSize&quot;</span>, <span class="number">1.0f</span> + i * blurSpread);</span><br><span class="line"></span><br><span class="line">            RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Render the vertical pass</span></span><br><span class="line">            Graphics.Blit(buffer0, buffer1, material, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">            buffer0 = buffer1;</span><br><span class="line">            buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Render the horizontal pass</span></span><br><span class="line">            Graphics.Blit(buffer0, buffer1, material, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">            buffer0 = buffer1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        material.SetTexture(<span class="string">&quot;_Bloom&quot;</span>, buffer0);</span><br><span class="line">        Graphics.Blit(src, dest, material, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Graphics.Blit(src, dest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="shader：-2"><a href="#shader：-2" class="headerlink" title="shader："></a>shader：</h4><ol>
<li>定义提取亮部区域的vs和fs：<ol>
<li>vs和之前的一样；</li>
<li>fs需要计算当前像素的亮度，减去阈值后截取到0-1区域之间，然后返回值为截取后的亮度*原像素值；</li>
</ol>
</li>
<li>定义混合亮部区域和原图像的vs和fs：<ol>
<li>vs中有两套uv坐标，一个是_ MainTex原图像的，另一个是_ Bloom，即模糊后的亮部区域图像的。</li>
<li>需要对_ Bloom的纹理坐标进行平台差异化处理。</li>
</ol>
</li>
<li>使用<strong>UsePass时需要用大写的名字</strong>，因为Unity内部会把Pass的Name转换为大写。</li>
</ol>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;</span></span><br><span class="line"></span><br><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Bloom&quot; &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">		_Bloom (&quot;Bloom (RGB)&quot;, <span class="number">2</span>D) = &quot;black&quot; &#123;&#125;</span><br><span class="line">		_LuminanceThreshold (&quot;Luminance Threshold&quot;, Float) = <span class="number">0.5</span></span><br><span class="line">		_BlurSize (&quot;Blur Size&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		CGINCLUDE</span><br><span class="line">		</span><br><span class="line">		<span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">sampler2D</span> _MainTex;</span><br><span class="line">		half4 _MainTex_TexelSize;</span><br><span class="line">		<span class="type">sampler2D</span> _Bloom;</span><br><span class="line">		<span class="type">float</span> _LuminanceThreshold;</span><br><span class="line">		<span class="type">float</span> _BlurSize;</span><br><span class="line">		</span><br><span class="line">		struct v2f &#123;</span><br><span class="line">			float4 pos : SV_POSITION; </span><br><span class="line">			half2 uv : TEXCOORD0;</span><br><span class="line">		&#125;;	</span><br><span class="line">		</span><br><span class="line">		v2f vertExtractBright(appdata_img v) &#123;</span><br><span class="line">			v2f o;</span><br><span class="line">			</span><br><span class="line">			o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">			</span><br><span class="line">			o.uv = v.texcoord;</span><br><span class="line">					 </span><br><span class="line">			<span class="keyword">return</span> o;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		fixed luminance(fixed4 color) &#123;</span><br><span class="line">			<span class="keyword">return</span>  <span class="number">0.2125</span> * color.r + <span class="number">0.7154</span> * color.g + <span class="number">0.0721</span> * color.b; </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">         <span class="comment">// 提取亮部区域：将采样得到的像素求到的亮度值减去阈值，然后将结果截取到0-1范围内，然后返回该值与原像素相乘的结果。</span></span><br><span class="line">		fixed4 fragExtractBright(v2f i) : SV_Target &#123;</span><br><span class="line">			fixed4 c = tex2D(_MainTex, i.uv);</span><br><span class="line">			fixed val = <span class="built_in">clamp</span>(luminance(c) - _LuminanceThreshold, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> c * val;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">         <span class="comment">// 定义混合亮部图像和原图时使用的vs和fs</span></span><br><span class="line">		struct v2fBloom &#123;</span><br><span class="line">			float4 pos : SV_POSITION; </span><br><span class="line">			half4 uv : TEXCOORD0;</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		v2fBloom vertBloom(appdata_img v) &#123;</span><br><span class="line">			v2fBloom o;</span><br><span class="line">			</span><br><span class="line">			o.pos = UnityObjectToClipPos (v.vertex);</span><br><span class="line">			o.uv.xy = v.texcoord;		</span><br><span class="line">			o.uv.zw = v.texcoord;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">#if UNITY_UV_STARTS_AT_TOP			</span></span><br><span class="line">			<span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0.0</span>)</span><br><span class="line">				o.uv.w = <span class="number">1.0</span> - o.uv.w;</span><br><span class="line">			<span class="meta">#endif</span></span><br><span class="line">				        	</span><br><span class="line">			<span class="keyword">return</span> o; </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		fixed4 fragBloom(v2fBloom i) : SV_Target &#123;</span><br><span class="line">			<span class="keyword">return</span> tex2D(_MainTex, i.uv.xy) + tex2D(_Bloom, i.uv.zw);</span><br><span class="line">		&#125; </span><br><span class="line">		</span><br><span class="line">		ENDCG</span><br><span class="line">		</span><br><span class="line">		ZTest Always Cull Off ZWrite Off</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 第1个Pass</span></span><br><span class="line">		Pass &#123;  </span><br><span class="line">			CGPROGRAM  </span><br><span class="line">			<span class="meta">#pragma vertex vertExtractBright  </span></span><br><span class="line">			<span class="meta">#pragma fragment fragExtractBright  </span></span><br><span class="line">			</span><br><span class="line">			ENDCG  </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 第2个Pass</span></span><br><span class="line">		UsePass &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Gaussian Blur/GAUSSIAN_BLUR_VERTICAL&quot;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 第3个Pass</span></span><br><span class="line">		UsePass &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Gaussian Blur/GAUSSIAN_BLUR_HORIZONTAL&quot;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 第4个Pass</span></span><br><span class="line">		Pass &#123;  </span><br><span class="line">			CGPROGRAM  </span><br><span class="line">			<span class="meta">#pragma vertex vertBloom  </span></span><br><span class="line">			<span class="meta">#pragma fragment fragBloom  </span></span><br><span class="line">			</span><br><span class="line">			ENDCG  </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>通过以上的案例可以总结出：</p>
<ol>
<li>后处理的c#脚本用于控制渲染的顺序、渲染纹理的来源src、输出target、使用的material和pass等，可以非常灵活的产生多种结果。</li>
<li>对应的shader基本都是使用Unity内部定义的结构体appdata_img（P108有定义，只有position以及uv信息；回顾一下，Shadow Caster里用的是appdata_base，多了一个normal信息）作为vs的输入，自定义v2f；</li>
<li>卷积运算中，设置当前像素邻域的uv坐标一般定义在vs；</li>
<li>重要的卷积、改变亮度、饱和度等其他效果的实现基本都是在fs中。</li>
</ol>
<h2 id="案例5-0：运动模糊"><a href="#案例5-0：运动模糊" class="headerlink" title="案例5.0：运动模糊"></a>案例5.0：运动模糊</h2><p>实现方法：</p>
<ol>
<li>累积缓存：在同一帧里渲染多次场景，然后取它们的平均值；暴力方法、对性能消耗大。</li>
<li>速度缓存：存储了各个像素当前的运动速度，然后利用该值来决定模糊的方向和大小。</li>
</ol>
<p>本例使用累积缓存的变种：不在一帧中渲染多次场景，而是保存之前的渲染结果，不断把当前的渲染图像（src）叠加（blend）到之前的渲染图像（自定义的渲染纹理）中。</p>
<h3 id="问题：为什么不能直接用dest作为renderTarget来参与blend呢？"><a href="#问题：为什么不能直接用dest作为renderTarget来参与blend呢？" class="headerlink" title="问题：为什么不能直接用dest作为renderTarget来参与blend呢？"></a>问题：为什么不能直接用dest作为renderTarget来参与blend呢？</h3><p>这是因为<strong>每一帧dest都需要首先完成初始化</strong>——初始化为默认的背景色（通常是黑色）：如果这样blend的结果就是每帧src和黑色进行blend，结果必然错误，<strong>因此无法保存之前帧生成的结果</strong>，因此必须要自己定义一个渲染纹理用来<strong>存储之前帧的blend结果</strong>。</p>
<h4 id="和OpenGL作对比"><a href="#和OpenGL作对比" class="headerlink" title="和OpenGL作对比"></a>和OpenGL作对比</h4><p>在OpenGL中，混合的案例中，是直接设置好blend的参数，然后按从远到近的顺序对物体进行绘制即可，这个过程中使用的是默认的frameBuffer，这是因为<strong>每一帧中进行了多次Draw</strong>（每次Draw都会和默认的frameBuffer，即dest进行混合），由于dest在多次Draw的过程中不会再次被初始化，因此可以保留多次blend的结果。</p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>因此，我们就可以发现，最大的不同在于，<strong>每次渲染的时机是在什么时候</strong>？</p>
<ol>
<li>如果是需要每帧渲染一次，因为dest每帧一定需要初始化，因此它不可以用来存储之前draw的数据，不可以作为blend的输入，故必须要一个中间存储；</li>
<li>如果是每一帧中渲染多次，那么dest就可以用来保存每一次draw的结果，也可以用于blend的输入，不需要额外的存储。</li>
</ol>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><h4 id="c-：-4"><a href="#c-：-4" class="headerlink" title="c#："></a>c#：</h4><p>需要自定义一个private RenderTexture的变量，保存之前叠加的结果。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RenderTexture accumulationTexture;</span><br></pre></td></tr></table></figure>

<p>在停止运行的时候销毁该变量，下一期play时重新应用运动模糊：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    DestroyImmediate(accumulationTexture);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现OnRenderImage：</p>
<ol>
<li>首先，创建material，并判断创建是否成功；</li>
<li>判断accumulationTexture是否和屏幕大小一致，若不一致，则销毁后重新分配内存区域，并将当前src的内容赋值给它；</li>
<li>因为本例是自行管理accumulationTexture内存的释放，因此需要将它的hideFlags设置为HideFlags.HideAndDontSave；</li>
<li>得到了有效的accumulationTexture变量后，需要调用accumulationTexture.MarkRestoreExpected();来进行一个渲染纹理的<strong>恢复操作</strong>，因为每次调用OnRenderImage时（应该是每一帧调用一次）accumulationTexture都不需要提前清空。</li>
<li>blurAmount在面板上数值越大时，直观意义是运动模糊效果越明显，但是在Shader中Blend时，作为a系数参与混合，需要a &#x3D; 1-blurAmount，因为a乘的是src的rgb。1-a即blurAmount乘的是accumulationTexture的rgb，想要效果越明显，那么accumulationTexture的浓度就要越高。</li>
<li>然后将src作为shader的_ MainTex，accumulationTexture作为SV_ Target，进行渲染。</li>
<li>将accumulationTexture的内容输出到dest屏幕。</li>
</ol>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture src, RenderTexture dest</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (material != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Create the accumulation texture</span></span><br><span class="line">        <span class="keyword">if</span> (accumulationTexture == <span class="literal">null</span> || accumulationTexture.width != src.width || accumulationTexture.height != src.height)</span><br><span class="line">        &#123;</span><br><span class="line">            DestroyImmediate(accumulationTexture);</span><br><span class="line">            accumulationTexture = <span class="keyword">new</span> RenderTexture(src.width, src.height, <span class="number">0</span>);</span><br><span class="line">            accumulationTexture.hideFlags = HideFlags.HideAndDontSave;</span><br><span class="line">            Graphics.Blit(src, accumulationTexture);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We are accumulating motion over frames without clear/discard</span></span><br><span class="line">        <span class="comment">// by design, so silence any performance warnings from Unity</span></span><br><span class="line">        accumulationTexture.MarkRestoreExpected();</span><br><span class="line"></span><br><span class="line">        material.SetFloat(<span class="string">&quot;_BlurAmount&quot;</span>, <span class="number">1.0f</span> - blurAmount);</span><br><span class="line"></span><br><span class="line">        Graphics.Blit(src, accumulationTexture, material);</span><br><span class="line">        Graphics.Blit(accumulationTexture, dest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Graphics.Blit(src, dest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="shader：-3"><a href="#shader：-3" class="headerlink" title="shader："></a>shader：</h4><p>本例也是在CGINCLUDE&#x2F; ENDCG内进行定义。</p>
<p>需要<strong>两个Pass</strong>，第一个混合rgb（<strong>新src在上，accumulationTexture在下</strong>），第二个将原始src的a通道写入SV_Target，<strong>保护a通道数据</strong>。</p>
<p>因为实际上两个Pass的通道互不影响，并且<strong>输入的是同一个src</strong>，所以顺序谁前谁后无所谓：</p>
<ol>
<li>第一个Pass将当前src与accumulationTexture根据_BlurAmount进行Blend混合，ColorMask RGB（只写RGB通道）。</li>
<li>第二个Pass将当前的src.a通道写入accumulationTexture，也是用的Blend（One Zero），且ColorMask A（只写a通道）。</li>
</ol>
<p>第一个Pass需要使用_ BlurAmount进行Blend混合，因此将_ BlurAmount放置到a通道；第二个需要使用src.a通道的数据，混合设置直接Blend One Zero即可：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fixed4 fragRGB (v2f i) : SV_Target &#123;</span><br><span class="line">	<span class="keyword">return</span> fixed4(tex2D(_MainTex, i.uv).rgb, _BlurAmount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">half4 fragA (v2f i) : SV_Target &#123;</span><br><span class="line">	<span class="keyword">return</span> tex2D(_MainTex, i.uv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个Pass的设置：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ZTest Always Cull Off ZWrite Off</span><br><span class="line"></span><br><span class="line">Pass &#123;</span><br><span class="line">    Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">    ColorMask RGB</span><br><span class="line">    </span><br><span class="line">    CGPROGRAM</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#pragma vertex vert  </span></span><br><span class="line">    <span class="meta">#pragma fragment fragRGB  </span></span><br><span class="line">    </span><br><span class="line">    ENDCG</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pass &#123;   </span><br><span class="line">    Blend One Zero</span><br><span class="line">    ColorMask A</span><br><span class="line">        </span><br><span class="line">    CGPROGRAM  </span><br><span class="line">    </span><br><span class="line">    <span class="meta">#pragma vertex vert  </span></span><br><span class="line">    <span class="meta">#pragma fragment fragA</span></span><br><span class="line">        </span><br><span class="line">    ENDCG</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试现象：运动越快运动模糊越明显，越慢越不明显"><a href="#测试现象：运动越快运动模糊越明显，越慢越不明显" class="headerlink" title="测试现象：运动越快运动模糊越明显，越慢越不明显"></a>测试现象：运动越快运动模糊越明显，越慢越不明显</h3><ol>
<li>经过测试，在较暗的情况下，如果blurAmount数值越大（0.9），那么会留下<strong>残影</strong>。</li>
<li>在摄像头进行转向时，会进行<strong>减速</strong>，也就是在同一个区域停留的时间会变长，那么在相同时间段内，在不同帧捕捉到的src<strong>差异不大</strong>，这样不断blend的结果看起来几乎是在同一个位置，因此视觉上<strong>运动越快运动模糊越明显，越慢越不明显</strong>。</li>
</ol>
<h3 id="“混合”：Blend和lerp-的异同"><a href="#“混合”：Blend和lerp-的异同" class="headerlink" title="“混合”：Blend和lerp()的异同"></a>“混合”：Blend和lerp()的异同</h3><p>结合之前的部分案例，可以发现有些混合是使用lerp()，有的是直接用Blend，二者的异同和使用环境总结如下：</p>
<h4 id="使用环境"><a href="#使用环境" class="headerlink" title="使用环境"></a>使用环境</h4><ol>
<li><p>Blend是shader自行进行的计算，流程比较<strong>固定</strong>，需要将<strong>fs的输出作为src</strong>（而不是直接覆盖SV_Target），<strong>当前的SV_Target</strong>作为target进行混合，并且<strong>混合结果会直接覆盖SV_Target</strong>，也即：<br>$$<br>n1 * src + n2 * SV_Target &#x3D;&gt; SV_Target<br>$$</p>
</li>
<li><p>而lerp则是将某2个自定义的值根据一个混合因子n进行混合，即：<br>$$<br>res &#x3D; lerp(val_1, val_2, n)<br>$$<br>因为val1、val2、res是自定义的，它们可以不同甚至可以相同，因此使用上更加灵活；但是如果想使用lerp()得到blend的效果，则需要自行对SV_Target进行采样，然后作为lerp的参数混合之后，再作为fs的返回值（即直接覆盖SV_Target），会比直接使用Blend多一步采样，更麻烦。</p>
</li>
</ol>
<p>因为本案例，需要将混合的结果直接显示到屏幕，并且<strong>其中一个混合的成分是上一次混合的结果</strong>，因此配合Graphics.Blit()将SV_Target改为累积混合结果，使用Blend明显更方便。</p>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><h3 id="c-与Shader结构"><a href="#c-与Shader结构" class="headerlink" title="c#与Shader结构"></a>c#与Shader结构</h3><ol>
<li>如果是类似边缘检测，只进行一次shader渲染就可以得到最终的结果，那么Graphics.Blit()的输入就是src，输出就是dest，不需要RenderTexture转存中间结果；</li>
<li>如果是类似高斯模糊，虽然<strong>每一帧的渲染结果都一样</strong>，但是需要先进行一次shader中某个Pass渲染，计算出<strong>中间结果</strong>（声明和定义都在OnRenderImage之中，是局部变量），然后再对<strong>中间结果</strong>进行之后的Pass渲染，也即<strong>两个Pass渲染的输入的_MainTex不是同一个，前一个的输出SV_Target是后一个的输入</strong>，那就<strong>必须要新建一个RenderTexture来存储中间的结果</strong>；</li>
<li>如果是类似运动模糊，如图所示：中间结果需要<strong>跨时间存储</strong>，那么就需要<strong>自己管理成员变量RenderTexture的销毁</strong>，并且又因为SV_Targrt既要作为shader的输入又要作为同一个shader的输出参与混合，因此直接使用Blend。</li>
<li>c#中，使用Shader进行渲染的最小单位是Pass，因此关键是指定输入Graphics.Blit()的_ MainTex以及SV_Target。如果一个Shader中的<strong>多个Pass都被同时使用</strong>（没有指定索引），那么每个Pass中的_ MainTex都是同一个src。</li>
</ol>
<h3 id="Shader的组织结构"><a href="#Shader的组织结构" class="headerlink" title="Shader的组织结构"></a>Shader的组织结构</h3><ol>
<li>如果一个Shader中多个Pass使用<strong>同样的vs或fs</strong>，那么就在SubShaser块中声明，当做头文件使用；</li>
<li>如果一个Shader想要<strong>使用别的Shader中定义的Pass</strong>，那么被使用的Pass需要声明Name语义，并且UsePass时需要大写。</li>
</ol>
<p><img src="/images/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/%E8%BF%90%E5%8A%A8%E6%A8%A1%E7%B3%8A.png" alt="运动模糊"></p>
<h1 id="第十三章-使用深度和法线纹理"><a href="#第十三章-使用深度和法线纹理" class="headerlink" title="第十三章 使用深度和法线纹理"></a>第十三章 使用深度和法线纹理</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">Moony</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2022/11/02/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/">http://example.com/2022/11/02/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Unity/">Unity</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/11/03/Unity/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Unity</div></div></a></div><div class="next-post pull-right"><a href="/2022/11/02/OpenGL/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">OpenGL</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/11/03/Unity/" title="Unity"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-03</div><div class="title">Unity</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Moony</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">1.</span> <span class="toc-text">第二章：渲染流水线</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">概念：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E9%98%B6%E6%AE%B5%EF%BC%9A"><span class="toc-number">1.1.1.</span> <span class="toc-text">应用阶段：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E4%BD%95%E9%98%B6%E6%AE%B5%EF%BC%9A"><span class="toc-number">1.1.2.</span> <span class="toc-text">几何阶段：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%89%E6%A0%85%E5%8C%96%E9%98%B6%E6%AE%B5%EF%BC%9A"><span class="toc-number">1.1.3.</span> <span class="toc-text">光栅化阶段：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU%E5%92%8CGPU%E7%9A%84%E9%80%9A%E4%BF%A1%EF%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">CPU和GPU的通信：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E9%98%B6%E6%AE%B5%EF%BC%9A-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">应用阶段：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GPU%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">1.3.</span> <span class="toc-text">GPU流水线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">顶点着色器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%81%E5%89%AA-Clipping"><span class="toc-number">1.3.2.</span> <span class="toc-text">裁剪(Clipping)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%8F%E5%B9%95%E6%98%A0%E5%B0%84"><span class="toc-number">1.3.3.</span> <span class="toc-text">屏幕映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E8%A7%92%E5%BD%A2%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.3.4.</span> <span class="toc-text">三角形设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E8%A7%92%E5%BD%A2%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.5.</span> <span class="toc-text">三角形遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%87%E5%85%83%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">1.3.6.</span> <span class="toc-text">片元着色器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%90%E7%89%87%E5%85%83%E6%93%8D%E4%BD%9C-x2F-%E8%BE%93%E5%87%BA%E5%90%88%E5%B9%B6"><span class="toc-number">1.3.7.</span> <span class="toc-text">逐片元操作&#x2F; 输出合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E5%89%8D%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95-Early-Z"><span class="toc-number">1.3.8.</span> <span class="toc-text">提前深度测试(Early-Z)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E9%87%8D%E7%BC%93%E5%86%B2"><span class="toc-number">1.3.9.</span> <span class="toc-text">双重缓冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Draw-Call"><span class="toc-number">1.3.10.</span> <span class="toc-text">Draw Call</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9AUnity-Shader%E4%B8%8EShaderLab"><span class="toc-number">2.</span> <span class="toc-text">第三章：Unity Shader与ShaderLab</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity-Shader"><span class="toc-number">2.1.</span> <span class="toc-text">Unity Shader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ShaderLab%EF%BC%9A-shader%E6%96%87%E4%BB%B6"><span class="toc-number">2.2.</span> <span class="toc-text">ShaderLab：.shader文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity-Shader%E5%92%8C%E7%9C%9F%E6%AD%A3%E7%9A%84Shader%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">Unity Shader和真正的Shader有什么不同？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E6%95%B0%E5%AD%A6"><span class="toc-number">3.</span> <span class="toc-text">第四章：数学</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9AUnity-Shader%E4%B8%8E%E5%86%85%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%8F%8A%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">第五章：Unity Shader与内置属性及函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">第六章：光照模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97diffuse%E5%88%86%E9%87%8F"><span class="toc-number">5.1.</span> <span class="toc-text">计算diffuse分量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97specular%E5%88%86%E9%87%8F"><span class="toc-number">5.2.</span> <span class="toc-text">计算specular分量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%89%E6%BA%90%E7%B1%BB%E5%9E%8B%EF%BC%889-2%EF%BC%9A%E5%88%A4%E6%96%AD%E5%85%89%E6%BA%90%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="toc-number">5.3.</span> <span class="toc-text">光源类型（9.2：判断光源类型）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E8%AE%A1%E7%AE%97"><span class="toc-number">5.4.</span> <span class="toc-text">使用内置函数进行计算</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E7%BA%B9%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">第七章：纹理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%BC%A0%E7%BA%B9%E7%90%86-gt-diffuse"><span class="toc-number">6.1.</span> <span class="toc-text">单张纹理-&gt;diffuse</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E6%9D%BF%E5%B1%9E%E6%80%A7"><span class="toc-number">6.1.1.</span> <span class="toc-text">面板属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%B0%BA%E5%AF%B8%E5%92%8C%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F"><span class="toc-number">6.1.2.</span> <span class="toc-text">最大尺寸和存储格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%B9%E5%87%B8%E8%B4%B4%E5%9B%BE"><span class="toc-number">6.2.</span> <span class="toc-text">凹凸贴图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%BA%BF%E7%A9%BA%E9%97%B4%E4%B8%8B%E7%9A%84%E5%85%89%E7%85%A7%E8%AE%A1%E7%AE%97"><span class="toc-number">6.2.1.</span> <span class="toc-text">切线空间下的光照计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%96%E7%95%8C%E7%A9%BA%E9%97%B4%E4%B8%8B%E7%9A%84%E5%85%89%E7%85%A7%E8%AE%A1%E7%AE%97"><span class="toc-number">6.2.2.</span> <span class="toc-text">世界空间下的光照计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UnpackNormal"><span class="toc-number">6.2.3.</span> <span class="toc-text">UnpackNormal</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%90%E5%8F%98%E7%BA%B9%E7%90%86%EF%BC%9A%E4%BD%BF%E7%94%A8halfLambert%E4%BD%9C%E4%B8%BA%E7%BA%B9%E7%90%86%E5%9D%90%E6%A0%87"><span class="toc-number">6.3.</span> <span class="toc-text">渐变纹理：使用halfLambert作为纹理坐标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%AE%E7%BD%A9%E7%BA%B9%E7%90%86"><span class="toc-number">6.4.</span> <span class="toc-text">遮罩纹理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E9%80%8F%E6%98%8E%E7%89%A9%E4%BD%93"><span class="toc-number">7.</span> <span class="toc-text">第八章：透明物体</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F%E5%BE%88%E9%87%8D%E8%A6%81%EF%BC%81"><span class="toc-number">7.1.</span> <span class="toc-text">渲染顺序很重要！</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#warning%EF%BC%9A"><span class="toc-number">7.1.1.</span> <span class="toc-text">warning：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8E%92%E5%BA%8F"><span class="toc-number">7.2.</span> <span class="toc-text">Unity中的渲染排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E9%98%9F%E5%88%97"><span class="toc-number">7.2.1.</span> <span class="toc-text">渲染队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Alpha-Test"><span class="toc-number">7.3.</span> <span class="toc-text">Alpha Test</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Alpha-Blend"><span class="toc-number">7.4.</span> <span class="toc-text">Alpha Blend</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E8%BA%AB%E5%A4%8D%E6%9D%82%E7%9A%84%E6%A8%A1%E5%9E%8B%EF%BC%9A%E5%BC%80%E5%90%AF%E6%B7%B1%E5%BA%A6%E5%86%99%E5%85%A5%E7%9A%84%E5%8D%8A%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C"><span class="toc-number">7.5.</span> <span class="toc-text">自身复杂的模型：开启深度写入的半透明效果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ShaderLab%E7%9A%84%E6%B7%B7%E5%90%88%E5%91%BD%E4%BB%A4"><span class="toc-number">7.6.</span> <span class="toc-text">ShaderLab的混合命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E9%9D%A2%E6%B8%B2%E6%9F%93%E7%9A%84%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C"><span class="toc-number">7.7.</span> <span class="toc-text">双面渲染的透明效果</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Alpha-Test%E7%9A%84%E5%8F%8C%E9%9D%A2%E6%B8%B2%E6%9F%93"><span class="toc-number">7.7.1.</span> <span class="toc-text">Alpha Test的双面渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Alpha-Blend%E7%9A%84%E5%8F%8C%E9%9D%A2%E6%B8%B2%E6%9F%93"><span class="toc-number">7.7.2.</span> <span class="toc-text">Alpha Blend的双面渲染</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%9A%E5%A4%9A%E5%85%89%E6%BA%90%EF%BC%8C%E9%98%B4%E5%BD%B1%EF%BC%8C%E5%85%89%E7%BA%BF%E8%A1%B0%E5%87%8F"><span class="toc-number">8.</span> <span class="toc-text">第九章：多光源，阴影，光线衰减</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84"><span class="toc-number">8.1.</span> <span class="toc-text">渲染路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AEPass%E4%B8%AD%E7%9A%84LightMode%EF%BC%88P181%EF%BC%89"><span class="toc-number">8.1.1.</span> <span class="toc-text">设置Pass中的LightMode（P181）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%90%91%E6%B8%B2%E6%9F%93"><span class="toc-number">8.1.2.</span> <span class="toc-text">前向渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B6%E7%82%B9%E7%85%A7%E6%98%8E%E6%B8%B2%E6%9F%93%EF%BC%88%E7%95%A5%EF%BC%89"><span class="toc-number">8.1.3.</span> <span class="toc-text">顶点照明渲染（略）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93"><span class="toc-number">8.1.4.</span> <span class="toc-text">延迟渲染</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity%E7%9A%84%E5%85%89%E6%BA%90%E7%B1%BB%E5%9E%8B%EF%BC%88P189%EF%BC%89"><span class="toc-number">8.2.</span> <span class="toc-text">Unity的光源类型（P189）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B1-0%EF%BC%9A%E5%89%8D%E5%90%91%E6%B8%B2%E6%9F%93"><span class="toc-number">8.3.</span> <span class="toc-text">案例1.0：前向渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Base-Pass"><span class="toc-number">8.3.1.</span> <span class="toc-text">Base Pass</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Additional-Pass"><span class="toc-number">8.3.2.</span> <span class="toc-text">Additional Pass</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8frame-debugger%E6%9D%A5%E6%9F%A5%E7%9C%8B%E6%B8%B2%E6%9F%93%E4%BA%8B%E4%BB%B6"><span class="toc-number">8.3.3.</span> <span class="toc-text">利用frame debugger来查看渲染事件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity%E7%9A%84%E5%85%89%E7%85%A7%E8%A1%B0%E5%87%8F"><span class="toc-number">8.4.</span> <span class="toc-text">Unity的光照衰减</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity%E7%9A%84%E9%98%B4%E5%BD%B1"><span class="toc-number">8.5.</span> <span class="toc-text">Unity的阴影</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Shadow-Map"><span class="toc-number">8.5.1.</span> <span class="toc-text">Shadow Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Screenspace-Shadow-Map%EF%BC%88%E9%9C%80%E8%A6%81%E6%98%BE%E5%8D%A1%E6%94%AF%E6%8C%81MRT%EF%BC%89"><span class="toc-number">8.5.2.</span> <span class="toc-text">Screenspace Shadow Map（需要显卡支持MRT）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">8.5.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B2-0%EF%BC%9A%E4%B8%8D%E9%80%8F%E6%98%8E%E7%89%A9%E4%BD%93%E7%9A%84%E9%98%B4%E5%BD%B1"><span class="toc-number">8.6.</span> <span class="toc-text">案例2.0：不透明物体的阴影</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ShadowCaster%EF%BC%88%E7%94%9F%E6%88%90shadow-map%EF%BC%89"><span class="toc-number">8.6.1.</span> <span class="toc-text">ShadowCaster（生成shadow map）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%B0%E8%B1%A1%EF%BC%9A"><span class="toc-number">8.6.1.1.</span> <span class="toc-text">现象：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">8.6.1.2.</span> <span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E9%98%B4%E5%BD%B1%EF%BC%88%E4%BD%BF%E7%94%A8%E5%86%85%E7%BD%AE%E5%AE%8F%EF%BC%8C%E5%9C%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84shader%E4%B8%AD%E7%9A%84pass%E5%A4%84%E7%90%86%EF%BC%89"><span class="toc-number">8.6.2.</span> <span class="toc-text">接收阴影（使用内置宏，在自定义的shader中的pass处理）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%81%E5%AE%8F%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E5%90%8D%E5%8C%B9%E9%85%8D"><span class="toc-number">8.6.3.</span> <span class="toc-text">！宏定义中的变量名匹配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86%E5%85%89%E7%85%A7%E8%A1%B0%E5%87%8F%E5%92%8C%E9%98%B4%E5%BD%B1"><span class="toc-number">8.7.</span> <span class="toc-text">统一管理光照衰减和阴影</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B3-0"><span class="toc-number">8.7.1.</span> <span class="toc-text">案例3.0</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%8F%E6%98%8E%E7%89%A9%E4%BD%93%E7%9A%84%E9%98%B4%E5%BD%B1"><span class="toc-number">8.8.</span> <span class="toc-text">透明物体的阴影</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B4-0%EF%BC%9AAlphaTest"><span class="toc-number">8.8.1.</span> <span class="toc-text">案例4.0：AlphaTest</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B5-0%EF%BC%9AAlphaBlend"><span class="toc-number">8.8.2.</span> <span class="toc-text">案例5.0：AlphaBlend</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%9A%E9%AB%98%E7%BA%A7%E8%B4%B4%E5%9B%BE"><span class="toc-number">9.</span> <span class="toc-text">第十章：高级贴图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%8B%E6%96%B9%E4%BD%93%E7%BA%B9%E7%90%86"><span class="toc-number">9.1.</span> <span class="toc-text">立方体纹理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A9%E7%A9%BA%E7%9B%92"><span class="toc-number">9.1.1.</span> <span class="toc-text">天空盒</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84"><span class="toc-number">9.1.2.</span> <span class="toc-text">环境映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">9.1.3.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%8F%8D%E5%B0%84%E6%96%B9%E5%90%91%EF%BC%9A"><span class="toc-number">9.1.3.1.</span> <span class="toc-text">计算反射方向：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%87%E6%A0%B7%EF%BC%9A"><span class="toc-number">9.1.3.2.</span> <span class="toc-text">采样：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-1"><span class="toc-number">9.1.3.3.</span> <span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%98%E5%B0%84"><span class="toc-number">9.1.4.</span> <span class="toc-text">折射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8F%B2%E6%B6%85%E5%B0%94%E5%8F%8D%E5%B0%84"><span class="toc-number">9.1.5.</span> <span class="toc-text">菲涅尔反射</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E7%BA%B9%E7%90%86"><span class="toc-number">9.2.</span> <span class="toc-text">渲染纹理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%AD%90%E6%95%88%E6%9E%9C"><span class="toc-number">9.2.1.</span> <span class="toc-text">镜子效果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%BB%E7%92%83%E6%95%88%E6%9E%9C"><span class="toc-number">9.2.2.</span> <span class="toc-text">玻璃效果</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GrabPass%E7%9A%84%E5%90%8D%E5%AD%97%EF%BC%8C%E6%98%AF%E7%A9%BA%E8%BF%98%E6%98%AF%E8%87%AA%E5%AE%9A%E4%B9%89%EF%BC%9F"><span class="toc-number">9.2.2.1.</span> <span class="toc-text">GrabPass的名字，是空还是自定义？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E7%BA%B9%E7%90%86vs-GrabPass"><span class="toc-number">9.2.3.</span> <span class="toc-text">渲染纹理vs. GrabPass</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%BA%B9%E7%90%86"><span class="toc-number">9.3.</span> <span class="toc-text">程序纹理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE%EF%BC%9A"><span class="toc-number">9.4.</span> <span class="toc-text">回顾：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%EF%BC%9A%E7%BA%B9%E7%90%86%E5%8A%A8%E7%94%BB"><span class="toc-number">10.</span> <span class="toc-text">第十一章：纹理动画</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#shader%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E6%97%B6%E9%97%B4%E5%8F%98%E9%87%8F"><span class="toc-number">10.1.</span> <span class="toc-text">shader中的内置时间变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%B9%E7%90%86%E5%8A%A8%E7%94%BB"><span class="toc-number">10.2.</span> <span class="toc-text">纹理动画</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%B8%A7%E5%8A%A8%E7%94%BB"><span class="toc-number">10.2.1.</span> <span class="toc-text">序列帧动画</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B1-0"><span class="toc-number">10.2.1.1.</span> <span class="toc-text">案例1.0</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%9A%E5%8A%A8%E7%9A%84%E8%83%8C%E6%99%AF"><span class="toc-number">10.2.2.</span> <span class="toc-text">滚动的背景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B2-0"><span class="toc-number">10.2.2.1.</span> <span class="toc-text">案例2.0</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B6%E7%82%B9%E5%8A%A8%E7%94%BB"><span class="toc-number">10.2.3.</span> <span class="toc-text">顶点动画</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B3-0%EF%BC%9A%E6%B5%81%E5%8A%A8%E7%9A%84%E6%B2%B3%E6%B5%81"><span class="toc-number">10.2.3.1.</span> <span class="toc-text">案例3.0：流动的河流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E5%91%8A%E7%89%8C"><span class="toc-number">10.2.4.</span> <span class="toc-text">广告牌</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B4-0"><span class="toc-number">10.2.4.1.</span> <span class="toc-text">案例4.0</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-number">10.3.</span> <span class="toc-text">补充</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B5-0%EF%BC%9A%E7%BB%99%E9%A1%B6%E7%82%B9%E5%8A%A8%E7%94%BB%E6%8A%95%E5%B0%84%E9%98%B4%E5%BD%B1"><span class="toc-number">10.3.1.</span> <span class="toc-text">案例5.0：给顶点动画投射阴影</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%EF%BC%9A%E5%B1%8F%E5%B9%95%E5%90%8E%E5%A4%84%E7%90%86"><span class="toc-number">11.</span> <span class="toc-text">第十二章：屏幕后处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%B1%8F%E5%B9%95%E5%90%8E%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%E7%B3%BB%E7%BB%9F"><span class="toc-number">11.1.</span> <span class="toc-text">建立一个基本的屏幕后处理脚本系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-number">11.1.1.</span> <span class="toc-text">流程：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B1-0%EF%BC%9A%E8%B0%83%E6%95%B4%E5%B1%8F%E5%B9%95%E7%9A%84%E4%BA%AE%E5%BA%A6%E3%80%81%E9%A5%B1%E5%92%8C%E5%BA%A6%E5%92%8C%E5%AF%B9%E6%AF%94%E5%BA%A6"><span class="toc-number">11.2.</span> <span class="toc-text">案例1.0：调整屏幕的亮度、饱和度和对比度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%EF%BC%9A"><span class="toc-number">11.2.1.</span> <span class="toc-text">c#：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shader%EF%BC%9A"><span class="toc-number">11.2.2.</span> <span class="toc-text">Shader：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E4%B9%8B%E5%89%8D%E7%9A%84%E6%A1%88%E4%BE%8B%E5%AF%B9%E6%AF%94"><span class="toc-number">11.2.3.</span> <span class="toc-text">与之前的案例对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8COpenGL%E5%AF%B9%E6%AF%94"><span class="toc-number">11.2.4.</span> <span class="toc-text">和OpenGL对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B2-0%EF%BC%9A%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B"><span class="toc-number">11.3.</span> <span class="toc-text">案例2.0：边缘检测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%B7%E7%A7%AF"><span class="toc-number">11.3.1.</span> <span class="toc-text">卷积</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">11.3.2.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%EF%BC%9A-1"><span class="toc-number">11.3.2.1.</span> <span class="toc-text">c#：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shader%EF%BC%9A"><span class="toc-number">11.3.2.2.</span> <span class="toc-text">shader：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">11.3.2.3.</span> <span class="toc-text">注意</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%91%84%E5%83%8F%E6%9C%BA%E4%B8%8A%E6%8C%82%E8%BD%BD%E5%A4%9A%E4%B8%AA%E5%90%8E%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC"><span class="toc-number">11.4.</span> <span class="toc-text">在一个摄像机上挂载多个后处理脚本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B3-0%EF%BC%9A%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A"><span class="toc-number">11.5.</span> <span class="toc-text">案例3.0：高斯模糊</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8C%96"><span class="toc-number">11.5.1.</span> <span class="toc-text">简化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">11.5.2.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%EF%BC%9A-2"><span class="toc-number">11.5.2.1.</span> <span class="toc-text">c#：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-number">11.5.2.1.1.</span> <span class="toc-text">第一个版本的实现：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-number">11.5.2.1.2.</span> <span class="toc-text">第二个版本的实现：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-number">11.5.2.1.3.</span> <span class="toc-text">第三个版本的实现：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shader%EF%BC%9A-1"><span class="toc-number">11.5.2.2.</span> <span class="toc-text">shader：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B4-0%EF%BC%9ABloom%E6%95%88%E6%9E%9C"><span class="toc-number">11.6.</span> <span class="toc-text">案例4.0：Bloom效果</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%EF%BC%88%E5%85%B14%E4%B8%AAPass%EF%BC%89"><span class="toc-number">11.6.1.</span> <span class="toc-text">原理（共4个Pass）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">11.6.2.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%EF%BC%9A-3"><span class="toc-number">11.6.2.1.</span> <span class="toc-text">c#：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shader%EF%BC%9A-2"><span class="toc-number">11.6.2.2.</span> <span class="toc-text">shader：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">11.6.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B5-0%EF%BC%9A%E8%BF%90%E5%8A%A8%E6%A8%A1%E7%B3%8A"><span class="toc-number">11.7.</span> <span class="toc-text">案例5.0：运动模糊</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E7%94%A8dest%E4%BD%9C%E4%B8%BArenderTarget%E6%9D%A5%E5%8F%82%E4%B8%8Eblend%E5%91%A2%EF%BC%9F"><span class="toc-number">11.7.1.</span> <span class="toc-text">问题：为什么不能直接用dest作为renderTarget来参与blend呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%92%8COpenGL%E4%BD%9C%E5%AF%B9%E6%AF%94"><span class="toc-number">11.7.1.1.</span> <span class="toc-text">和OpenGL作对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">11.7.1.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">11.7.2.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%EF%BC%9A-4"><span class="toc-number">11.7.2.1.</span> <span class="toc-text">c#：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shader%EF%BC%9A-3"><span class="toc-number">11.7.2.2.</span> <span class="toc-text">shader：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%8E%B0%E8%B1%A1%EF%BC%9A%E8%BF%90%E5%8A%A8%E8%B6%8A%E5%BF%AB%E8%BF%90%E5%8A%A8%E6%A8%A1%E7%B3%8A%E8%B6%8A%E6%98%8E%E6%98%BE%EF%BC%8C%E8%B6%8A%E6%85%A2%E8%B6%8A%E4%B8%8D%E6%98%8E%E6%98%BE"><span class="toc-number">11.7.3.</span> <span class="toc-text">测试现象：运动越快运动模糊越明显，越慢越不明显</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%9C%E6%B7%B7%E5%90%88%E2%80%9D%EF%BC%9ABlend%E5%92%8Clerp-%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">11.7.4.</span> <span class="toc-text">“混合”：Blend和lerp()的异同</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83"><span class="toc-number">11.7.4.1.</span> <span class="toc-text">使用环境</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">11.8.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%E4%B8%8EShader%E7%BB%93%E6%9E%84"><span class="toc-number">11.8.1.</span> <span class="toc-text">c#与Shader结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shader%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84"><span class="toc-number">11.8.2.</span> <span class="toc-text">Shader的组织结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E4%BD%BF%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%92%8C%E6%B3%95%E7%BA%BF%E7%BA%B9%E7%90%86"><span class="toc-number">12.</span> <span class="toc-text">第十三章 使用深度和法线纹理</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/11/03/Unity/" title="Unity"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity"/></a><div class="content"><a class="title" href="/2022/11/03/Unity/" title="Unity">Unity</a><time datetime="2022-11-03T12:44:35.000Z" title="Created 2022-11-03 20:44:35">2022-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/02/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/" title="Shader入门精要"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Shader入门精要"/></a><div class="content"><a class="title" href="/2022/11/02/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/" title="Shader入门精要">Shader入门精要</a><time datetime="2022-11-02T11:22:23.000Z" title="Created 2022-11-02 19:22:23">2022-11-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/02/OpenGL/" title="OpenGL"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OpenGL"/></a><div class="content"><a class="title" href="/2022/11/02/OpenGL/" title="OpenGL">OpenGL</a><time datetime="2022-11-02T08:35:45.000Z" title="Created 2022-11-02 16:35:45">2022-11-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/02/c-%E6%80%BB%E7%BB%93/" title="c++总结"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="c++总结"/></a><div class="content"><a class="title" href="/2022/11/02/c-%E6%80%BB%E7%BB%93/" title="c++总结">c++总结</a><time datetime="2022-11-02T05:49:40.000Z" title="Created 2022-11-02 13:49:40">2022-11-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/02/Dx11/" title="Dx11"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Dx11"/></a><div class="content"><a class="title" href="/2022/11/02/Dx11/" title="Dx11">Dx11</a><time datetime="2022-11-02T05:02:20.000Z" title="Created 2022-11-02 13:02:20">2022-11-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Moony</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>