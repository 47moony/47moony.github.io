<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>OpenGL | Moony's World</title><meta name="author" content="Moony"><meta name="copyright" content="Moony"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="环境配置使用Cmake + Clion构建项目  下载安装Cmake和MinGW； 下载GLFW（根据clion编译器版本选择；解压后需要include文件夹和lib-mingw下的glfw3.dll），glad（解压后需要include和src文件）； 新建一个项目，在工程根目录下新建3个文件夹，include,lib,src。把glad和glfw的include文件夹下所有文件夹都复制到刚建的">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenGL">
<meta property="og:url" content="http://example.com/2022/11/02/OpenGL/index.html">
<meta property="og:site_name" content="Moony&#39;s World">
<meta property="og:description" content="环境配置使用Cmake + Clion构建项目  下载安装Cmake和MinGW； 下载GLFW（根据clion编译器版本选择；解压后需要include文件夹和lib-mingw下的glfw3.dll），glad（解压后需要include和src文件）； 新建一个项目，在工程根目录下新建3个文件夹，include,lib,src。把glad和glfw的include文件夹下所有文件夹都复制到刚建的">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-11-02T08:35:45.000Z">
<meta property="article:modified_time" content="2023-03-12T16:28:30.058Z">
<meta property="article:author" content="Moony">
<meta property="article:tag" content="OpenGL">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/11/02/OpenGL/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'OpenGL',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-13 00:28:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Moony's World</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">OpenGL</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-11-02T08:35:45.000Z" title="Created 2022-11-02 16:35:45">2022-11-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-03-12T16:28:30.058Z" title="Updated 2023-03-13 00:28:30">2023-03-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="OpenGL"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>使用Cmake + Clion构建项目</p>
<ol>
<li>下载安装Cmake和MinGW；</li>
<li>下载GLFW（根据clion编译器版本选择；解压后需要include文件夹和lib-mingw下的glfw3.dll），glad（解压后需要include和src文件）；</li>
<li>新建一个项目，在工程根目录下新建3个文件夹，include,lib,src。把glad和glfw的include文件夹下所有文件夹都复制到刚建的include文件夹下(glad的include下的glad和KHR文件夹，glfw的include下的GLFW文件夹),把glad下的src下的glad.c复制到刚建的src文件夹下，把glfw的glfw3.dll文件复制到刚建的lib文件夹下。最后一步，别忘了把glfw3.dll复制到程序运行目录，clion编译好的文件默认会放到项目根目录下的cmake-build-debug下，所以要把glfw3.dll也复制到这个文件夹下，不然运行不了；</li>
<li>Clion的编译器和make程序需要在toolchain中进行设置（都用MinGW的）；</li>
<li>修改CmakeList.txt，指定头文件所在的路径，并且将dll文件链接上；</li>
</ol>
<p>​	根目录下的：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.22</span>)</span><br><span class="line"><span class="keyword">SET</span> (CMAKE_C_COMPILER_WORKS <span class="number">1</span>)</span><br><span class="line"><span class="keyword">SET</span> (CMAKE_CXX_COMPILER_WORKS <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 测试在根目录下生成的可执行文件位于 cmake-build-debug根目录下</span></span><br><span class="line"><span class="keyword">set</span>(projectName <span class="string">&quot;LearnOpenGL&quot;</span>)</span><br><span class="line"><span class="comment"># $&#123;PROJECT_NAME&#125; = $&#123;projectName&#125;, 存在这样的赋值关系</span></span><br><span class="line"><span class="keyword">project</span>(<span class="variable">$&#123;projectName&#125;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"><span class="comment"># 引入头文件 子项目的CmakeList.txt不用做修改</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/includes)</span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试在根目录下生成的可执行文件位于 cmake-build-debug根目录下 对应的生成和链接代码</span></span><br><span class="line"><span class="comment"># 生成的文件名可以用$&#123;PROJECT_NAME&#125; 也可以用$&#123;projectName&#125; 因为此时这两个值是相等的</span></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> main.cpp <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/glad.c chapter02/demo8_color.cpp includes/learnopengl/mesh.h includes/learnopengl/model.h)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;projectName&#125;</span> <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib/glfw3.dll)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子项目生成的可执行文件位于 cmake-build-debug/子项目文件名 的根目录目录下</span></span><br><span class="line"><span class="keyword">ADD_SUBDIRECTORY</span>(chapter01)</span><br><span class="line"><span class="keyword">ADD_SUBDIRECTORY</span>(chapter02)</span><br></pre></td></tr></table></figure>

<p>​	子目录chapter01下的：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将该子项目下包含的内容反馈回主项目中</span></span><br><span class="line"><span class="keyword">include_directories</span>(.)</span><br><span class="line"></span><br><span class="line"><span class="comment"># chapter01</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="keyword">set</span>(subProjectName1 <span class="string">&quot;demo1_hello_window_clear&quot;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;subProjectName1&#125;</span> demo1_hello_window_clear.cpp <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/glad.c)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;subProjectName1&#125;</span> <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib/glfw3.dll)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="keyword">set</span>(subProjectName2 <span class="string">&quot;demo2_hello_triangle&quot;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;subProjectName2&#125;</span> demo2_hello_triangle.cpp <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/glad.c)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;subProjectName2&#125;</span> <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib/glfw3.dll)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>目录结构如下：</p>
<p><img src="/images%5COpenGL%5C%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="目录结构"></p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.likecs.com/show-203849102.html">https://www.likecs.com/show-203849102.html</a></p>
<h1 id="2022-x2F-06-x2F-17"><a href="#2022-x2F-06-x2F-17" class="headerlink" title="2022&#x2F;06&#x2F;17"></a>2022&#x2F;06&#x2F;17</h1><p>要点：</p>
<ol>
<li>OpenGL是一种规范，它规定了函数的输入和输出，每个函数的具体运作方式是由不同的<strong>显卡</strong>厂商实现的。</li>
<li>OpenGL3.3的核心模式是其他高版本的基础。更高的OpenGL新版本特性只有更高级的显卡才能支持。</li>
<li>当显卡公司推出一个新的特性（拓展）时，这个<strong>Extension</strong>还未进入新的OpenGL规范，因此一般都是这样写的：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(GL_ARB_extension_name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用硬件支持的全新的现代特性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 不支持此扩展: 用旧的方式去做</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>OpenGL是一个巨大的<strong>状态机</strong>，它的当前状态叫做OpenGL上下文。通常使用如下途径去更改OpenGL状态：设置选项(State-changing Function)，操作缓冲。最后，我们使用当前OpenGL上下文来渲染(State-using Function)。</li>
<li>OpenGL的对象是指一些选项的集合，它是OpenGL状态的一个子集，类似C语言中的Struct。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> objectId = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">glGenObject</span>(<span class="number">1</span>, &amp;objectId);</span><br><span class="line"><span class="comment">// 绑定对象至上下文</span></span><br><span class="line"><span class="built_in">glBindObject</span>(GL_WINDOW_TARGET, objectId);</span><br><span class="line"><span class="comment">// 设置当前绑定到 GL_WINDOW_TARGET 的对象的一些选项</span></span><br><span class="line"><span class="built_in">glSetObjectOption</span>(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, <span class="number">800</span>);</span><br><span class="line"><span class="built_in">glSetObjectOption</span>(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, <span class="number">600</span>);</span><br><span class="line"><span class="comment">// 将上下文对象设回默认</span></span><br><span class="line"><span class="built_in">glBindObject</span>(GL_WINDOW_TARGET, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><strong>OpenGL的对象</strong>是指一些选项的集合，它是<strong>OpenGL状态</strong>的一个子集，类似C语言中的<strong>Struct</strong>。</li>
<li>使用对象的一个好处是在程序中，我们不止可以定义一个对象，并设置它们的选项，每个对象都可以是不同的设置。<strong>在我们执行一个使用OpenGL状态的操作的时候，只需要绑定含有需要的设置的对象即可。</strong>比如说我们有一些作为3D模型数据（一栋房子或一个人物）的容器对象，在我们想绘制其中任何一个模型的时候，只需绑定一个包含对应模型数据的对象就可以了（当然，我们需要先创建并设置对象的选项）。拥有数个这样的对象允许我们指定多个模型，在想画其中任何一个的时候，直接将对应的对象绑定上去，便不需要再重复设置选项了。</li>
</ol>
<h2 id="双缓冲-Double-Buffer"><a href="#双缓冲-Double-Buffer" class="headerlink" title="双缓冲(Double Buffer)"></a>双缓冲(Double Buffer)</h2><p>应用程序使用单缓冲绘图时可能会存在图像闪烁的问题。 这是因为生成的图像不是一下子被绘制出来的，而是按照从左到右，由上而下逐像素地绘制而成的。最终图像不是在瞬间显示给用户，而是通过一步一步生成的，这会导致渲染的结果很不真实。为了规避这些问题，我们应用双缓冲渲染窗口应用程序。<strong>前</strong>缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在<strong>后</strong>缓冲上绘制。当所有的渲染指令执行完毕后，我们<strong>交换</strong>(Swap)前缓冲和后缓冲，这样图像就立即呈显出来，之前提到的不真实感就消除了。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/th_gsb/article/details/50999307">https://blog.csdn.net/th_gsb/article/details/50999307</a></p>
<h2 id="延迟渲染："><a href="#延迟渲染：" class="headerlink" title="延迟渲染："></a>延迟渲染：</h2><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36696486/article/details/105206425">(76条消息) OpenGL学习笔记二十（延迟渲染）_绿洲守望者的博客-CSDN博客_opengl 延迟渲染</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/135444145">延迟渲染与MSAA的那些事 - 知乎 (zhihu.com)</a></li>
</ol>
<p>补充：Cmake的前世今生</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/448884264">捋一捋gcc&#x2F;g++&#x2F;MingW&#x2F;MSVC与make&#x2F;CMake的关系 - 知乎 (zhihu.com)</a></p>
<ol>
<li>linux&#x2F;windows平台下的编译器: gcc&#x2F;g++;</li>
<li>windows: MinGW&#x2F;MSVC;</li>
<li>IOS: LLVM(Clang)</li>
</ol>
<p>Make用于链接不同的文件，尤其是修改之后需要重新编译的情况，但是Make对类unix的平台支持的比较好，并且需要编写对应编译器的makefile，比较不方便，Make命令的执行就是寻找项目对应的makefile文件并执行，makefile内是不同编译命令的集合；</p>
<p>而Cmake是跨平台的，只需要编辑CmakeList.txt，把需要编译的文件、所依赖的环境、编译生成的可执行文件名等填写好，它就可以根据系统选择对应的构建生成器(Make&#x2F;VS)，将其翻译之后再用对应的编译器进行编译。</p>
<h2 id="入门：你好，三角形"><a href="#入门：你好，三角形" class="headerlink" title="入门：你好，三角形"></a>入门：你好，三角形</h2><ol>
<li>经过顶点着色器处理过的顶点坐标应该是位于[-1, 1]中的标准化设备坐标**(Normalized Device Coordinates, NDC)**。在这个范围外的坐标都会被裁剪掉，不会显示在屏幕上。</li>
<li>通过顶点缓冲对象(Vertex Buffer Objects, VBO)管理顶点着色器在GPU上创建的用于储存我们的顶点数据的内存，它会在GPU内存（通常被称为显存）中储存大量顶点。</li>
</ol>
<h1 id="2022-x2F-09-x2F-16"><a href="#2022-x2F-09-x2F-16" class="headerlink" title="2022&#x2F;09&#x2F;16"></a>2022&#x2F;09&#x2F;16</h1><h2 id="MingW"><a href="#MingW" class="headerlink" title="MingW"></a>MingW</h2><p>首先，尝试过5.2.4-5.2.5以及讨论最广的3.3.1，都不行。</p>
<p>遂尝试5.1.6</p>
<p>首先报错</p>
<p><img src="/images%5COpenGL%5Cfsseko%E6%8A%A5%E9%94%99.png" alt="fsseko报错"></p>
<p>直接把o去掉</p>
<p><img src="/images%5COpenGL%5Cfseek.png" alt="fseek"></p>
<p>然后报错：</p>
<p><img src="/images%5COpenGL%5Cundefined_1.png" alt="undefined_1"></p>
<p>根据<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33199236/article/details/118100009">(84条消息) mingw+cmake编译Assimp库遇到undefine问题_CN_swords的博客-CSDN博客</a>这个帖子重新cmake build文件之后，这时没有去掉BUILD_SHARED_LIBS：</p>
<p><img src="/images%5COpenGL%5Cmaximum.png" alt="maximum"></p>
<p>修改：</p>
<p><img src="/images%5COpenGL%5Cmax_2.png" alt="max_2"></p>
<p>原本没有&#x2F;2，因为看数字大小正好是2倍遂改之。</p>
<p>结果依旧：</p>
<p><img src="/images%5COpenGL%5Cundefined_2.png" alt="undefined_2"></p>
<p>遂去掉BUILD_SHARED_LIBS，大功告成（差点气死）。</p>
<p><img src="/images%5COpenGL%5Cover.png" alt="over"></p>
<p>ps：之后把相关code都改回去了。</p>
<h2 id="Visual-Studio-2019"><a href="#Visual-Studio-2019" class="headerlink" title="Visual Studio 2019"></a>Visual Studio 2019</h2><ol>
<li>5.2.5直接用cmake编译，编译器选vs2019</li>
<li>然后在vs项目中在属性里把include&#x2F;lib设置好，别忘了链接器的input</li>
<li>filesystem.h getenv报错，在属性-&gt;c&#x2F;c++-&gt;预处理器中加入_CRT_SECURE_NO_WARNINGS</li>
<li>然后是root_directory.h中设置项目的根目录<ol>
<li>const char * logl_root &#x3D; “D:&#x2F;LearningOpenGL&#x2F;LearnOpenGL”; </li>
<li>FileSystem读取文件的时候记得写根目录下的相对路径即可，比如：Model ourModel(FileSystem::getPath(“resources&#x2F;objects&#x2F;nanosuit&#x2F;nanosuit.obj”).c_str());</li>
</ol>
</li>
<li>model.h 中读取纹理报错，在”stb_image.h”之前加入#define STB_IMAGE_IMPLEMENTATION</li>
<li>shader的路径，是从cpp文件开始算，而不是exe本身所在的同级目录，所以是:     Shader ourShader(“..&#x2F;shaders&#x2F;demo14_shader.vs”, “..&#x2F;shaders&#x2F;demo14_shader.fs”);</li>
</ol>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhxmdefj/p/11374514.html">编译Assimp傻瓜教程 - zhxmdefj - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhxmdefj/p/11173754.html">OpenGL入门1.0：环境搭建 - zhxmdefj - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhxmdefj/p/11255134.html">OpenGL入门1.4：纹理&#x2F;贴图Texture - zhxmdefj - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_24367797/article/details/76977454">(84条消息) error C4996: ‘getenv’: This function or variable may be unsafe._天花板上飞着鱼的博客-CSDN博客</a></p>
<p>如果在同一个解决方案里需要创建多个项目，怎么不多次配置环境？</p>
<p>[OpenGL在VS2019上搭建环境 —— GLEW、GLFW以及GLUT - Colourso](<a target="_blank" rel="noopener" href="https://www.colourso.top/opengl-setup/#:~:text=%E7%84%B6%E5%90%8E%E6%89%93%E5%BC%80VS2019%EF%BC%8C%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%8C%E8%BF%99%E9%87%8C%E5%8F%96%E5%90%8D%E4%B8%BA">https://www.colourso.top/opengl-setup/#:~:text=然后打开VS2019，创建一个新的解决方案，这里取名为</a> opengl ，存放在 OpenGLRoot 目录下，添加一个 main.cpp,文件，这样便于配置C%2B%2B相关的东西。 右键项目，点击属性 (快捷键是 Alt %2B Enter)，在属性页的最上部选择配置为所有配置，平台选择活动Win32。)</p>
<p>更改vs工程项目名：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yebanliyu/article/details/121807428">(84条消息) vs2019 如何将项目修改为自己的项目-命名空间、cspoj名_夜半鲤鱼的博客-CSDN博客_vs修改命名空间</a></p>
<h1 id="OpenGL和DirectX的区别"><a href="#OpenGL和DirectX的区别" class="headerlink" title="OpenGL和DirectX的区别"></a>OpenGL和DirectX的区别</h1><h2 id="右乘还是左乘？"><a href="#右乘还是左乘？" class="headerlink" title="右乘还是左乘？"></a>右乘还是左乘？</h2><p>在OpenGL中，矩阵乘法是列优先的。[变换 - LearnOpenGL CN (learnopengl-cn.github.io)](<a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/01">https://learnopengl-cn.github.io/01</a> Getting started&#x2F;07 Transformations&#x2F;)中：</p>
<blockquote>
<p>在这里我们先把箱子围绕原点(0, 0, 0)旋转，之后，我们把旋转过后的箱子位移到屏幕的右下角。记住，实际的变换顺序应该与阅读顺序相反：尽管在代码中我们先位移再旋转，实际的变换却是先应用旋转再是位移的。</p>
</blockquote>
<p>在DirectX中，矩阵乘法在CPU端是行优先的（变换是<strong>从左至右</strong>的），但是在GPU端是列优先的，因此将矩阵传给GPU的时候需要进行转置。</p>
<p>但是，OpenGL不需要，CPU和GPU两端的矩阵是保持一致的，因此进行Model矩阵的计算时，依旧是<strong>从右至左</strong>进行变换。</p>
<h2 id="面剔除"><a href="#面剔除" class="headerlink" title="面剔除"></a>面剔除</h2><p>OpenGL中，逆时针为正；DirectX中，顺时针为正。</p>
<h1 id="2022-x2F-10-x2F-08"><a href="#2022-x2F-10-x2F-08" class="headerlink" title="2022&#x2F;10&#x2F;08"></a>2022&#x2F;10&#x2F;08</h1><h2 id="深度测试"><a href="#深度测试" class="headerlink" title="深度测试"></a>深度测试</h2><p>深度测试需要注意到的是，opengl里面，原本的z-eye在经过了投影变换之后变成了一个非线性的值，同时，经过透视除法之后变换到了ndc空间中，之后再经过视口变换（归一化）到[0-1]之间。</p>
<p>在进行深度的绘制、云雾效果等实现时，需要将这个z-value逆变换为z-eye，也就是先逆归一化到ndc空间中，然后再逆透视除法，然后再逆投影变换。</p>
<p>（公式推导待补充。）</p>
<p>深度还与光栅化过程中的插值有关。（待补充）</p>
<h2 id="模板测试"><a href="#模板测试" class="headerlink" title="模板测试"></a>模板测试</h2><p>以绘制物体轮廓为例：</p>
<p>模板测试，简单来说就是一个新的buffer——STENCIL_BUFFER。</p>
<p>先启用，然后设置<strong>glStencilOp</strong>(GL_KEEP, GL_KEEP, GL_REPLACE);用于控制<strong>stencil_buffer中的值</strong>如何更新（通过or不通过模板测试时如何更新）。</p>
<ul>
<li><code>sfail</code>：模板测试失败时采取的行为。</li>
<li><code>dpfail</code>：模板测试通过，但深度测试失败时采取的行为。</li>
<li><code>dppass</code>：模板测试和深度测试都通过时采取的行为。</li>
</ul>
<p><strong>GL_REPLACE</strong>则是指，<strong>通过模板测试之后</strong>将模板<strong>参考值ref</strong>写入到对应的buffer位置中。</p>
<p>它可以实现stencil_buffer的写入控制 用AND逻辑运算（相当于一个开关）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glStencilMask</span>(<span class="number">0x00</span>); <span class="comment">// 每一位在写入模板缓冲时都会变成0（禁用写入）</span></span><br><span class="line"><span class="built_in">glStencilMask</span>(<span class="number">0xFF</span>); <span class="comment">// 每一位写入模板缓冲时都保持原样</span></span><br></pre></td></tr></table></figure>

<ol>
<li>通过设置<strong>glStencilFunc</strong>(GL_ALWAYS, 1, 0xFF);是设置fragment如何通过模板测试。always就是指<strong>无论如何都通过测试</strong>，即都渲染出来，且将stencil_buffer更新为ref &#x3D;&#x3D; 1(因为设置了<strong>GL_REPLACE</strong>)。</li>
<li>最后一个参数是用这个值与参考值以及stencil_buffer中的值进行and运算，默认都为1。</li>
<li>在设置好func之后，将mask设置为FF，渲染fragment对应位置的stencil_buffer都写入为1。</li>
<li>然后关闭depth测试，<strong>glStencilFunc</strong>(GL_NOTEQUAL, 1, 0xFF);进行渲染时，跟stencil_buffer中的值进行比对，如果不相等，则渲染出来，否则不渲染；此时需要<strong>mask</strong>设置为00，所以通过测试的fragment的stencil_buffer<strong>不会</strong>设置为ref &#x3D;&#x3D; 1。</li>
<li>最后要把depth测试打开，同时设置mask&#x3D;&#x3D;FF。这是因为，while循环中每次开始都会clear屏幕，需要将stencil_buffer重新设置为0，用always + ref &#x3D; 0即可。</li>
</ol>
<p>用途：物体描边、后视镜贴图、shadow volume</p>
<p>物体轮廓所能做的事情正如它名字所描述的那样。我们将会为每个（或者一个）物体在它的周围创建一个很小的有色边框。当你想要在策略游戏中选中一个单位进行操作的，想要告诉玩家选中的是哪个单位的时候，这个效果就非常有用了。为物体创建轮廓的步骤如下：</p>
<blockquote>
<ol>
<li>在绘制（需要添加轮廓的）物体之前，将模板函数设置为GL_ALWAYS，每当物体的片段被渲染时，将模板缓冲更新为1。</li>
<li>渲染物体。</li>
<li>禁用模板写入以及深度测试。 &#x2F;&#x2F; 保证边框能够输出在满足模板测试后的所有物体之上，和深度无关；且不能改变深度值，因此直接把深度测试关了</li>
<li>将每个物体缩放一点点。</li>
<li>使用一个不同的片段着色器，输出一个单独的（边框）颜色。</li>
<li>再次绘制物体，但只在它们片段的模板值不等于1时才绘制。</li>
<li>再次启用模板写入和深度测试。</li>
</ol>
</blockquote>
<p>这个过程将每个物体的片段的模板缓冲设置为1，当我们想要绘制边框的时候，我们主要绘制放大版本的物体中模板测试通过的部分，也就是物体的边框的位置。我们主要使用模板缓冲丢弃了放大版本中属于原物体片段的部分。</p>
<h2 id="混合：alpha通道的使用"><a href="#混合：alpha通道的使用" class="headerlink" title="混合：alpha通道的使用"></a>混合：alpha通道的使用</h2><ol>
<li><p>第一种是直接discard；（比如a小于某个阈值，直接在fs内discard掉这个像素，不绘制，要注意纹理的插值方式改为clamp）</p>
</li>
<li><p>第二种是使用GL_BLEND，然后设置混合函数的因子如何获取。</p>
<ol>
<li><p>混合因子：一般都是后面的物体颜色 * (1-a) + 前面这个物体颜色 * a，a是前面这个物体的alpha通道值。设置方式即：glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</p>
</li>
<li><p><strong>前后有多个透明物体叠加</strong>时，<strong>要考虑绘制次序的问题</strong>。如果不按照从远到近的方式进行渲染，那么透明物体后面的本来应该可以看到的物体会无法通过深度测试。所以需要使用map，将相机到物体的distance设置为key，物体位置设置为value进行存储，map会根据key升序排序。然后再倒序进行渲染即可。</p>
<blockquote>
<p>因为个人观察到LearnOpenGL的案例中直接使用T变换作为平移后的物体坐标，因此思考了一下应该<strong>怎么正确计算camera到物体的距离</strong>。</p>
<p>在LearnOpenGL中直接导入vertex的顶点位置其实就是世界坐标系下的坐标点（一般只有一个简单的面，那么z &#x3D; 0）；且因为模型导入到世界坐标系的时候一般都是<strong>直接将模型原点（模型原点时建模的时候建模师人为规定的）和世界坐标系原点重合</strong>，即将世界坐标系原点当作模型的原点，那么model变换中平移T &#x3D; (x, y, z)就是相对世界坐标系&#x2F;模型原点 &#x3D; (0, 0, 0)而言的，那么(x, y, z)相当于 &#x3D;&#x3D; 模型平移之后它的原点在世界坐标系下的坐标点，因此可以直接求(x, y, z)和camera在世界坐标系下的位置之间的距离，然后用这个距离排序即可。</p>
<p><img src="/images/OpenGL/%E8%A7%84%E5%AE%9A%E6%A8%A1%E5%9E%8B%E5%8E%9F%E7%82%B9.png" alt="规定模型原点"></p>
<p>上图描述了一种规定模型原点和实际模型中心不一致的情况。假设obj1和obj2都是同一个模型的副本，它们导入世界坐标系后从原点开始只经过了平移变换到了现在的位置。如果是按照人为规定的模型原点计算到camera的距离，那么B在前；如果是按照真实的重心坐标计算到camera的距离，那么A在前。</p>
<p>如果这两个物体正好是透明物体，那么错误的排序会导致错误的渲染结果。因此应该尽可能保证模型原点尽量是物体的重心（？）</p>
<p>但是，如果考虑到camera的朝向和真实模型的复杂程度，那么距离肯定不能这么简单的计算…</p>
</blockquote>
</li>
<li><p>补充：注意，普通的深度测试，是将当前fragment的z-value与depth_buffer进行对比，如果小于，就绘制出来，如果大于，就直接丢弃，<strong>完全不需要考虑绘制物体的次序问题</strong>。但有alpha通道的透明物体，如果乱序排序，那么就会在<strong>比它先绘制</strong>的fragment基础上，去<strong>进行blend</strong>，这样无法保证它后面的透明物体也会被绘制出来（<strong>因为z-value比它小，如果是在绘制了这个物体之后去绘制它后面的物体，那么就无法绘制出来，但这不是我们想要的结果</strong>），所以说需要从后往前绘制更新fragment_buffer的值，这样才能mix出正确的值。(伪代码如下)</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先绘制非透明物体</span></span><br><span class="line"><span class="keyword">if</span> (z_value &lt; depth_buffer[index]) &#123;</span><br><span class="line">    overlap... <span class="comment">// 直接覆盖fragment_buffer[index]的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再绘制透明物体</span></span><br><span class="line"><span class="keyword">if</span> (z_value &lt; depth_buffer[index]) &#123;</span><br><span class="line">    blend... <span class="comment">// blend过程中需要使用当前fragment_buffer[index]的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>有透明物体的绘制准则如下：</p>
<ol>
<li><p>先绘制所有不透明的物体。</p>
</li>
<li><p>对所有透明的物体排序。</p>
</li>
<li><p>按顺序绘制所有透明的物体。</p>
</li>
<li><p>更高级的技术还有<strong>次序无关透明度</strong>(Order Independent Transparency, OIT)。</p>
</li>
</ol>
</li>
</ol>
<h2 id="补充0："><a href="#补充0：" class="headerlink" title="补充0："></a>补充0：</h2><p>联想到了GAMES101作业中使用MSAA之后出现黑线的问题。绘制的过程是<strong>类似blend</strong>的，相当于是 &#x3D; percent * 三角形颜色 + (1 - percent) * framebuffer颜色。</p>
<p>因此，如果先绘制前面的物体，在绘制边缘的时候就需要进行MSAA，就会出现类似混合的情况，如果绘制完成后同时修改了depth_buffer的值，那么后面的三角形在绘制的时候，这个像素就无法通过深度测试，那么就会出现一条黑线，尽管这个像素已经被着色了，但是它没有正确被混合。</p>
<p>因此上层的三角形使用MSAA对边缘像素进行着色时应该关闭深度写入，再绘制后面的物体；或者是先绘制下层的三角形，然后再绘制上层的三角形（类似绘制透明物体时先绘制后面的物体）。</p>
<blockquote>
<p>那么，绘制透明物体的时候可以关闭深度写入，先绘制前面的物体，再绘制后面的物体吗？</p>
<p><strong>不可以</strong>，因为蓝色在上和红色在上分别是不一样的效果（后绘制的物体的因子会比frame buffer的因子大）。所以一定要先绘制位于后面的物体再绘制位于前面的物体，否则效果会出错。</p>
</blockquote>
<h3 id="为何要在渲染透明物体时关闭深度写入？"><a href="#为何要在渲染透明物体时关闭深度写入？" class="headerlink" title="为何要在渲染透明物体时关闭深度写入？"></a>为何要在渲染透明物体时关闭深度写入？</h3><p>大多数的文章都会提到，在渲染透明物体时一定要关闭深度写入，但是有些文章并没有写清楚理由（大部分是说因为如果先渲染前方的不透明物体，并且写入z-buffer，后面的物体就没办法通过深度测试。但是这个问题明显可以通过排序物体的渲染顺序解决，因此不是关闭深度写入的理由。况且LearnOpenGL中只强调过渲染半透明物体的顺序，而没有强调一定要关闭深度写入）。</p>
<p>结合下面补充1-3的例子讲讲为何要在渲染透明物体时关闭深度写入。</p>
<p>首先我们知道，一定要先渲染不透明物体，再从远到近渲染透明物体，这个过程中似乎确实可以不用关闭渲染写入，但是这样无法使得一个<strong>有复杂结构的透明物体</strong>得到正确的渲染结果。</p>
<p>这是因为渲染过程中，如果不关闭深度写入，如果这个物体靠前的面片先被渲染，那么它的深度信息就会被写入，它靠后的面片就无法通过深度测试，会被遮挡住。</p>
<p>因此如果是一个本身就很复杂的透明物体，因为我们<strong>无法控制它像素的渲染顺序</strong>，所以必须要关闭深度写入。</p>
<h2 id="补充1："><a href="#补充1：" class="headerlink" title="补充1："></a>补充1：</h2><p>来源：<a target="_blank" rel="noopener" href="https://blog.csdn.net/reload0236/article/details/107579865">https://blog.csdn.net/reload0236/article/details/107579865</a></p>
<p>最近复习透明物体的渲染方式，让我又浮现出了曾经的疑惑：为什么透明物体渲染要关闭深度写入？于是查了很多资料，却也没有把这个问题说的特别明白，而且很多情况下分别对比深度开和关的渲染结果，二者也没有任何显示上的差异，最后借用《Unity Shader入门精要》里面的一个例子摆弄了一下，终于把这个问题想明白了。</p>
<p>大部分的渲染引擎对透明物体的处理方式过程为：首先渲染所有的不透明物体，其次对所有的透明物体由远到近后排序后开启混合进行渲染（在此过程中<strong>关闭深度写入</strong>）。</p>
<p><strong>我一开始的想法是这样的，既然不透明物体都经过由远到近排序了，那么即使深度写入是开启的，所有透明物渲染时也是可以通过深度测试的，实际上，对于简单场景模型来说深度写入关与否确实是没有区别。</strong></p>
<p>而问题在渲染<strong>单个复杂模型</strong>的情况下就暴露出来了，一般情况下我们<strong>无法对单个模型进行像素级别的渲染排序</strong>，以下面的这个透明环状物体为例，最左侧部分的网格最先渲染，<strong>在开启深度写入的情形下，后面部分的网格就无法通过深度测试，结果被GPU剔除了。</strong>再对比一下第二张图，关闭深度写入的情形，所有的片元都会参与到混合渲染的过程中，虽然渲染结果并非完全正确，但是对比之下也是相对正确。（ps：想要获得理想的透明效果不是一件简单的事情，暂时不在本文讨论范围之内）</p>
<p><img src="https://img-blog.csdnimg.cn/20200725163235630.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20200725163250569.png" alt="img"></p>
<h2 id="补充2："><a href="#补充2：" class="headerlink" title="补充2："></a>补充2：</h2><p>来源：<a target="_blank" rel="noopener" href="https://blog.csdn.net/sixdaycoder/article/details/78093531">(76条消息) 透明物体的渲染_SixDayCoder的博客-CSDN博客_透明物体渲染</a></p>
<p>一般来说，我们使用Alpha Test（透明度测试）或者Alpha Blend（透明度混合）来实现透明效果，其中Alpha Blend（之后简称）Blend可以实现真正的半透明效果。</p>
<p>无论哪种实现方式，我们都需要<strong>关闭透明物体的深度写入</strong>（禁止ZWrite）。</p>
<p>为什么要关闭透明物体的深度写入？</p>
<p>设想一种情况，假设半透明物体A在不透明物体B的前面。</p>
<p>如果开启了深度写入，那么由于A在B的前面，ZBuffer中存储的肯定是A的Z值，那么B就无法通过ZTest，导致A的颜色会覆盖掉B的颜色。这样最终呈现的效果就是半透明物体A挡住了不透明物体B，这显然不是我们需要的结果。</p>
<p>所以，我们必须<strong>关闭透明物体的深度写入</strong>，不过这样做实际上破坏了深度缓冲的工作机制，这带来了很大的副作用，为了让深度缓冲机制正常工作，我们就必须严格的控制物体的<strong>渲染顺序</strong>。</p>
<h3 id="半透明物体和不透明物体的渲染顺序"><a href="#半透明物体和不透明物体的渲染顺序" class="headerlink" title="半透明物体和不透明物体的渲染顺序"></a>半透明物体和不透明物体的渲染顺序</h3><p>假设半透明物体A和不透明物体B，A仍然在B的前面。</p>
<ol>
<li>先渲染半透明物体A再渲染不透明物体B ：<ol>
<li>渲染A，ZBuffer为空，通过ZTest，由于关闭了透明物体的ZWrite，所以A的Z值不会写入ZBuffer</li>
<li>渲染B，实际上此时ZBuffer还是初始值，B通过ZTest之后直接写入ZWrite，导致B的颜色覆盖掉A。</li>
</ol>
</li>
<li>先渲染不透明物体B再渲染透明物体A<ol>
<li>渲染B，ZBuffer为空，通过ZTest，B的Z值写入ZBuffer。</li>
<li>渲染A，由于A是在B的前面，所以A会通过ZTest（但不写入ZWrite），之后根据设置好的Blend公式做出混合操作，实现半透明效果。</li>
</ol>
</li>
</ol>
<p>结论是，如果半透明物体和不透明物体共存，那么首先开启ZWrire，渲染不透明物体。再关闭ZWrite，渲染半透明物体。</p>
<h3 id="半透明物体和半透明物体的渲染顺序"><a href="#半透明物体和半透明物体的渲染顺序" class="headerlink" title="半透明物体和半透明物体的渲染顺序"></a>半透明物体和半透明物体的渲染顺序</h3><p>假设半透明物体A和半透明物体B， A在B的前面。</p>
<ol>
<li>先渲染A再渲染B ：<ol>
<li>渲染A，ZBuffer为空，通过ZTest，将A写入Framebuffer（颜色缓冲不是ZBuffer）</li>
<li>渲染B，ZBuffer仍然为空，通过ZTest，将B和A颜色混合。如果使用SrcAlpha和OneMinusSrcAlpha这样的公式，会让B的颜色重于A，造成了B在A前面的视觉效果。</li>
</ol>
</li>
<li>先渲染B再渲染A ：<ol>
<li>渲染B，ZBuffer为空，通过ZTest，将B写入Framebuffer（颜色缓冲不是ZBuffer）</li>
<li>渲染A，ZBuffer仍然为空，通过ZTest，将B和A颜色混合。如果使用SrcAlpha和OneMinusSrcAlpha这样的公式，会让A的颜色重于B，A在B前面的视觉效果，正是我们要的效果。</li>
</ol>
</li>
</ol>
<p>结论是，多个透明物体，要按照由远到近的顺序渲染。</p>
<h3 id="PS-Blend公式"><a href="#PS-Blend公式" class="headerlink" title="PS : Blend公式"></a>PS : Blend公式</h3><p>$$<br>DstColor(new)&#x3D;SrcAlpha∗SrcColor+(1−SrcAlpha)∗DstColor(old)<br>$$</p>
<p>其中DstColor是颜色缓冲中的颜色值，SrcColor是(纹理采样+光照计算)后的的颜色，SrcAlpha是纹理采样的alpha通道。</p>
<h3 id="开启ZWrite的透明效果"><a href="#开启ZWrite的透明效果" class="headerlink" title="开启ZWrite的透明效果"></a>开启ZWrite的透明效果</h3><p>关闭ZWrite并依靠排序的方法来搞定渲染顺序，有时候也会出错（因为某个model很可能是多个不在一个平面上的不规则模型），这里有一种开启ZWrite的渲染方法。</p>
<p>核心思想就是渲染两次：</p>
<p>第一遍渲染开启ZWrite但是不把颜色写入到Framebuffer中，得到一个正确结果的ZBuffer<br>第二遍渲染就像正常的Blend过程，关闭ZWrite直接混合，由于深度信息已经正确，所以无需排序。<br>这样的方法是比较消耗性能的，之前的Blend效果就比较可以，一般不使用这种方式。</p>
<p>PS ： 这种方法仅适用于渲染半透明物体，对不透明物体不需要这么做。</p>
<h3 id="双向透明渲染"><a href="#双向透明渲染" class="headerlink" title="双向透明渲染"></a>双向透明渲染</h3><p>核心思想也是渲染两次 ：</p>
<p>第一次渲染，CullFront，渲染背面，剔除前面，当然这个过程是关闭ZWrite的，就像常规的Blend操作。<br>第二次渲染，CullBack， 渲染前面，剔除背面，当然这个过程是关闭ZWrite的，就像常规的Blend操作。<br>这两次渲染隐含了半透明物体共存时，渲染顺序必须是由远到近的顺序渲染。</p>
<h2 id="补充3："><a href="#补充3：" class="headerlink" title="补充3："></a>补充3：</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/416887453#:~:text=%E6%88%91%E4%BB%AC%E7%9B%B4%E6%8E%A5%E8%80%83%E8%99%91%E4%B8%8D%E5%85%B3,%E7%89%A9%E4%BD%93%E5%B0%86%E4%B8%8D%E4%BC%9A%E8%A2%AB%E6%B8%B2%E6%9F%93">UnityShader中的透明渲染 - 知乎 (zhihu.com)</a></p>
<p>前言：<br>前前后后庄懂老师的课和百人计划的课程等一大堆资料看了不少，借着解决群友问题的契机回过头再翻看《入门精要》才发现很多东西已经在书上写的明明白白，当时只是一知半解的走马观花，<br>由此看来，在适当的时机回头看一遍以前看过的东西还是很有必须要的。<br>趁着今天还有点记忆，就把第八章整理一哈，其中有一些概念&#x2F;原话可以在百人的early-z和庄懂13课中找到答案</p>
<h2 id="引言：Visibility可见性＆渲染顺序"><a href="#引言：Visibility可见性＆渲染顺序" class="headerlink" title="引言：Visibility可见性＆渲染顺序"></a>引言：Visibility可见性＆渲染顺序</h2><ul>
<li><p>在不考虑透明度&#x2F;半透明效果时，我们不是很强调<strong>渲染顺序</strong>， 这是因为有<strong>深度缓冲</strong>的存在</p>
</li>
<li><p>深度缓冲解决了可见性的问题</p>
</li>
<li><p><strong>Visibility（可见性）</strong></p>
</li>
<li><ul>
<li><p>可见性决定哪个物体的哪个部分会被渲染在前面，而哪些部分会被其他物体遮挡</p>
</li>
<li><p>基本思想是</p>
</li>
<li><ul>
<li>根据深度缓冲中的值来判断该片元到摄像机的距离</li>
<li>当要渲染一个片元时，就拿这个片元的深度值和已经存在深度缓冲区中的值进行比较</li>
<li>如果片元的值距离摄像机更远，那它就不该被渲染（有东西挡在它前边）</li>
<li>否则这个片元就应该覆盖掉此时深度缓冲区中的像素值（它在最前边），并把它的深度值更新到深度缓冲区中（如果开启了深度写入）</li>
</ul>
</li>
</ul>
</li>
<li><p>但是，当我们考虑透明效果时，事情就不是上述这么无脑&#x2F;简单了，因为实现透明效果时，我们一般会<strong>关闭深度写入（Z-Write）</strong>。</p>
</li>
</ul>
<h2 id="一、什么是透明度测试（Alpha-Test-x2F-Cutout）"><a href="#一、什么是透明度测试（Alpha-Test-x2F-Cutout）" class="headerlink" title="一、什么是透明度测试（Alpha Test&#x2F;Cutout）"></a>一、什么是透明度测试（Alpha Test&#x2F;Cutout）</h2><ul>
<li>首先要说的是，透明度测试（AlphaTest）并不能实现<strong>半透明效果</strong>，而且<strong>不用关闭深度写入</strong>。</li>
</ul>
<h3 id="1、基本思想"><a href="#1、基本思想" class="headerlink" title="1、基本思想"></a>1、基本思想</h3><ul>
<li><ul>
<li>设置一个透明度不满足条件（阈值），对片元的判断</li>
<li>如果不满足条件，这个片元就会被舍弃，之后不会进行任何操作</li>
<li>如果满足，就会按照不透明物体的处理方式来处理它</li>
<li>总结成一句话就是：设置一个透明度范围，如果符合这个范围就进行渲染，否则就舍弃</li>
</ul>
</li>
</ul>
<h3 id="2、具体操作-x2F-实现"><a href="#2、具体操作-x2F-实现" class="headerlink" title="2、具体操作&#x2F;实现"></a>2、具体操作&#x2F;实现</h3><ul>
<li><ul>
<li><p>&#x2F;&#x2F;接下来只整理知识结构、思路，具体实现原理、代码内容略，可以自行查阅（能自己查阅相关资料才是学习，光看是学不会的，这个本人亲测2333）</p>
</li>
<li><p>定义阈值参数，利用clip函数进行AlphaTest，实现对不满足要求的片元的“裁剪”</p>
</li>
<li><p>参考资料</p>
</li>
<li><ul>
<li>入门精要内容</li>
<li>庄懂老师的TA课，L13-AlphaCutout</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h3><ul>
<li><ul>
<li>AlphaTest是一个“一刀切”的操作，设定一个阈值&#x2F;范围，对于满足我们要求的片元，就行类似不透明物体的渲染，对位不满足的片元，就直接舍弃</li>
<li>这样一来，实际上并不能实现半透明效果（下图为阈值从1到0的变化）</li>
</ul>
</li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-290fabca025ee7ac290192739f87d2a3_b.jpg" alt="动图封面"></p>
<ul>
<li>如果想要实现半透明效果，我们就需要再进一步，了解AlphaBlend-透明度混合</li>
</ul>
<h2 id="二、什么是透明度混合（Alpha-Blend）"><a href="#二、什么是透明度混合（Alpha-Blend）" class="headerlink" title="二、什么是透明度混合（Alpha Blend）"></a>二、什么是透明度混合（Alpha Blend）</h2><ul>
<li>AlphaBlend可以实现半透明效果，但是<strong>需要关闭深度写入</strong>。（没有关闭深度测试）</li>
</ul>
<p><img src="https://pic3.zhimg.com/v2-0f651b3f5c1c2fe669b668121adc4af6_b.webp" alt="动图"></p>
<p>（透明度从1到0的过程）</p>
<h3 id="1、基本思想-1"><a href="#1、基本思想-1" class="headerlink" title="1、基本思想"></a>1、基本思想</h3><ul>
<li>使用<strong>当前片元的透明度</strong>作为<strong>混合因子</strong>，与已经<strong>存在颜色缓冲区中</strong>的<strong>颜色值</strong>进行混合，来得到新的颜色</li>
</ul>
<h3 id="2、具体实现"><a href="#2、具体实现" class="headerlink" title="2、具体实现"></a>2、具体实现</h3><ul>
<li>关闭深度写入（ZWrite Off）</li>
<li>更改混合模式为： Blend SrcAlpha OneMinusSrcAlpha</li>
<li>片元着色器中的返回值的a通道更改为对应内容</li>
<li>&#x2F;&#x2F;参考入门精要、庄懂TA-L13-AB</li>
</ul>
<h3 id="3、为什么AlphaBlend并没有错误的遮挡关系"><a href="#3、为什么AlphaBlend并没有错误的遮挡关系" class="headerlink" title="3、为什么AlphaBlend并没有错误的遮挡关系"></a>3、为什么AlphaBlend并没有错误的遮挡关系</h3><ul>
<li>因为深度测试并没有关闭，也就是说在渲染一个片元时，还会将它的深度值和深度缓冲区中的深度值作比较，如果它离摄像机更远（有东西在它前边），就不进行混合操作</li>
<li>还有Unity<strong>“渲染队列”（Queue）</strong>的存在</li>
</ul>
<h2 id="三、为什么渲染顺序很重要性"><a href="#三、为什么渲染顺序很重要性" class="headerlink" title="三、为什么渲染顺序很重要性"></a>三、为什么渲染顺序很重要性</h2><p>首先我们来讲一下<strong>为什么在实现半透明效果的Alpha Test时，要关闭深度写入</strong></p>
<ul>
<li><p>我们直接考虑不关闭深度写入的情况：如果在透明物体后边有不透明物体，如果开启深度写入的话，因为后边的不透明物体离摄像机更远，因为深度缓冲的原因，在透明物体后边的不透明物体将不会被渲染</p>
</li>
<li><ul>
<li>这很明显是错误的，因为这样一来，<strong>我们就不能透过透明物体看到它后边的不透明物体了</strong></li>
</ul>
</li>
</ul>
<p>接下来我们通过两个例子来理解<strong>渲染顺序的重要性</strong></p>
<h3 id="例1：半透明物体和不透明物体"><a href="#例1：半透明物体和不透明物体" class="headerlink" title="例1：半透明物体和不透明物体"></a>例1：半透明物体和不透明物体</h3><p><img src="https://pic1.zhimg.com/80/v2-e76f4c9551e0e3e7521e4642ef73180c_720w.webp" alt="img"></p>
<ul>
<li><p><strong>情况一：先渲染B再渲染A</strong></p>
</li>
<li><ul>
<li><p>渲染B时</p>
</li>
<li><ul>
<li>深度测试和写入都开启 ，所以B的数据会写入颜色缓冲区和深度缓冲区</li>
</ul>
</li>
<li><p>渲染A时</p>
</li>
<li><ul>
<li>关闭深度写入，进行深度测试</li>
<li>深度测试的结果是A离相机的具体比B更近，所以我们会将A的透明度和颜色缓冲区中B的颜色值进行混合</li>
<li>得到的结果正确</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>情况二：先渲染A再渲染B</strong></p>
</li>
<li><ul>
<li><p>渲染A时</p>
</li>
<li><ul>
<li>因为深度写入关闭，此时只将A写入了颜色缓冲区</li>
</ul>
</li>
<li><p>渲染B时</p>
</li>
<li><ul>
<li>因为深度缓冲区并没有数据，所以B就会直接覆盖颜色缓冲区中的A的颜色</li>
<li>很显然这个结果是错误的（结果的视觉上，B在A前边）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>结论：</strong></p>
</li>
<li><ul>
<li>应该先渲染不透明物体再渲染半透明物体</li>
</ul>
</li>
</ul>
<h3 id="例2：半透明物体之间"><a href="#例2：半透明物体之间" class="headerlink" title="例2：半透明物体之间"></a>例2：半透明物体之间</h3><p><img src="https://pic1.zhimg.com/80/v2-61d432fe4c9daf849a8a7245fd9f34c8_720w.webp" alt="img"></p>
<ul>
<li><p><strong>情况一：先渲染B再渲染A</strong></p>
</li>
<li><ul>
<li><p>渲染B时</p>
</li>
<li><ul>
<li>B会正常的写入颜色缓冲区</li>
</ul>
</li>
<li><p>渲染A时</p>
</li>
<li><ul>
<li>A会和颜色缓冲区中的B混合，得到正确的结果</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>情况二：先渲染A再渲染B</strong></p>
</li>
<li><ul>
<li><p>渲染A时</p>
</li>
<li><ul>
<li>会将A写入颜色缓冲区</li>
</ul>
</li>
<li><p>渲染B时</p>
</li>
<li><ul>
<li>会将B和颜色缓冲中的A混合，得到的结果会反过来</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>结论：</strong></p>
</li>
<li><ul>
<li>半透明物体，应该从后往前渲染</li>
</ul>
</li>
</ul>
<h3 id="Unity-Shader的渲染顺序"><a href="#Unity-Shader的渲染顺序" class="headerlink" title="Unity Shader的渲染顺序"></a>Unity Shader的渲染顺序</h3><ul>
<li><strong>Unity内置的几种渲染队列</strong>：</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-bfb55382e93ccc3986fb8e23045a5bdf_720w.webp" alt="img"></p>
<p><strong>按照渲染顺序从先到后排序，队列数越小，越先渲染；反之同理。</strong></p>
<ul>
<li><p><strong>Unity中设置渲染队列</strong>：</p>
</li>
<li><ul>
<li>语法：Tags { “Queue” &#x3D; “渲染队列名”}</li>
<li>默认是Geometry</li>
</ul>
</li>
<li><p><strong>Unity中不透明物体的渲染顺序：从前往后</strong></p>
</li>
<li><ul>
<li><strong>也就是说深度小的先渲染，其次再渲染深度大的</strong></li>
</ul>
</li>
<li><p><strong>Unity中透明物体的渲染顺序：从后往前（类似画家算法，会造成OverDraw）</strong></p>
</li>
<li><p>可以在shader的Inspector面板中查看渲染队列相关属性</p>
</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-a1ffad00d1cdb4b88227dba11d151edc_720w.webp" alt="img"></p>
<h2 id="四、开启深度写入的半透明效果（Z-Prepass）"><a href="#四、开启深度写入的半透明效果（Z-Prepass）" class="headerlink" title="四、开启深度写入的半透明效果（Z-Prepass）"></a>四、开启深度写入的半透明效果（Z-Prepass）</h2><h3 id="1、透明度混合的特殊情况"><a href="#1、透明度混合的特殊情况" class="headerlink" title="1、透明度混合的特殊情况"></a>1、透明度混合的特殊情况</h3><p>前边我们阐述了<strong>为什么透明度混合并没有产生错误的遮挡关系</strong><br>那么有没有特殊情况呢？</p>
<ul>
<li>答案是有的，当模型本身有复杂的遮挡关系，或者包含了复杂的非凸网格时，就会因为各种排序错误而产生的错误的透明效果</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-ee8852bab053fca94c85e64befca1422_720w.webp" alt="img"></p>
<ul>
<li>这是因为在透明度混合时我们关闭了深度写入，这样我们就<strong>无法对模型进行像素级的深度排序</strong></li>
</ul>
<h3 id="2、Pre-Z（ZPrepass）"><a href="#2、Pre-Z（ZPrepass）" class="headerlink" title="2、Pre-Z（ZPrepass）"></a>2、Pre-Z（ZPrepass）</h3><p>有没有方法解决上述问题呢？</p>
<ul>
<li>答案同样是有的，既然问题是关闭了深度写入，我们想办法再把深度写入利用回来不就行了</li>
</ul>
<p>一般PreZ有两种做法：双Pass、提前分离的PreZ<br><strong>双Pass</strong></p>
<ul>
<li><p>我们使用两个pass完成模型的渲染</p>
</li>
<li><ul>
<li>Pass1：开启深度写入，但不输出颜色，目的只是为了把该模型的深度信息写入到深度缓冲区中</li>
<li>Pass2：关闭深度写入，进行正常的透明度混合</li>
</ul>
</li>
</ul>
<p><strong>提前分离的PreZ</strong></p>
<ul>
<li>同样要使用两个pass，将pass1的z-prepass单独分离出一个shader，并用这个shader将场景的不透明物体先渲染一遍</li>
</ul>
<p><strong>参考扩展</strong></p>
<ul>
<li>百人计划3.5</li>
</ul>
<h2 id="五、ShaderLab的混合命令（混合模式）"><a href="#五、ShaderLab的混合命令（混合模式）" class="headerlink" title="五、ShaderLab的混合命令（混合模式）"></a>五、ShaderLab的混合命令（混合模式）</h2><p>在上述Alpha Blend的具体实现部分，我们已经用了混合命令，当然我们只是简单的说了将Blend Mode（混合模式）改为具体哪一个，却没说原因。实际上，混合还有其他用处，不仅仅是透明度混合</p>
<h3 id="1、混合是如何实现的"><a href="#1、混合是如何实现的" class="headerlink" title="1、混合是如何实现的"></a>1、混合是如何实现的</h3><p>当片元在片元着色器产生一个颜色时，可以渲染与颜色缓冲中的颜色进行混合，这样一来，就有两个操作数可以控制混合：<strong>源颜色（source color）、目标颜色（destination color）</strong></p>
<ul>
<li>源颜色，用S表示，指的是片元shader产生的颜色值</li>
<li>目标颜色，用D表示，指的是从颜色缓冲区中取出的颜色值</li>
<li>当然在我们说这两种颜色时，它们都包含了RGBA四个通道</li>
</ul>
<h3 id="2、感性理解"><a href="#2、感性理解" class="headerlink" title="2、感性理解"></a>2、感性理解</h3><ul>
<li>Src-源，相当于混合的上边图层</li>
<li>Dst-目标，相当于混合的下边图层</li>
</ul>
<h3 id="3、混合等式、混合参数"><a href="#3、混合等式、混合参数" class="headerlink" title="3、混合等式、混合参数"></a>3、混合等式、混合参数</h3><p>实际上，最终的结果不是单纯的上边图层叠在下边图层，而是：两者分别乘一个自己“乘子&#x2F;因子”，再运算。所以混合公式就是：<strong>Src*SrcFactor op Dst*DstFactor</strong><br>在设置混合状态时，实际上设置的就是公式中的<strong>混合因子</strong>和<strong>操作符op（默认为+）</strong><br>在入门精要里，将这个等式分为了rgb和a通道两个公式：</p>
<ul>
<li>Orgb &#x3D; SrcFactor × Srgb + DstFactor × Drgb</li>
<li>Oa &#x3D; SrcFactorA × Sa + DstFactorA × Da</li>
</ul>
<h3 id="4、混合操作、其他参考"><a href="#4、混合操作、其他参考" class="headerlink" title="4、混合操作、其他参考"></a>4、混合操作、其他参考</h3><p><img src="https://pic4.zhimg.com/80/v2-0dc54f66dca28b27da9c668d7a4e0c3f_720w.webp" alt="img"></p>
<p>常用混合模式：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//正常(Normal),</span><br><span class="line">即透明度混合</span><br><span class="line">Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">//柔和相加(Soft Additive)</span><br><span class="line">Blend OneMinusDstColor One</span><br><span class="line">//正片叠底(Multiply), 即相乘</span><br><span class="line">Blend DstColor Zero</span><br><span class="line">//两倍相乘(2x Multiply)</span><br><span class="line">Blend DstColor SrcColor</span><br><span class="line">//变暗(Darken)</span><br><span class="line">BlendOp Min</span><br><span class="line">Blend One One</span><br><span class="line">//变亮(Lighten)</span><br><span class="line">BlendOp Max</span><br><span class="line">Blend One One</span><br><span class="line">//滤色(Screen)</span><br><span class="line">Blend OneMinusDstColor One</span><br><span class="line">//等同于</span><br><span class="line">Blend One OneMinusSrcColor</span><br><span class="line">//线性减淡(Linear Dodge)</span><br><span class="line">Blend One One</span><br></pre></td></tr></table></figure>

<p><img src="https://pic3.zhimg.com/80/v2-3bbea57039ecbde9735c05ec17362272_720w.webp" alt="img"></p>
<h2 id="六、双面渲染的透明效果（剔除）"><a href="#六、双面渲染的透明效果（剔除）" class="headerlink" title="六、双面渲染的透明效果（剔除）"></a>六、双面渲染的透明效果（剔除）</h2><p>默认渲染情况下，Unity引擎会帮我们剔除物体背面而只渲染物体正面。<br>如果我们想要得到双面渲染的效果，就需要改变相关指令</p>
<h3 id="1、剔除指令"><a href="#1、剔除指令" class="headerlink" title="1、剔除指令"></a>1、剔除指令</h3><ul>
<li>剔除正面：Cull Front</li>
<li>剔除背面：Cull Back</li>
<li>关闭剔除：Cull Off</li>
</ul>
<h3 id="2、AlphaTest的双面渲染"><a href="#2、AlphaTest的双面渲染" class="headerlink" title="2、AlphaTest的双面渲染"></a>2、AlphaTest的双面渲染</h3><p>只需要关闭剔除即可</p>
<h3 id="3、AlphaBlend的双面渲染"><a href="#3、AlphaBlend的双面渲染" class="headerlink" title="3、AlphaBlend的双面渲染"></a>3、AlphaBlend的双面渲染</h3><p>相对于透明度测试，透明度混合更加复杂一点，这是因为一切混乱的源头“关闭深度写入”<br>我们采取以下做法：将渲染工作分为两个Pass</p>
<ul>
<li><p>Pass1</p>
</li>
<li><ul>
<li>只渲染背面（Cull Front）</li>
</ul>
</li>
<li><p>Pass2</p>
</li>
<li><ul>
<li>只渲染正面（Cull Back）</li>
</ul>
</li>
<li><p>由于Unity会顺序执行Subshader中的各个Pass，所以我们可以保证背面总是在正面被渲染之前渲染，来得到正确的深度渲染关系</p>
</li>
</ul>
<h1 id="2022-x2F-10-x2F-09"><a href="#2022-x2F-10-x2F-09" class="headerlink" title="2022&#x2F;10&#x2F;09"></a>2022&#x2F;10&#x2F;09</h1><h2 id="面剔除-1"><a href="#面剔除-1" class="headerlink" title="面剔除"></a>面剔除</h2><p>效果：穿进闭合物体后不会看到背面了。</p>
<p>例外：正反面都要显示的物体不能用面剔除（除非贴两层）。</p>
<ol>
<li>OpenGL在<strong>光栅化阶段</strong>（透视投影之后的点，依旧是按照vertex_buffer中的顺序组织的，次序不会发生变化）默认按照顶点的<strong>逆时针排列顺序认为这个面是正面</strong>，相对的，顺时针排列顺序则是背面，glEnable(GL_CULL_FACE);开启后，默认背面会被剔除；剔除的含义就是不会进行下一步的深度测试、模板测试、fs着色等操作。</li>
<li>当然，可以设置glCullFace(GL_FRONT);为剔除正面。</li>
<li>也可以设置glFrontFace(GL_CW);认为顺时针为正面，逆时针为背面。</li>
<li>定义顶点时针方向：假设从<strong>某一个视角</strong>去看这个物体，<strong>哪些面是正面？哪些面是背面？</strong>当然从任何一个视角去定义顺序都没问题，比如从物体的正&#x2F;侧面；因为如果一个面的正面是逆时针，那么它的背面一定是顺时针，因此，只要视角从这个面的正面移动到了它的背面，那么这个面此时的时针顺序一定会反向。</li>
</ol>
<h2 id="帧缓冲"><a href="#帧缓冲" class="headerlink" title="帧缓冲"></a>帧缓冲</h2><p>颜色缓冲+深度缓冲+模板缓冲&#x3D;帧缓冲(framebuffer)。此前的操作都是在默认帧缓冲的渲染缓冲上进行，可以自定义帧缓冲，从而实现后处理等操作。</p>
<p>先和其他对象一样，需要先创建一个帧缓冲对象FBO。一个完整的帧缓冲需要满足以下的条件，否则不能使用：</p>
<ul>
<li>附加至少一个缓冲（颜色、深度或模板缓冲）。</li>
<li>至少有一个颜色附件(Attachment)。</li>
<li>所有的附件都必须是完整的（保留了内存）。</li>
<li>每个缓冲都应该有相同的样本数（样本在抗锯齿中用到）。</li>
</ul>
<p>由于不是默认的帧缓冲，因此渲染指令并不会输出到窗口上，这种渲染到一个不同的帧缓冲叫做离屏渲染(Off-screen Rendering)。若要保证所有的渲染操作在主窗口中有视觉效果，需要再次激活默认帧缓冲：glBindFramebuffer(GL_FRAMEBUFFER, 0);</p>
<p>最后删除这个帧缓冲对象：glDeleteFramebuffers(1, &amp;fbo);</p>
<h3 id="完整性检测"><a href="#完整性检测" class="headerlink" title="完整性检测"></a>完整性检测</h3><p>最后，需要调用glCheckFramebufferStatus检查帧缓冲是否完整。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">glCheckFramebufferStatus</span>(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE)</span><br><span class="line">  <span class="comment">// 执行胜利的舞蹈</span></span><br></pre></td></tr></table></figure>

<h3 id="帧缓冲的附件"><a href="#帧缓冲的附件" class="headerlink" title="帧缓冲的附件"></a>帧缓冲的附件</h3><p>帧缓冲附件是帧缓冲的一个缓冲，类似一个图像。分为<strong>纹理</strong>和<strong>渲染缓冲</strong>两种类型。</p>
<p><strong>纹理：</strong></p>
<ol>
<li>所有的渲染指令将会写入到这个纹理中，渲染结果存储在一个图像中，可以在shader中方便使用。</li>
<li>纹理就和普通的图片纹理的创建一样，但是因为不会读取只会写入，因此glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 800, 600, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);维度为屏幕大小，最后纹理data是NULL。</li>
<li>然后将纹理附加到帧缓冲上。glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, 0);</li>
</ol>
<ul>
<li><code>target</code>：帧缓冲的目标（绘制、读取或者两者皆有）</li>
<li><code>attachment</code>：我们想要附加的附件类型。当前我们正在附加一个颜色附件。注意最后的<code>0</code>意味着我们可以附加多个颜色附件。我们将在之后的教程中提到。</li>
<li><code>textarget</code>：你希望附加的纹理类型</li>
<li><code>texture</code>：要附加的纹理本身</li>
<li><code>level</code>：多级渐远纹理的级别。我们将它保留为0。</li>
</ul>
<p>附件类型还可以是深度&#x2F;模板缓冲类型，同时对应的纹理的format以及internalformat要进行对应的改变为GL_DEPTH_COMPONENT&#x2F; GL_STENCIL_INDEX，指定深度&#x2F;模板缓冲的存储格式。</p>
<p>也可以将深度&#x2F;模板缓冲附加为一个单独的纹理，比如每32bit数值&#x3D;24bit depth + 8 bit stencil。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexImage2D</span>(</span><br><span class="line">  GL_TEXTURE_2D, <span class="number">0</span>, GL_DEPTH24_STENCIL8, <span class="number">800</span>, <span class="number">600</span>, <span class="number">0</span>, </span><br><span class="line">  GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8, <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D, texture, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><strong>渲染缓冲：</strong></p>
<ol>
<li>将数据存储为OpenGL原生的渲染格式，优化了离屏渲染。直接存储到它的缓冲中，不会做任何针对纹理的格式转换，速度快。</li>
<li>它是只写的，不可读，所以不能采样，但是可以用glReadPixels来读取当前绑定的<strong>帧缓冲</strong>中的特定区域像素。经常用于depth&#x2F; stencil，只写不读不采样，只用于深度&#x2F;模板测试。创建一个深度和模板渲染缓冲对象并附加到帧缓冲：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glRenderbufferStorage</span>(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, <span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glFramebufferRenderbuffer</span>(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo);</span><br></pre></td></tr></table></figure>

<h3 id="什么时候用纹理，什么时候用渲染缓冲？"><a href="#什么时候用纹理，什么时候用渲染缓冲？" class="headerlink" title="什么时候用纹理，什么时候用渲染缓冲？"></a>什么时候用纹理，什么时候用渲染缓冲？</h3><p>通常的规则是，如果你不需要从一个缓冲中<strong>采样</strong>数据，那么对这个缓冲使用渲染缓冲对象会是明智的选择。如果你需要从缓冲中采样颜色或深度值等数据，那么你应该选择纹理附件。性能方面它不会产生非常大的影响的。</p>
<p><strong>warning！</strong>这里我理解的<strong>采样</strong>是指，用户端如果需要对buffer进行访问，那么就要使用纹理；如果更底层的opengl内部实现对buffer进行访问，比如深度&#x2F;模板测试时对buffer中的值进行非用户层的访问判断，那么就用渲染缓冲。</p>
<p><img src="/images%5COpenGL%5Cframe_buffer_01.jpg" alt="frame_buffer_01"></p>
<p><img src="/images%5COpenGL%5Cframe_buffer_02.jpg" alt="frame_buffer_02"></p>
<h2 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h2><p>通过将pass one输出的texture的color进行一些变换，可以得到例如反向、灰度化、锐化、模糊、边缘检测等效果。</p>
<p>其中，锐化、模糊、边缘检测需要使用kernal核进行卷积得到处理后的效果。</p>
<p><img src="/images%5COpenGL%5Cframe_buffer_03.jpg" alt="frame_buffer_03"></p>
<h1 id="2022-x2F-10-x2F-18"><a href="#2022-x2F-10-x2F-18" class="headerlink" title="2022&#x2F;10&#x2F;18"></a>2022&#x2F;10&#x2F;18</h1><h2 id="立方体贴图"><a href="#立方体贴图" class="headerlink" title="立方体贴图"></a>立方体贴图</h2><p>将纹理映射在一个6面的立方体纹理对象上。</p>
<h3 id="天空盒"><a href="#天空盒" class="headerlink" title="天空盒"></a>天空盒</h3><p>我们希望天空盒是以玩家为中心的，这样不论玩家移动了多远，天空盒都不会变近，让玩家产生周围环境非常大的印象。然而，当前的观察矩阵会旋转、缩放和位移来变换天空盒的所有位置，所以当玩家移动的时候，立方体贴图也会移动！我们希望移除观察矩阵中的位移部分，让移动不会影响天空盒的位置向量。因此，为了避免camera的位移对天空盒造成影响，需要将4 * 4的view矩阵只取左上角的3 * 3部分，去掉w代表的位移部分（天空盒不会相对于camera位移，只发生相对于camera的旋转）。</p>
<p>同理，这个方法还被应用于着色时，输入vertex shader的<strong>法线</strong>进行model变换时的修正：[基础光照 - LearnOpenGL CN (learnopengl-cn.github.io)](<a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/02">https://learnopengl-cn.github.io/02</a> Lighting&#x2F;02 Basic Lighting&#x2F;)，简单来说，依旧是只取model矩阵的左上3 * 3的部分（或者法线的w改为0）；其次，如果有非等比的scale，还需要先取逆再转置（修正非等比缩放的问题）之后取3 * 3。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Normal = <span class="type">mat3</span>(<span class="built_in">transpose</span>(<span class="built_in">inverse</span>(model))) * aNormal;</span><br></pre></td></tr></table></figure>

<p>但是，<strong>最好不要在shader上计算矩阵的逆</strong>：矩阵求逆是一项对于着色器开销很大的运算，因为它必须在场景中的<strong>每一个顶点上进行</strong>，所以应该尽可能地避免在着色器中进行求逆运算。以学习为目的的话这样做还好，但是对于一个高效的应用来说，你最好先在CPU上计算出法线矩阵，再通过uniform把它传递给着色器（就像模型矩阵一样）。</p>
<p><strong>因为model对于一个obj而言是唯一固定的，所以它的逆也是唯一固定的，不需要在shader中去给每一个顶点都算一次。CPU传过来的值，就好像针对每个GPU单元的一个全局变量；shader中的计算就是每个GPU单元（每个顶点）都要进行的。</strong></p>
<p>因此，如果是对每个顶点都一样的值，直接从CPU传过来就行。如果是需要针对顶点的属性进行更改的，那么就传入GPU之后进行计算，比如着色等。</p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>目前：当<strong>禁止深度写入</strong>时，先绘制的物体总会被后绘制的物体掩盖。想要将天空盒绘制在所有的物体后面，那么就要禁止深度写入，并且第一个绘制天空盒。但是这种做法并不是非常高效，因此采用<strong>提前深度测试</strong>：最后渲染天空盒；因为天空盒只是一个1 ^ 3的立方体，因此如果直接使用它原本的深度值，可能会导致覆盖其他的物体，但是我们的目的是<strong>将天空盒置于所有物体的后方</strong>，因此，我们需要<strong>手动</strong>将天空盒的深度值修改为最大的深度值，即：透视除法之后的结果为1.0。</p>
<p>又因为<strong>透视除法</strong>是在顶点着色器运行之后执行的，值来源于gl_Position。因此，将z分量改为w，这样就能保证z &#x2F; w &#x3D; 1.0，永远为最大值1.0了。因此，最后渲染的天空盒会在可以通过深度测试的地方进行（也即没有物体的地方）。</p>
<p>我们还要改变一下深度函数，将它从默认的GL_LESS改为GL_LEQUAL。深<strong>度缓冲默认初始化时，将会填充上天空盒的1.0值</strong>，所以我们需要保证天空盒在值<strong>小于或等于深度缓冲</strong>而不是小于时通过深度测试。</p>
<h3 id="环境映射"><a href="#环境映射" class="headerlink" title="环境映射"></a>环境映射</h3><p>可以用立方体贴图给物体反射、折射等属性。</p>
<p>根据反射、折射（Snell’s Law）来计算光路，然后将反射、折射（弹射一次后）的光路作为对立方体采样的方向向量。类似光追中从摄像机出发反向求光路一样，把立方体贴图当做光源，光路弹射一次直接打到光源（立方体贴图），采样就类似与光源求交。</p>
<h4 id="动态环境贴图"><a href="#动态环境贴图" class="headerlink" title="动态环境贴图"></a>动态环境贴图</h4><p>意思是不止考虑天空盒这个立方体贴图，而是使用帧缓冲，对<strong>需要使用立方体贴图的物体</strong>进行预计算，<strong>生成一个为它所用的考虑了其他物体的立方体贴图存储在一个纹理对象中</strong>，然后对这个立方体贴图进行采样。</p>
<h2 id="exercise"><a href="#exercise" class="headerlink" title="exercise"></a>exercise</h2><p>一开始在model和mesh里加了reflection这类纹理，但是没啥必要，heightMap也可以用。</p>
<p>在vs中输入pos、normal、uv；fs中输入cameraPos、来自vs的世界坐标系下的Pos和Nomal，计算反射向量，然后对天空盒采样；同时加上对obj素贴图的采样，可以得到一个有底纹的光泽外壳的玩意儿，但是和LearnOpenGL的不一样，估计是要分区&amp;&amp;计算。</p>
<h1 id="2022-x2F-11-x2F-02"><a href="#2022-x2F-11-x2F-02" class="headerlink" title="2022&#x2F;11&#x2F;02"></a>2022&#x2F;11&#x2F;02</h1><h2 id="环境贴图"><a href="#环境贴图" class="headerlink" title="环境贴图"></a>环境贴图</h2><h3 id="实时渲染-vs-光追-vs-普通光源"><a href="#实时渲染-vs-光追-vs-普通光源" class="headerlink" title="实时渲染 vs. 光追 vs. 普通光源"></a>实时渲染 vs. 光追 vs. 普通光源</h3><p>在实时渲染中应用环境贴图，需要了解球谐函数（GAMES202），和光追的思路一样，先通过出射方向和着色点位置确定入射光方向，然后通过入射光方向对环境贴图进行采样，从而得到光照强度等信息，然后进行着色。</p>
<p>于是，和点光源（点光源的光照强度、位置等都是固定的一个值，只需要计算出入射方向就可以着色了）等简单光源相比，环境贴图需要多一步<strong>采样</strong>，但和光追相比，实时渲染中使用环境贴图时，光线的弹射只用发生1次；光追需要考虑非直接光照&#x2F;全局光照，所以如果没有弹射到光源的话，可能（取决于俄罗斯轮盘赌）不会停止。</p>
<h1 id="几何着色器"><a href="#几何着色器" class="headerlink" title="几何着色器"></a>几何着色器</h1><p>位于顶点着色器和片元着色器之间，用于增加顶点或者进行顶点变换。</p>
<p>也可用于法向量的可视化。</p>
<p>主要逻辑：</p>
<ol>
<li>在vertexShader中得到vertex在相机空间中的pos和normal；</li>
<li>在geometryShader中计算投影空间中的pos，并将pos向着normal位移之后再得到新的点；</li>
<li>最后将两个点组成的图元进行插值，然后在fragmentShader中着色。</li>
</ol>
<h1 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h1><p>将数据打包，一次性从CPU发送给GPU，提高渲染效率。</p>
<blockquote>
<p>实例化这项技术能够让我们使用一个渲染调用来绘制多个物体，来节省每次绘制物体时CPU -&gt; GPU的通信，它只需要一次即可。如果想使用实例化渲染，我们只需要将glDrawArrays和glDrawElements的渲染调用分别改为glDrawArraysInstanced和glDrawElementsInstanced就可以了。这些渲染函数的<strong>实例化</strong>版本需要一个额外的参数，叫做实例数量(Instance Count)，它能够设置我们需要渲染的实例个数。这样我们只需要将必须的数据发送到GPU一次，然后使用一次函数调用告诉GPU它应该如何绘制这些实例。GPU将会直接渲染这些实例，而不用不断地与CPU进行通信。</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">Moony</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2022/11/02/OpenGL/">http://example.com/2022/11/02/OpenGL/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OpenGL/">OpenGL</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/11/02/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Shader入门精要</div></div></a></div><div class="next-post pull-right"><a href="/2022/11/02/c-%E6%80%BB%E7%BB%93/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">c++总结</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Moony</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-number">1.</span> <span class="toc-text">环境配置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2022-x2F-06-x2F-17"><span class="toc-number">2.</span> <span class="toc-text">2022&#x2F;06&#x2F;17</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E7%BC%93%E5%86%B2-Double-Buffer"><span class="toc-number">2.1.</span> <span class="toc-text">双缓冲(Double Buffer)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%EF%BC%9A"><span class="toc-number">2.2.</span> <span class="toc-text">延迟渲染：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%EF%BC%9A%E4%BD%A0%E5%A5%BD%EF%BC%8C%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-number">2.3.</span> <span class="toc-text">入门：你好，三角形</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2022-x2F-09-x2F-16"><span class="toc-number">3.</span> <span class="toc-text">2022&#x2F;09&#x2F;16</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MingW"><span class="toc-number">3.1.</span> <span class="toc-text">MingW</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Visual-Studio-2019"><span class="toc-number">3.2.</span> <span class="toc-text">Visual Studio 2019</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#OpenGL%E5%92%8CDirectX%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.</span> <span class="toc-text">OpenGL和DirectX的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%B3%E4%B9%98%E8%BF%98%E6%98%AF%E5%B7%A6%E4%B9%98%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">右乘还是左乘？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%89%94%E9%99%A4"><span class="toc-number">4.2.</span> <span class="toc-text">面剔除</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2022-x2F-10-x2F-08"><span class="toc-number">5.</span> <span class="toc-text">2022&#x2F;10&#x2F;08</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95"><span class="toc-number">5.1.</span> <span class="toc-text">深度测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95"><span class="toc-number">5.2.</span> <span class="toc-text">模板测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%EF%BC%9Aalpha%E9%80%9A%E9%81%93%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">5.3.</span> <span class="toc-text">混合：alpha通道的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%850%EF%BC%9A"><span class="toc-number">5.4.</span> <span class="toc-text">补充0：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BD%95%E8%A6%81%E5%9C%A8%E6%B8%B2%E6%9F%93%E9%80%8F%E6%98%8E%E7%89%A9%E4%BD%93%E6%97%B6%E5%85%B3%E9%97%AD%E6%B7%B1%E5%BA%A6%E5%86%99%E5%85%A5%EF%BC%9F"><span class="toc-number">5.4.1.</span> <span class="toc-text">为何要在渲染透明物体时关闭深度写入？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%851%EF%BC%9A"><span class="toc-number">5.5.</span> <span class="toc-text">补充1：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%852%EF%BC%9A"><span class="toc-number">5.6.</span> <span class="toc-text">补充2：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8A%E9%80%8F%E6%98%8E%E7%89%A9%E4%BD%93%E5%92%8C%E4%B8%8D%E9%80%8F%E6%98%8E%E7%89%A9%E4%BD%93%E7%9A%84%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.6.1.</span> <span class="toc-text">半透明物体和不透明物体的渲染顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8A%E9%80%8F%E6%98%8E%E7%89%A9%E4%BD%93%E5%92%8C%E5%8D%8A%E9%80%8F%E6%98%8E%E7%89%A9%E4%BD%93%E7%9A%84%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.6.2.</span> <span class="toc-text">半透明物体和半透明物体的渲染顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PS-Blend%E5%85%AC%E5%BC%8F"><span class="toc-number">5.6.3.</span> <span class="toc-text">PS : Blend公式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%90%AFZWrite%E7%9A%84%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C"><span class="toc-number">5.6.4.</span> <span class="toc-text">开启ZWrite的透明效果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%80%8F%E6%98%8E%E6%B8%B2%E6%9F%93"><span class="toc-number">5.6.5.</span> <span class="toc-text">双向透明渲染</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%853%EF%BC%9A"><span class="toc-number">5.7.</span> <span class="toc-text">补充3：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E8%A8%80%EF%BC%9AVisibility%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%86%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.8.</span> <span class="toc-text">引言：Visibility可见性＆渲染顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%8F%E6%98%8E%E5%BA%A6%E6%B5%8B%E8%AF%95%EF%BC%88Alpha-Test-x2F-Cutout%EF%BC%89"><span class="toc-number">5.9.</span> <span class="toc-text">一、什么是透明度测试（Alpha Test&#x2F;Cutout）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">5.9.1.</span> <span class="toc-text">1、基本思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%85%B7%E4%BD%93%E6%93%8D%E4%BD%9C-x2F-%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.9.2.</span> <span class="toc-text">2、具体操作&#x2F;实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">5.9.3.</span> <span class="toc-text">3、总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%8F%E6%98%8E%E5%BA%A6%E6%B7%B7%E5%90%88%EF%BC%88Alpha-Blend%EF%BC%89"><span class="toc-number">5.10.</span> <span class="toc-text">二、什么是透明度混合（Alpha Blend）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-1"><span class="toc-number">5.10.1.</span> <span class="toc-text">1、基本思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.10.2.</span> <span class="toc-text">2、具体实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88AlphaBlend%E5%B9%B6%E6%B2%A1%E6%9C%89%E9%94%99%E8%AF%AF%E7%9A%84%E9%81%AE%E6%8C%A1%E5%85%B3%E7%B3%BB"><span class="toc-number">5.10.3.</span> <span class="toc-text">3、为什么AlphaBlend并没有错误的遮挡关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F%E5%BE%88%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-number">5.11.</span> <span class="toc-text">三、为什么渲染顺序很重要性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B1%EF%BC%9A%E5%8D%8A%E9%80%8F%E6%98%8E%E7%89%A9%E4%BD%93%E5%92%8C%E4%B8%8D%E9%80%8F%E6%98%8E%E7%89%A9%E4%BD%93"><span class="toc-number">5.11.1.</span> <span class="toc-text">例1：半透明物体和不透明物体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B2%EF%BC%9A%E5%8D%8A%E9%80%8F%E6%98%8E%E7%89%A9%E4%BD%93%E4%B9%8B%E9%97%B4"><span class="toc-number">5.11.2.</span> <span class="toc-text">例2：半透明物体之间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unity-Shader%E7%9A%84%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.11.3.</span> <span class="toc-text">Unity Shader的渲染顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%BC%80%E5%90%AF%E6%B7%B1%E5%BA%A6%E5%86%99%E5%85%A5%E7%9A%84%E5%8D%8A%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C%EF%BC%88Z-Prepass%EF%BC%89"><span class="toc-number">5.12.</span> <span class="toc-text">四、开启深度写入的半透明效果（Z-Prepass）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%80%8F%E6%98%8E%E5%BA%A6%E6%B7%B7%E5%90%88%E7%9A%84%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5"><span class="toc-number">5.12.1.</span> <span class="toc-text">1、透明度混合的特殊情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Pre-Z%EF%BC%88ZPrepass%EF%BC%89"><span class="toc-number">5.12.2.</span> <span class="toc-text">2、Pre-Z（ZPrepass）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81ShaderLab%E7%9A%84%E6%B7%B7%E5%90%88%E5%91%BD%E4%BB%A4%EF%BC%88%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">5.13.</span> <span class="toc-text">五、ShaderLab的混合命令（混合模式）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%B7%B7%E5%90%88%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">5.13.1.</span> <span class="toc-text">1、混合是如何实现的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%84%9F%E6%80%A7%E7%90%86%E8%A7%A3"><span class="toc-number">5.13.2.</span> <span class="toc-text">2、感性理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%B7%B7%E5%90%88%E7%AD%89%E5%BC%8F%E3%80%81%E6%B7%B7%E5%90%88%E5%8F%82%E6%95%B0"><span class="toc-number">5.13.3.</span> <span class="toc-text">3、混合等式、混合参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%B7%B7%E5%90%88%E6%93%8D%E4%BD%9C%E3%80%81%E5%85%B6%E4%BB%96%E5%8F%82%E8%80%83"><span class="toc-number">5.13.4.</span> <span class="toc-text">4、混合操作、其他参考</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%8F%8C%E9%9D%A2%E6%B8%B2%E6%9F%93%E7%9A%84%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C%EF%BC%88%E5%89%94%E9%99%A4%EF%BC%89"><span class="toc-number">5.14.</span> <span class="toc-text">六、双面渲染的透明效果（剔除）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%89%94%E9%99%A4%E6%8C%87%E4%BB%A4"><span class="toc-number">5.14.1.</span> <span class="toc-text">1、剔除指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81AlphaTest%E7%9A%84%E5%8F%8C%E9%9D%A2%E6%B8%B2%E6%9F%93"><span class="toc-number">5.14.2.</span> <span class="toc-text">2、AlphaTest的双面渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81AlphaBlend%E7%9A%84%E5%8F%8C%E9%9D%A2%E6%B8%B2%E6%9F%93"><span class="toc-number">5.14.3.</span> <span class="toc-text">3、AlphaBlend的双面渲染</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2022-x2F-10-x2F-09"><span class="toc-number">6.</span> <span class="toc-text">2022&#x2F;10&#x2F;09</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%89%94%E9%99%A4-1"><span class="toc-number">6.1.</span> <span class="toc-text">面剔除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A7%E7%BC%93%E5%86%B2"><span class="toc-number">6.2.</span> <span class="toc-text">帧缓冲</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E6%80%A7%E6%A3%80%E6%B5%8B"><span class="toc-number">6.2.1.</span> <span class="toc-text">完整性检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A7%E7%BC%93%E5%86%B2%E7%9A%84%E9%99%84%E4%BB%B6"><span class="toc-number">6.2.2.</span> <span class="toc-text">帧缓冲的附件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E7%BA%B9%E7%90%86%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E6%B8%B2%E6%9F%93%E7%BC%93%E5%86%B2%EF%BC%9F"><span class="toc-number">6.2.3.</span> <span class="toc-text">什么时候用纹理，什么时候用渲染缓冲？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E5%A4%84%E7%90%86"><span class="toc-number">6.3.</span> <span class="toc-text">后处理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2022-x2F-10-x2F-18"><span class="toc-number">7.</span> <span class="toc-text">2022&#x2F;10&#x2F;18</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%8B%E6%96%B9%E4%BD%93%E8%B4%B4%E5%9B%BE"><span class="toc-number">7.1.</span> <span class="toc-text">立方体贴图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A9%E7%A9%BA%E7%9B%92"><span class="toc-number">7.1.1.</span> <span class="toc-text">天空盒</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">7.1.1.1.</span> <span class="toc-text">优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84"><span class="toc-number">7.1.2.</span> <span class="toc-text">环境映射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%8E%AF%E5%A2%83%E8%B4%B4%E5%9B%BE"><span class="toc-number">7.1.2.1.</span> <span class="toc-text">动态环境贴图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exercise"><span class="toc-number">7.2.</span> <span class="toc-text">exercise</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2022-x2F-11-x2F-02"><span class="toc-number">8.</span> <span class="toc-text">2022&#x2F;11&#x2F;02</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E8%B4%B4%E5%9B%BE"><span class="toc-number">8.1.</span> <span class="toc-text">环境贴图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-vs-%E5%85%89%E8%BF%BD-vs-%E6%99%AE%E9%80%9A%E5%85%89%E6%BA%90"><span class="toc-number">8.1.1.</span> <span class="toc-text">实时渲染 vs. 光追 vs. 普通光源</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">9.</span> <span class="toc-text">几何着色器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">10.</span> <span class="toc-text">实例化</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/11/03/Unity/" title="Unity"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity"/></a><div class="content"><a class="title" href="/2022/11/03/Unity/" title="Unity">Unity</a><time datetime="2022-11-03T12:44:35.000Z" title="Created 2022-11-03 20:44:35">2022-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/02/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/" title="Shader入门精要"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Shader入门精要"/></a><div class="content"><a class="title" href="/2022/11/02/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/" title="Shader入门精要">Shader入门精要</a><time datetime="2022-11-02T11:22:23.000Z" title="Created 2022-11-02 19:22:23">2022-11-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/02/OpenGL/" title="OpenGL"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OpenGL"/></a><div class="content"><a class="title" href="/2022/11/02/OpenGL/" title="OpenGL">OpenGL</a><time datetime="2022-11-02T08:35:45.000Z" title="Created 2022-11-02 16:35:45">2022-11-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/02/c-%E6%80%BB%E7%BB%93/" title="c++总结"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="c++总结"/></a><div class="content"><a class="title" href="/2022/11/02/c-%E6%80%BB%E7%BB%93/" title="c++总结">c++总结</a><time datetime="2022-11-02T05:49:40.000Z" title="Created 2022-11-02 13:49:40">2022-11-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/02/Dx11/" title="Dx11"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Dx11"/></a><div class="content"><a class="title" href="/2022/11/02/Dx11/" title="Dx11">Dx11</a><time datetime="2022-11-02T05:02:20.000Z" title="Created 2022-11-02 13:02:20">2022-11-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Moony</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>