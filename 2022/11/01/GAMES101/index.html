<!DOCTYPE html>

<html lang="en">

<head>
    
    <title>GAMES101 - Hexo</title>
    <meta charset="UTF-8">
    <meta name="keywords" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
    
    

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <meta name="description" content="GAMES101Studies for GAMES101. Hw01向量绕任意轴旋转的简单推导 | Sulley图形学中有关旋转的一个问题是，一个（三维空间的）向量绕一个任意轴旋转若干角度后的角度是什么。本文简单进行推导，给出显式结果。 方法一：向量分解推导过程首先介绍一个最容易理解的方法——向量分解。假设要旋转的向量是p，要旋转的轴是n，是一个单位向量，要旋转的角度是θ。再设旋转后的轴是p′。">
<meta property="og:type" content="article">
<meta property="og:title" content="GAMES101">
<meta property="og:url" content="http://example.com/2022/11/01/GAMES101/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="GAMES101Studies for GAMES101. Hw01向量绕任意轴旋转的简单推导 | Sulley图形学中有关旋转的一个问题是，一个（三维空间的）向量绕一个任意轴旋转若干角度后的角度是什么。本文简单进行推导，给出显式结果。 方法一：向量分解推导过程首先介绍一个最容易理解的方法——向量分解。假设要旋转的向量是p，要旋转的轴是n，是一个单位向量，要旋转的角度是θ。再设旋转后的轴是p′。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://sulley.cc/images/arbitrary_rotation/1.png">
<meta property="og:image" content="http://example.com/images/GAMES101/MSAA%E9%BB%91%E7%BA%BF_class7.png">
<meta property="og:image" content="http://example.com/images/GAMES101/MSAA%E5%8E%BB%E6%8E%89%E9%BB%91%E7%BA%BF_class9.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210525152530754.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTkyODc5NA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210525152530802.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTkyODc5NA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="http://example.com/images/GAMES101/output_normal.png">
<meta property="og:image" content="http://example.com/images/GAMES101/output_texture.png">
<meta property="og:image" content="http://example.com/images/GAMES101/output_phong.png">
<meta property="og:image" content="http://example.com/images/GAMES101/output_bump.png">
<meta property="og:image" content="http://example.com/images/GAMES101/output_displacement.png">
<meta property="og:image" content="http://example.com/images/GAMES101/output_bump_vs_displacement.png">
<meta property="og:image" content="http://example.com/images/GAMES101/output_small_texure_not_bilinear.png">
<meta property="og:image" content="http://example.com/images/GAMES101/output_small_texure_bilinear.png">
<meta property="og:image" content="http://example.com/images/GAMES101/output_tiny_texure_not_bilinear.png">
<meta property="og:image" content="http://example.com/images/GAMES101/output_tiny_texure_bilinear.png">
<meta property="og:image" content="http://example.com/images/GAMES101/output_bunny_normal.png">
<meta property="og:image" content="http://example.com/images/GAMES101/output_bunny_phong_eye_pos_shading_2.png">
<meta property="og:image" content="http://example.com/images/GAMES101/output_bunny_phong_eye_pos_shading_10.png">
<meta property="og:image" content="http://example.com/images/GAMES101/output_bunny_normal_back.png">
<meta property="og:image" content="http://example.com/images/GAMES101/output_rock_normal.png">
<meta property="og:image" content="http://example.com/images/GAMES101/output_rock_phong.png">
<meta property="og:image" content="http://example.com/images/GAMES101/output_rock_texture.png">
<meta property="og:image" content="http://example.com/images/GAMES101/output_cube_normal.png">
<meta property="og:image" content="http://example.com/images/GAMES101/output_cube_phong.png">
<meta property="og:image" content="http://example.com/images/GAMES101/output_cube_texture.png">
<meta property="og:image" content="http://example.com/images/GAMES101/output_cube_texture_1.png">
<meta property="og:image" content="http://example.com/images/GAMES101/output_crate_normal.png">
<meta property="og:image" content="http://example.com/images/GAMES101/output_crate_phong.png">
<meta property="og:image" content="http://example.com/images/GAMES101/output_crate_texture.png">
<meta property="og:image" content="http://example.com/images/GAMES101/output_04.png">
<meta property="og:image" content="http://example.com/images/GAMES101/my_bezier_curve_antialiasing.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210315153608594.png#pic_center">
<meta property="og:image" content="http://example.com/images/GAMES101/output_05.png">
<meta property="og:image" content="http://example.com/images/GAMES101/RunTimeBVH.png">
<meta property="og:image" content="http://example.com/images/GAMES101/RunTimeSAH.png">
<meta property="og:image" content="http://example.com/images/GAMES101/output_BVH.png">
<meta property="og:image" content="http://example.com/images/GAMES101/t_wrong.png">
<meta property="og:image" content="http://example.com/images/GAMES101/without_static.png">
<meta property="og:image" content="http://example.com/images/GAMES101/with_static.png">
<meta property="og:image" content="http://example.com/images/GAMES101/without_MSAA.png">
<meta property="og:image" content="http://example.com/images/GAMES101/specular_wrong.png">
<meta property="og:image" content="http://example.com/images/GAMES101/BRDF_1.jpg">
<meta property="og:image" content="http://example.com/images/GAMES101/BRDF_2.jpg">
<meta property="og:image" content="http://example.com/images/GAMES101/specular.png">
<meta property="og:image" content="http://example.com/images/GAMES101/MSAA.png">
<meta property="og:image" content="http://example.com/images/GAMES101/specular_ggx.png">
<meta property="article:published_time" content="2022-11-01T13:13:51.000Z">
<meta property="article:modified_time" content="2022-11-01T13:49:10.369Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="图形学 GAMES101作业">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sulley.cc/images/arbitrary_rotation/1.png">
    
<link rel="stylesheet" href="/lib/fancybox/fancybox.css">
<link rel="stylesheet" href="/lib/justifiedGallery/justifiedGallery.min.css">
<link rel="stylesheet" href="/lib/mdui_043tiny/mdui.css">


    <link rel="stylesheet" href="/lib/iconfont/iconfont.css?v=1667310560019">
    
    <link rel="stylesheet" href="/css/style.css?v=1667310560019">
    
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="mdui-drawer-body-left">
    
    <div id="nexmoe-background">
        <div class="nexmoe-bg" style="background-image: url(https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg)"></div>
        <div class="mdui-appbar mdui-shadow-0">
            <div class="mdui-toolbar">
                <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
                <div class="mdui-toolbar-spacer"></div>
                <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
                <a href="/" title="John Doe" class="mdui-btn mdui-btn-icon"><img src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/avatar.png" alt="John Doe"></a>
            </div>
        </div>
    </div>
    <div id="nexmoe-header">
        <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="John Doe">
            <img src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/avatar.png" alt="John Doe" alt="John Doe">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>Articles</span>2</div>
        <div><span>Tags</span>1</div>
        <div><span>Categories</span>0</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/about.html" title="关于博客">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/PY.html" title="我的朋友">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的朋友
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
         
            <form id="search_form" action_e="https://cn.bing.com/search?q=site:nexmoe.com" onsubmit="return search();">
                <label><input id="search_value" name="q" type="search" placeholder="Search"></label>
            </form>
         
    </div>
</div>
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://jq.qq.com/?_wv=1027&k=5CfKHun" target="_blank" mdui-tooltip="{content: 'QQ群'}" style="color: rgb(249, 174, 8);background-color: rgba(249, 174, 8, .1);">
            <i class="nexmoefont icon-QQ"></i>
        </a><a class="mdui-ripple" href="https://space.bilibili.com/20238211" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/nexmoe/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
    
    

    
    
  <div class="nexmoe-widget-wrap">
    <div id="randomtagcloud" class="nexmoe-widget tagcloud nexmoe-rainbow">
      <a href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6-GAMES101%E4%BD%9C%E4%B8%9A/" style="font-size: 10px;">图形学 GAMES101作业</a>
    </div>
    
  </div>

    
    <!-- 一言 -->

  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">
      Hitokoto
    </h3>
    <div class="nexmoe-widget">
      <ul class="hitokoto-box">
        <li id="hitokoto_text_parent" class="hitokoto-text" hitokotoCategory="">
          <a href="#" id="hitokoto_text">
            
          </a>
          <a href="#" id="hitokoto_error_text" style="display: none;">
            
          </a>
        </li>
      </ul>
    </div>
  </div>

  <script>
    let hitokotoText = document.getElementById('hitokoto_text')
    let hitokotoErroText = document.getElementById('hitokoto_error_text')
    let hitokotoCategory = document.getElementById('hitokoto_text_parent').getAttribute('hitokotoCategory')
    window.onload = function () {
      let url = 'https://v1.hitokoto.cn'
      if (hitokotoCategory) {
        url += '?c=' + hitokotoCategory
      }
      fetch(url)
        .then(response => response.json())
        .then(data => {
          hitokotoText.innerText = "「 " + data.hitokoto + " 」 from " + data.from
          hitokotoText.href = 'https://hitokoto.cn/?uuid=' + data.uuid
        })
        .catch((reason) => {
          console.error(11, reason)
          hitokotoText.style.display = 'none'
          hitokotoErroText.style.display = 'block'
        })
    }
  </script>
  
    
</aside>
    <div class="nexmoe-copyright">
        &copy; 2022 John Doe
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        <br><a target="_blank" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"><img src="https://i.dawnlab.me/c0268c1e6cfd0863d6ba35be1575941a.png" width="150px"></a><script data-ad-client="ca-pub-2058306854838448" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    </div>
</div><!-- .nexmoe-drawer -->
    </div>
    <div id="nexmoe-content">
        <div class="nexmoe-primary">
            <div class="nexmoe-post">

  <article>
      
          <div class="nexmoe-post-cover" style="padding-bottom: 66.66666666666666%;"> 
              <img data-fancybox="gallery" src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg" alt="GAMES101" loading="lazy">
              <h1>GAMES101</h1>
          </div>
      
      
      <div class="nexmoe-post-meta nexmoe-rainbow" style="margin:10px 0!important;">
    <a><i class="nexmoefont icon-calendar-fill"></i>2022年11月01日</a>
</div>

      <div class="nexmoe-post-meta nexmoe-rainbow" style="margin:10px 0!important;">
    
        <a><i class="nexmoefont icon-areachart"></i>约12.2k字</a>
        <a><i class="nexmoefont icon-time-circle-fill"></i>预计需要57分钟</a>
    
</div>

      <h1 id="GAMES101"><a href="#GAMES101" class="headerlink" title="GAMES101"></a>GAMES101</h1><p>Studies for GAMES101.</p>
<h1 id="Hw01"><a href="#Hw01" class="headerlink" title="Hw01"></a>Hw01</h1><h2 id="向量绕任意轴旋转的简单推导-Sulley"><a href="#向量绕任意轴旋转的简单推导-Sulley" class="headerlink" title="向量绕任意轴旋转的简单推导 | Sulley"></a><a target="_blank" rel="noopener" href="https://sulley.cc/2021/06/07/%E5%90%91%E9%87%8F%E7%BB%95%E4%BB%BB%E6%84%8F%E8%BD%B4%E6%97%8B%E8%BD%AC%E7%9A%84%E7%AE%80%E5%8D%95%E6%8E%A8%E5%AF%BC/">向量绕任意轴旋转的简单推导 | Sulley</a></h2><p>图形学中有关旋转的一个问题是，一个（三维空间的）向量绕一个任意轴旋转若干角度后的角度是什么。本文简单进行推导，给出显式结果。</p>
<h2 id="方法一：向量分解"><a href="#方法一：向量分解" class="headerlink" title="方法一：向量分解"></a>方法一：向量分解</h2><h3 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h3><p>首先介绍一个最容易理解的方法——向量分解。假设要旋转的向量是p，要旋转的轴是n，是一个单位向量，要旋转的角度是θ。再设旋转后的轴是p′。</p>
<p>现在我们把p分解为两个向量，一个平行于n，另一个垂直于n，即：p&#x3D;p⊥+p∥容易知道，平行于n的分向量p∥就是p在n上的投影（推导过程略）：p∥&#x3D;(n⋅p)n从而就能得到p⊥：p⊥&#x3D;p−p∥同样地可以将旋转后的向量分解：p′&#x3D;p⊥′+p∥′显然，旋转后的向量对应的平行分量p∥′是不变的：p∥′&#x3D;p∥这里的关键在于求垂直分量p⊥′。</p>
<p><a target="_blank" rel="noopener" href="https://sulley.cc/images/arbitrary_rotation/1.png"><img data-fancybox="gallery" src="https://sulley.cc/images/arbitrary_rotation/1.png" alt="将向量分解为一个平行向量和一个垂直向量" data-caption="将向量分解为一个平行向量和一个垂直向量" loading="lazy"></a></p>
<p><em>将向量分解为一个平行向量和一个垂直向量</em></p>
<p>根据已知的旋转轴n，我们就知道它对应的平面V，而向量p与p′的垂直分量就在该平面内。该平面的维度是2，因此只需要找到两个基向量，就可以通过这两个基向量的线性组合表示该平面的任意向量。</p>
<p>其中一个基向量我们已经找到了，就是p⊥，而另一个我们可以通过n与p⊥的叉乘实现，得到的向量与n和p⊥垂直，且在平面V内。且注意到：n×p⊥&#x3D;n×(p−p∥)&#x3D;n×p−n×p∥&#x3D;n×p并且有：‖n×p‖&#x3D;‖n×p⊥‖&#x3D;‖n‖⋅‖p⊥‖⋅sin⁡(π&#x2F;2)&#x3D;‖p⊥‖进而我们能导出旋转后的垂直分量p⊥′：p⊥′&#x3D;cos⁡(θ)‖p⊥‖⋅p⊥‖p⊥‖+sin⁡(θ)‖p⊥‖⋅n×p‖n×p‖&#x3D;cos⁡(θ)p⊥+sin⁡(θ)(n×p)最后，我们得到旋转后的向量p′：</p>
<p>p′&#x3D;p⊥′+p∥′&#x3D;cos⁡(θ)p⊥+sin⁡(θ)(n×p)+p∥&#x3D;cos⁡(θ)(p−p∥)+p∥+sin⁡(θ)(n×p)&#x3D;cos⁡(θ)p+(1−cos⁡(θ))(n⋅p)n+sin⁡(θ)(n×p)</p>
<p>搞定！</p>
<h3 id="矩阵形式"><a href="#矩阵形式" class="headerlink" title="矩阵形式"></a>矩阵形式</h3><p>我们知道向量的叉乘可以表示为：n×p&#x3D;[0−nznynz0−nx−nynx0]p&#x3D;Np注意到，矩阵N有如下的性质：N(Np)&#x3D;N2p&#x3D;n×(n×p)所以我们可以把旋转公式写成下述形式：p′&#x3D;p+(1−cos⁡(θ))N2p+sin⁡(θ)Np&#x3D;Rp其中R&#x3D;I+sin⁡(θ)N+(1−cos⁡(θ))N2。上面的等式需要注意到(n⋅p)n&#x3D;p+N2p。</p>
<p>所以，使用Rodrigues’旋转公式，只需要首先令N&#x3D;[0−nznynz0−nx−nynx0]，然后再计算R&#x3D;I+sin⁡(θ)N+(1−cos⁡(θ))N2，就能得到旋转后的向量为p′&#x3D;Rp。</p>
<h2 id="方法二：坐标轴对齐"><a href="#方法二：坐标轴对齐" class="headerlink" title="方法二：坐标轴对齐"></a>方法二：坐标轴对齐</h2><p>既然直接绕着任意轴旋转比较困难，那为啥不先进行整个空间的旋转，把旋转轴旋转为坐标轴，这样就能把向量绕任意轴旋转转化为向量绕标准坐标轴旋转。这就是我们非常熟悉的问题了。</p>
<p>假定我们考虑的是三维空间的旋转（对更高维的情况容易推论），即标准坐标系为x&#x3D;(1,0,0),y&#x3D;(0,1,0),z&#x3D;(0,0,1)。我们有旋转轴n,‖n‖&#x3D;1和待旋转向量p。</p>
<p>首先，我们构建一个坐标系u,v,w，该坐标系的一个轴就是n，我们利用叉乘实现：</p>
<p>u&#x3D;n,v&#x3D;n×p‖n×p‖,w&#x3D;n×v</p>
<p>现在，我们要把坐标轴u,v,w分别旋转到坐标轴x,y,z的位置，这可以用下面的旋转矩阵实现：</p>
<p>Q&#x3D;[uvw]&#x3D;[xuyuzuxvyvzvxwywzw]</p>
<p>很容易验证：x&#x3D;Qu,y&#x3D;Qv,z&#x3D;Qw，从而就有I&#x3D;QQ⊤&#x3D;Q⊤Q，这就验证了Q是正交的。</p>
<p>现在，原来的向量p就变成了Qp，原来绕n旋转（也就是绕u旋转）就变成了绕x旋转，而我们知道绕x轴旋转θ的旋转矩阵是：T&#x3D;[1000cos⁡(θ)−sin⁡(θ)0sin⁡(θ)cos⁡(θ)]因此，旋转后的向量就是TQp。现在，只需要把旋转后的向量再旋转回原来的位置就好了，我们只需要再乘以Q的逆即可。由于Q是正交的，所以有Q−1&#x3D;Q⊤。把上面的结果合起来，就能得到最终的结果是：p′&#x3D;Q⊤TQp</p>
<h3 id="检验"><a href="#检验" class="headerlink" title="检验"></a>检验</h3><p>现在我们用代码来检验一下上述三种方法是否能得到同样的结果，以及它们的运算效率如何。比较的方法包括： 1. 向量分解-向量形式 2. 向量分解-矩阵形式 3. 对标轴对齐</p>
<p>程序在虚拟机上运行，RAM为4G，硬盘20G，处理器为2个Intel Core i5-10400F CPU @ 2.90GHz。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;eigen3/Eigen/Eigen&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.1415926</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rotation using vector decomposation - the vector form</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DecomposeVector</span><span class="params">(<span class="type">const</span> Eigen::Vector3f &amp;n, <span class="type">const</span> Eigen::Vector3f &amp;p, <span class="type">float</span> angle)</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> rotationAngle = angle / <span class="number">180.0</span> * PI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> startTime = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">Eigen::Vector3f rotatedVector = <span class="built_in">cos</span>(rotationAngle) * p </span><br><span class="line">                                + (<span class="number">1</span> - <span class="built_in">cos</span>(rotationAngle)) * (n.<span class="built_in">dot</span>(p)) * n </span><br><span class="line">                                + <span class="built_in">sin</span>(rotationAngle) * (n.<span class="built_in">cross</span>(p));</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> endTime = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="type">double</span> deltaTime = std::chrono::<span class="built_in">duration</span>&lt;<span class="type">double</span>, std::milli&gt;(endTime-startTime).<span class="built_in">count</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Method: vector decomposition - the vector form. The rotated vector p&#x27; is (&quot;</span> </span><br><span class="line">     &lt;&lt; <span class="built_in">rotatedVector</span>(<span class="number">0</span>) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">rotatedVector</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">rotatedVector</span>(<span class="number">2</span>)</span><br><span class="line">     &lt;&lt; <span class="string">&quot;). The time used is &quot;</span> &lt;&lt; deltaTime &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rotation using vector decomposation - the matrix form</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DecomposeMatrix</span><span class="params">(<span class="type">const</span> Eigen::Vector3f &amp;n, <span class="type">const</span> Eigen::Vector3f &amp;p, <span class="type">float</span> angle)</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> rotationAngle = angle / <span class="number">180.0</span> * PI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> startTime = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">Eigen::Matrix3f N = Eigen::Matrix3f::<span class="built_in">Identity</span>();</span><br><span class="line">N &lt;&lt; <span class="number">0</span>, -<span class="built_in">n</span>(<span class="number">2</span>), <span class="built_in">n</span>(<span class="number">1</span>),</span><br><span class="line">     <span class="built_in">n</span>(<span class="number">2</span>), <span class="number">0</span>, -<span class="built_in">n</span>(<span class="number">0</span>),</span><br><span class="line">     -<span class="built_in">n</span>(<span class="number">1</span>), <span class="built_in">n</span>(<span class="number">0</span>), <span class="number">0</span>;</span><br><span class="line">Eigen::Matrix3f R = Eigen::Matrix3f::<span class="built_in">Identity</span>() + <span class="built_in">sin</span>(rotationAngle) * N + (<span class="number">1</span> - <span class="built_in">cos</span>(rotationAngle)) * N * N;</span><br><span class="line">Eigen::Vector3f rotatedVector = R * p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> endTime = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="type">double</span> deltaTime = std::chrono::<span class="built_in">duration</span>&lt;<span class="type">double</span>, std::milli&gt;(endTime-startTime).<span class="built_in">count</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Method: vector decomposition - the matrix form. The rotated vector p&#x27; is (&quot;</span> </span><br><span class="line">     &lt;&lt; <span class="built_in">rotatedVector</span>(<span class="number">0</span>) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">rotatedVector</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">rotatedVector</span>(<span class="number">2</span>)</span><br><span class="line">     &lt;&lt; <span class="string">&quot;). The time used is &quot;</span> &lt;&lt; deltaTime &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rotation using axis coordination</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AxisCoordination</span><span class="params">(<span class="type">const</span> Eigen::Vector3f &amp;n, <span class="type">const</span> Eigen::Vector3f &amp;p, <span class="type">float</span> angle)</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> rotationAngle = angle / <span class="number">180.0</span> * PI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> startTime = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">Eigen::Vector3f crossed = n.<span class="built_in">cross</span>(p);</span><br><span class="line">Eigen::Vector3f u = n;</span><br><span class="line">Eigen::Vector3f v = crossed / crossed.<span class="built_in">norm</span>();</span><br><span class="line">Eigen::Vector3f w = n.<span class="built_in">cross</span>(v);</span><br><span class="line">Eigen::Matrix3f Q = Eigen::Matrix3f::<span class="built_in">Identity</span>(), T = Eigen::Matrix3f::<span class="built_in">Identity</span>();</span><br><span class="line">Q.<span class="built_in">row</span>(<span class="number">0</span>) = u;</span><br><span class="line">Q.<span class="built_in">row</span>(<span class="number">1</span>) = v;</span><br><span class="line">Q.<span class="built_in">row</span>(<span class="number">2</span>) = w;</span><br><span class="line">T &lt;&lt; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">     <span class="number">0</span>, <span class="built_in">cos</span>(rotationAngle), -<span class="built_in">sin</span>(rotationAngle),</span><br><span class="line">     <span class="number">0</span>, <span class="built_in">sin</span>(rotationAngle), <span class="built_in">cos</span>(rotationAngle);</span><br><span class="line">Eigen::Vector3f rotatedVector = Q.<span class="built_in">transpose</span>() * T * Q * p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> endTime = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="type">double</span> deltaTime = std::chrono::<span class="built_in">duration</span>&lt;<span class="type">double</span>, std::milli&gt;(endTime-startTime).<span class="built_in">count</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Method: axis coordination. The rotated vector p&#x27; is (&quot;</span> </span><br><span class="line">     &lt;&lt; <span class="built_in">rotatedVector</span>(<span class="number">0</span>) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">rotatedVector</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">rotatedVector</span>(<span class="number">2</span>)</span><br><span class="line">     &lt;&lt; <span class="string">&quot;). The time used is &quot;</span> &lt;&lt; deltaTime &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> angle = <span class="number">60</span>;</span><br><span class="line">    <span class="function">Eigen::Vector3f <span class="title">p</span><span class="params">(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Eigen::Vector3f <span class="title">n</span><span class="params">(<span class="number">2.0</span>, <span class="number">8.6</span>, <span class="number">-3.1</span>)</span></span>;</span><br><span class="line">    n.<span class="built_in">normalize</span>(); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// execute functions</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The vector p is (&quot;</span> &lt;&lt; <span class="built_in">p</span>(<span class="number">0</span>) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">p</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">p</span>(<span class="number">2</span>) &lt;&lt; <span class="string">&quot;). &quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;The rotation axis n is (&quot;</span> &lt;&lt; <span class="built_in">n</span>(<span class="number">0</span>) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">n</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">n</span>(<span class="number">2</span>) &lt;&lt; <span class="string">&quot;). &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">DecomposeVector</span>(n, p, angle);</span><br><span class="line">    <span class="built_in">DecomposeMatrix</span>(n, p, angle);</span><br><span class="line">    <span class="built_in">AxisCoordination</span>(n, p, angle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">The vector p <span class="title">is</span> <span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span>. The rotation axis n <span class="title">is</span> <span class="params">(<span class="number">0.213724</span>,<span class="number">0.919011</span>,<span class="number">-0.331271</span>)</span>. </span></span><br><span class="line"><span class="function">Method: vector decomposition - the vector form. The rotated vector p<span class="string">&#x27; is (3.57449,0.643966,0.899062). The time used is 0.016354</span></span></span><br><span class="line"><span class="string"><span class="function">Method: vector decomposition - the matrix form. The rotated vector p&#x27;</span> is (<span class="number">3.57449</span>,<span class="number">0.643966</span>,<span class="number">0.899062</span>). The time used is <span class="number">0.016642</span></span></span><br><span class="line"><span class="function">Method: axis coordination. The rotated vector p<span class="string">&#x27; is (3.57449,0.643966,0.899062). The time used is 0.021062</span></span></span><br></pre></td></tr></table></figure>

<p>再多试几组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">The vector p <span class="title">is</span> <span class="params">(<span class="number">1</span>,<span class="number">-654.1</span>,<span class="number">12.88</span>)</span>. The rotation axis n <span class="title">is</span> <span class="params">(<span class="number">0.995044</span>,<span class="number">0.0136933</span>,<span class="number">-0.0984901</span>)</span>. </span></span><br><span class="line"><span class="function">Method: vector decomposition - the vector form. The rotated vector p<span class="string">&#x27; is (-59.7309,-338.298,-556.777). The time used is 0.015503</span></span></span><br><span class="line"><span class="string"><span class="function">Method: vector decomposition - the matrix form. The rotated vector p&#x27;</span> is (<span class="number">-59.7309</span>,<span class="number">-338.298</span>,<span class="number">-556.777</span>). The time used is <span class="number">0.015297</span></span></span><br><span class="line"><span class="function">Method: axis coordination. The rotated vector p<span class="string">&#x27; is (-59.7309,-338.298,-556.777). The time used is 0.021547</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">The vector p <span class="title">is</span> <span class="params">(<span class="number">32.5</span>,<span class="number">45.1</span>,<span class="number">-2.2</span>)</span>. The rotation axis n <span class="title">is</span> <span class="params">(<span class="number">0.57735</span>,<span class="number">0.57735</span>,<span class="number">0.57735</span>)</span>. </span></span><br><span class="line"><span class="function">Method: vector decomposition - the vector form. The rotated vector p<span class="string">&#x27; is (5.16667,52.4667,17.7667). The time used is 0.015558</span></span></span><br><span class="line"><span class="string"><span class="function">Method: vector decomposition - the matrix form. The rotated vector p&#x27;</span> is (<span class="number">5.16667</span>,<span class="number">52.4667</span>,<span class="number">17.7667</span>). The time used is <span class="number">0.015215</span></span></span><br><span class="line"><span class="function">Method: axis coordination. The rotated vector p<span class="string">&#x27; is (5.16667,52.4667,17.7667). The time used is 0.020841</span></span></span><br><span class="line"><span class="string"><span class="function">The vector p is (666,0,0). The rotation axis n is (0,0,1). </span></span></span><br><span class="line"><span class="string"><span class="function">Method: vector decomposition - the vector form. The rotated vector p&#x27;</span> is (<span class="number">1.78454e-05</span>,<span class="number">666</span>,<span class="number">0</span>). The time used is <span class="number">0.01517</span></span></span><br><span class="line"><span class="function">Method: vector decomposition - the matrix form. The rotated vector p<span class="string">&#x27; is (0,666,0). The time used is 0.015402</span></span></span><br><span class="line"><span class="string"><span class="function">Method: axis coordination. The rotated vector p&#x27;</span> is (<span class="number">1.78454e-05</span>,<span class="number">666</span>,<span class="number">0</span>). The time used is <span class="number">0.020898</span></span></span><br></pre></td></tr></table></figure>

<p>最后一组出现了精度问题，所以代码中还应该加入判断</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(value - <span class="built_in">round</span>(value)) &lt; epsilon)</span><br><span class="line">     value = <span class="built_in">round</span>(value);</span><br></pre></td></tr></table></figure>



<p>从上面的例子来看，<strong>向量分解-向量形式</strong>与<strong>向量分解-矩阵形式</strong>运行效率是一致的，而<strong>坐标轴对齐</strong>的效率较低，这主要是由计算三次矩阵乘法导致的。</p>
<p>上面这个推导公式有问题，参考了下面的公式，更通用。</p>
<p><a target="_blank" rel="noopener" href="http://betheme.net/news/txtlist_i213886v.html">【GAMES101】作业1（提高）与框架理解 (betheme.net)</a></p>
<h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>1， Eigen中的矩阵和向量运算不会自动适应行列数，需要在编程的时候保证参与运算的矩阵和向量行列数可以进行运算<br>2，头文件&lt;Eigen&#x2F;Core&gt; 中包含【+，-，<em>，&#x2F;，+&#x3D;，-&#x3D;，</em>&#x3D;，.transpose()…sum()，.prod()，.mean()，minCoeff()，.maxCoeff，.trace()】等运算符<br>3，头文件&lt;Eigen&#x2F;Dense&gt; 中包含【.dot()，.cross()，adjoint()】等运算符<br>4，以下讨论的符号约定(假设满足运算的行列数要求)<br>矩阵：a，b<br>向量：u，v<br>常数：c</p>
<h3 id="1，【-，-x3D-，-，-x3D-】"><a href="#1，【-，-x3D-，-，-x3D-】" class="headerlink" title="1，【+，+&#x3D;，-，-&#x3D;】"></a>1，【+，+&#x3D;，-，-&#x3D;】</h3><p>适用于尺寸相同的矩阵之间、尺寸相同的向量之间的对应元素相加减</p>
<h3 id="2，【，-x3D-】"><a href="#2，【，-x3D-】" class="headerlink" title="2，【，&#x3D;】"></a>2，【<em>，</em>&#x3D;】</h3><p>1，用于矩阵与矩阵：尺寸合适的矩阵的一般矩阵乘法。此时，向量可以看成是矩阵<br>2，用于矩阵与标量：矩阵与标量的一般乘法，矩阵每个元素与标量相乘。此时，向量可以看成是矩阵</p>
<h3 id="3，【-transpose-】"><a href="#3，【-transpose-】" class="headerlink" title="3，【.transpose()】"></a>3，【.transpose()】</h3><p>返回矩阵的转置。此时，向量可以看成是矩阵</p>
<h3 id="4，【-dot-，-cross-，-adjoint-】"><a href="#4，【-dot-，-cross-，-adjoint-】" class="headerlink" title="4，【.dot()，.cross()，.adjoint()】"></a>4，【.dot()，.cross()，.adjoint()】</h3><p>只用于向量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">u.<span class="built_in">dot</span>(v):u和v的点乘，即对应元素乘积的和，返回一个标量。与v.<span class="built_in">dot</span>(u)，u.<span class="built_in">transpose</span>()*v，v.<span class="built_in">transpose</span>()*u相同。</span><br><span class="line"></span><br><span class="line">u.<span class="built_in">cross</span>(v):u和v的叉积，返回一个向量。与v.<span class="built_in">cross</span>(u)相差一个负号。</span><br><span class="line"></span><br><span class="line">u.<span class="built_in">adjoint</span>():返回u的共轭向量，若u为实向量，则返回结果与u相同。</span><br></pre></td></tr></table></figure>

<h3 id="5，针对矩阵元素进行的操作【-sum-，-prod-，-mean-，minCoeff-，-maxCoeff，-trace-】"><a href="#5，针对矩阵元素进行的操作【-sum-，-prod-，-mean-，minCoeff-，-maxCoeff，-trace-】" class="headerlink" title="5，针对矩阵元素进行的操作【.sum()，.prod()，.mean()，minCoeff()，.maxCoeff，.trace()】"></a>5，针对矩阵元素进行的操作【.sum()，.prod()，.mean()，minCoeff()，.maxCoeff，.trace()】</h3><p>本部分所有操作都可对矩阵和向量进行，将向量看做矩阵即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="built_in">sum</span>()：		返回矩阵a中所有元素的和</span><br><span class="line">a.<span class="built_in">prod</span>()：		返回矩阵a中所有元素的积</span><br><span class="line">a.<span class="built_in">mean</span>()：		返回矩阵a中所有有元素的平均值</span><br><span class="line">a.<span class="built_in">trace</span>():		返回矩阵的迹，即返回主对角线上元素的和。如果不是方阵或者为向量，仍返回对角线元素的和。</span><br><span class="line">a.<span class="built_in">minCoeff</span>()：	返回矩阵中最小的元素</span><br><span class="line">a.<span class="built_in">maxCoeff</span>()：	返回矩阵中最大的元素</span><br><span class="line"></span><br><span class="line">另外，对于.<span class="built_in">minCoeff</span>()，.<span class="built_in">maxCoeff</span>()，有以下用法：</span><br><span class="line"><span class="type">int</span> i,j;<span class="comment">//或std::ptrdiff_t i, j</span></span><br><span class="line"><span class="keyword">auto</span> min = a.<span class="built_in">minCoeff</span>(i,j);返回a的最小元素赋值给min，并将最小元素所在行号、列号赋值给i、j。</span><br><span class="line"><span class="keyword">auto</span> max = a.<span class="built_in">maxCoeff</span>(p,q);返回a的最大元素赋值给max，并将最大元素所在行号、列号赋值给q、p。</span><br></pre></td></tr></table></figure>

<h3 id="6，【-norm-】向量求模，矩阵范数"><a href="#6，【-norm-】向量求模，矩阵范数" class="headerlink" title="6，【.norm()】向量求模，矩阵范数"></a>6，【.norm()】向量求模，矩阵<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%8C%83%E6%95%B0&spm=1001.2101.3001.7020">范数</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.norm();//返回矩阵的Frobenius范数，即元素平方的和的平方根</span><br><span class="line">u.norm();//返回向量的模</span><br></pre></td></tr></table></figure>

<h1 id="Hw02"><a href="#Hw02" class="headerlink" title="Hw02"></a>Hw02</h1><h2 id="2022-x2F-04-x2F-12"><a href="#2022-x2F-04-x2F-12" class="headerlink" title="2022&#x2F;04&#x2F;12"></a>2022&#x2F;04&#x2F;12</h2><p>完成了作业二以及MSAA。目前没有学习z-buffer的插值函数，所以直接用了框架提供的代码。</p>
<p>目前效果是：如下图所示，三角形周围有黑线。</p>
<p><img data-fancybox="gallery" src="/images/GAMES101/MSAA%E9%BB%91%E7%BA%BF_class7.png" alt="MSAA黑线_class7" data-caption="MSAA黑线_class7" loading="lazy"></p>
<p>对应代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> rst::rasterizer::<span class="built_in">updateColorAndDepth</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> Triangle&amp; t, <span class="type">float</span> color_percent = <span class="number">1.0f</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 转换为齐次坐标</span></span><br><span class="line">    <span class="comment">// 在这一步，已经经过了MVP变换为了屏幕上的点，所以只需要知道x, y的信息即可</span></span><br><span class="line">    <span class="keyword">auto</span> v = t.<span class="built_in">toVector4</span>();</span><br><span class="line">    <span class="comment">// If so, use the following code to get the interpolated z value.</span></span><br><span class="line">    <span class="comment">// 这是插值函数，目前还没学到（刚上完p7）；这里加0.5f没有出错</span></span><br><span class="line">    <span class="comment">// auto[alpha, beta, gamma] = computeBarycentric2D(x + 0.5f, y + 0.5f, t.v);</span></span><br><span class="line">    <span class="keyword">auto</span>[alpha, beta, gamma] = <span class="built_in">computeBarycentric2D</span>(x, y, t.v);</span><br><span class="line">    <span class="type">float</span> w_reciprocal = <span class="number">1.0</span>/(alpha / v[<span class="number">0</span>].<span class="built_in">w</span>() + beta / v[<span class="number">1</span>].<span class="built_in">w</span>() + gamma / v[<span class="number">2</span>].<span class="built_in">w</span>());</span><br><span class="line">    <span class="type">float</span> z_interpolated = alpha * v[<span class="number">0</span>].<span class="built_in">z</span>() / v[<span class="number">0</span>].<span class="built_in">w</span>() + beta * v[<span class="number">1</span>].<span class="built_in">z</span>() / v[<span class="number">1</span>].<span class="built_in">w</span>() + gamma * v[<span class="number">2</span>].<span class="built_in">z</span>() / v[<span class="number">2</span>].<span class="built_in">w</span>();</span><br><span class="line">    z_interpolated *= w_reciprocal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还是z的问题，因为z是负值，所以如果越近，z越大</span></span><br><span class="line">    <span class="comment">// 因此depth_buf初始化的时候应该是用-inf来初始化才对</span></span><br><span class="line">    <span class="keyword">if</span>(z_interpolated &gt; depth_buf[<span class="built_in">get_index</span>(x, y)])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// TODO : set the current pixel (use the set_pixel function) to the color of the triangle (use getColor function) if it should be painted.</span></span><br><span class="line">        <span class="comment">// 用像素的中心来判断 但是加了0.5会导致缺一块   </span></span><br><span class="line">        <span class="comment">// 猜测加了0.5f出错是因为x, y应该是像素的index而不是像素中心的坐标点</span></span><br><span class="line">        Eigen::Vector3f point = Eigen::<span class="built_in">Vector3f</span>(x, y, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="built_in">set_pixel</span>(point, t.<span class="built_in">getColor</span>() * color_percent);</span><br><span class="line">        <span class="comment">// 更新depth_buf</span></span><br><span class="line">        depth_buf[<span class="built_in">get_index</span>(x, y)] = z_interpolated;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(MSAA)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义super-sampling的形状</span></span><br><span class="line">    <span class="type">int</span> m = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">2</span>;</span><br><span class="line">    <span class="type">float</span> total_samples = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(m * n);</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">Eigen::Vector2f <span class="title">p</span><span class="params">(x+(<span class="number">0.5f</span>+i)/m, y+(<span class="number">0.5f</span>+j)/n)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">insideTrianglePoint</span>(p, t.v)) count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">float</span> color_percent = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(count) / total_samples;</span><br><span class="line">    <span class="keyword">if</span>(color_percent &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">updateColorAndDepth</span>(x, y, t, color_percent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2022-x2F-04-x2F-19"><a href="#2022-x2F-04-x2F-19" class="headerlink" title="2022&#x2F;04&#x2F;19"></a>2022&#x2F;04&#x2F;19</h2><p><strong>去掉了黑线</strong></p>
<p><img data-fancybox="gallery" src="/images/GAMES101/MSAA%E5%8E%BB%E6%8E%89%E9%BB%91%E7%BA%BF_class9.png" alt="MSAA去掉黑线_class9" data-caption="MSAA去掉黑线_class9" loading="lazy"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> rst::rasterizer::<span class="built_in">updateColorAndDepth</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> Triangle&amp; t, <span class="type">float</span> color_percent = <span class="number">1.0f</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ind = <span class="built_in">get_index</span>(x, y);</span><br><span class="line">    <span class="comment">// 转换为齐次坐标</span></span><br><span class="line">    <span class="comment">// 在这一步，已经经过了MVP变换为了屏幕上的点，所以只需要知道x, y的信息即可</span></span><br><span class="line">    <span class="keyword">auto</span> v = t.<span class="built_in">toVector4</span>();</span><br><span class="line">    <span class="comment">// If so, use the following code to get the interpolated z value.</span></span><br><span class="line">    <span class="comment">// 这是插值函数，目前还没学到（刚上完p7）；这里加0.5f没有出错</span></span><br><span class="line">    <span class="comment">// auto[alpha, beta, gamma] = computeBarycentric2D(x + 0.5f, y + 0.5f, t.v);</span></span><br><span class="line">    <span class="keyword">auto</span>[alpha, beta, gamma] = <span class="built_in">computeBarycentric2D</span>(x, y, t.v);</span><br><span class="line">    <span class="type">float</span> w_reciprocal = <span class="number">1.0</span>/(alpha / v[<span class="number">0</span>].<span class="built_in">w</span>() + beta / v[<span class="number">1</span>].<span class="built_in">w</span>() + gamma / v[<span class="number">2</span>].<span class="built_in">w</span>());</span><br><span class="line">    <span class="type">float</span> z_interpolated = alpha * v[<span class="number">0</span>].<span class="built_in">z</span>() / v[<span class="number">0</span>].<span class="built_in">w</span>() + beta * v[<span class="number">1</span>].<span class="built_in">z</span>() / v[<span class="number">1</span>].<span class="built_in">w</span>() + gamma * v[<span class="number">2</span>].<span class="built_in">z</span>() / v[<span class="number">2</span>].<span class="built_in">w</span>();</span><br><span class="line">    z_interpolated *= w_reciprocal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还是z的问题，因为z是负值，所以如果越近，z越大</span></span><br><span class="line">    <span class="comment">// 因此depth_buf初始化的时候应该是用-inf来初始化才对</span></span><br><span class="line">    <span class="keyword">if</span>(z_interpolated &gt; depth_buf[ind])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// TODO : set the current pixel (use the set_pixel function) to the color of the triangle (use getColor function) if it should be painted.</span></span><br><span class="line">        <span class="comment">// 用像素的中心来判断 但是加了0.5会导致缺一块   </span></span><br><span class="line">        <span class="comment">// 猜测加了0.5f出错是因为x, y应该是像素的index而不是像素中心的坐标点</span></span><br><span class="line">        Eigen::Vector3f point = Eigen::<span class="built_in">Vector3f</span>(x, y, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="built_in">set_pixel</span>(point, t.<span class="built_in">getColor</span>() * color_percent + frame_buf[ind] * (<span class="number">1</span> - color_percent));</span><br><span class="line">        <span class="comment">// 更新depth_buf</span></span><br><span class="line">        depth_buf[ind] = z_interpolated;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为了将边界处的深度初始化，因为如果存在重叠的情况，需要更新下方的颜色，否则比较大小内不会执行（颜色不更新）</span></span><br><span class="line">    <span class="keyword">if</span>(color_percent &lt; <span class="number">1.0f</span>) depth_buf[ind] = - std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">infinity</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体来说，首先着色的是绿色的三角形，如果是边界，那么color_percent一定小于1，这时，由于是第一次着色，所以原本的frame_buffer中存的是黑色(0, 0, 0)，如果有颜色的占比很小，那么MSAA混合出来的颜色就会很深，看着就像一条黑线。所以需要将depth_buffer初始化，在而后对处于下方的蓝色三角形进行着色时，这个原本的黑色边界就会被着色为蓝色，边界也就不存在了。</p>
<h2 id="黑边问题"><a href="#黑边问题" class="headerlink" title="黑边问题"></a>黑边问题</h2><p>产生黑边的<strong>原因</strong>主要为：这时采用的为原图片大小的深度缓存空间，两个三角形位置为关系为绿色在上（前），蓝色在下（后）面，绘制时的顺序也按照这样。在计算完绿色三角形之后，帧缓存和深度缓存均已更新，三角形边缘的地方像素颜色采用覆盖比率插值计算，深度值为绿色三角形在该坐标所计算出的深度插值。根据上面的话，这条黑色的边其实并不是真的的黑色，而是插值之后的绿色，只不过是由于覆盖比率很小在插值之后rgb值变得很低，颜色的饱和度与亮度会随之下降。例如原rgb值为（200,200,100），若覆盖比率为4&#x2F;16的话，如下面效果，若覆盖率更低那么会更接近黑色。（参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_51928794/article/details/117256226%EF%BC%89">https://blog.csdn.net/weixin_51928794/article/details/117256226）</a></p>
<p><img data-fancybox="gallery" src="https://img-blog.csdnimg.cn/20210525152530754.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTkyODc5NA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" data-caption="在这里插入图片描述" loading="lazy"></p>
<p><img data-fancybox="gallery" src="https://img-blog.csdnimg.cn/20210525152530802.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTkyODc5NA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" data-caption="在这里插入图片描述" loading="lazy"></p>
<p>在计算完第一个绿色的三角形之后，开始计算第二个蓝色的三角形，这时又遍历到了上面异常的黑边处，也就是有一点点绿色的黑边，需要比较深度缓存来决定蓝色三角形是否要在该像素绘制。在每个像素采样计算时，三角形的覆盖是按照4x4采样计算的，但是深度值是按照像素级别1x1计算和存储来的， 之前该像素位置只存储了绿色三角形的深度值，蓝色三角形在绿色之后，所以深度比较失败，从而导致了该处不会再更新像素值。</p>
<p><strong>解决方法</strong>：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/454001952">Games101｜作业2 + 光栅化 + SSAA vs MSAA + 黑边问题 - 知乎 (zhihu.com)</a></p>
<p>为了解决这个问题，我们可以在光栅化的时候，确保边界上的每个三角形的每个小像素都被考虑到，即在过完每个 边界上的像素后，我们确保记录下它的frame buffer，<strong>并清除它的depth buffer</strong>。这样上图的蓝色小像素就不会因为depth_buf的原因，而没被记录。如何确定哪个像素在边界上？通过在三角形的小像素的个数。</p>
<p>翻译一下这个方案，就是通过比较上下重叠的两个物体，谁在边界处对像素的samples覆盖得更多，取覆盖的更多的那个颜色（且不稀释？）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Screen space rasterization</span></span><br><span class="line"><span class="type">void</span> rst::rasterizer::<span class="built_in">rasterize_triangle</span>(<span class="type">const</span> Triangle&amp; t) &#123;</span><br><span class="line">    <span class="keyword">auto</span> v = t.<span class="built_in">toVector4</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> min_x = width;</span><br><span class="line">    <span class="type">float</span> max_x = <span class="number">0</span>;</span><br><span class="line">    <span class="type">float</span> min_y = height;</span><br><span class="line">    <span class="type">float</span> max_y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find out the bounding box of current triangle</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        min_x = std::<span class="built_in">min</span>(v[i].<span class="built_in">x</span>(), min_x);</span><br><span class="line">        max_x = std::<span class="built_in">max</span>(v[i].<span class="built_in">x</span>(), max_x);</span><br><span class="line">        min_y = std::<span class="built_in">min</span>(v[i].<span class="built_in">y</span>(), min_y);</span><br><span class="line">        max_y = std::<span class="built_in">max</span>(v[i].<span class="built_in">y</span>(), max_y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iterate through the pixel</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y = min_y; y &lt; max_y; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x = min_x; x &lt; max_x; x++) &#123;</span><br><span class="line">            <span class="type">int</span> index = <span class="built_in">get_index</span>(x, y);</span><br><span class="line">            <span class="type">float</span> count = <span class="number">0.0</span>;</span><br><span class="line">            <span class="type">float</span> max_count = ssaa_w*ssaa_h;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">float</span> j = start_point; j &lt; <span class="number">1.0</span>; j+=pixel_size_sm) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">float</span> i = start_point; i &lt; <span class="number">1.0</span>; i+=pixel_size_sm) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">insideTriangle</span>(x+i, y+j, t.v)) &#123;</span><br><span class="line">                        count += <span class="number">1.0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// find if the current pixel is inside the triangle</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">insideTriangle</span>(x+<span class="number">0.5</span>, y+<span class="number">0.5</span>, t.v)) &#123;</span><br><span class="line">                <span class="comment">// if so, use the following code to get the interpolated z value.</span></span><br><span class="line">                <span class="keyword">auto</span>[alpha, beta, gamma] = <span class="built_in">computeBarycentric2D</span>(x+<span class="number">0.5</span>, y+<span class="number">0.5</span>, t.v);</span><br><span class="line">                <span class="type">float</span> w_reciprocal = <span class="number">1.0</span>/(alpha / v[<span class="number">0</span>].<span class="built_in">w</span>() + beta / v[<span class="number">1</span>].<span class="built_in">w</span>() + gamma / v[<span class="number">2</span>].<span class="built_in">w</span>());</span><br><span class="line">                <span class="type">float</span> z_interpolated = alpha * v[<span class="number">0</span>].<span class="built_in">z</span>() / v[<span class="number">0</span>].<span class="built_in">w</span>() + beta * v[<span class="number">1</span>].<span class="built_in">z</span>() / v[<span class="number">1</span>].<span class="built_in">w</span>() + gamma * v[<span class="number">2</span>].<span class="built_in">z</span>() / v[<span class="number">2</span>].<span class="built_in">w</span>();</span><br><span class="line">                z_interpolated *= w_reciprocal;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// set the current pixel (use the set_pixel function) </span></span><br><span class="line">                <span class="comment">// to the color of the triangle (use getColor function)</span></span><br><span class="line">                <span class="comment">// if it should be painted.</span></span><br><span class="line">                <span class="keyword">if</span>(z_interpolated &lt; depth_buf[index]) &#123;</span><br><span class="line">                    Eigen::Vector3f p;</span><br><span class="line">                    p &lt;&lt; x, y, z_interpolated;</span><br><span class="line">                    Eigen::Vector3f color = t.<span class="built_in">getColor</span>()*(count/max_count)+((max_count-count)/max_count)*frame_buf[index];</span><br><span class="line">                    <span class="built_in">set_pixel</span>(p, color);</span><br><span class="line">                    depth_buf[index] = z_interpolated;</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count &lt; max_count) &#123;</span><br><span class="line">                depth_buf[index] = std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">infinity</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Hw03"><a href="#Hw03" class="headerlink" title="Hw03"></a>Hw03</h1><h2 id="2022-04-21"><a href="#2022-04-21" class="headerlink" title="2022.04.21"></a>2022.04.21</h2><p><em>完成了Hw3，包括基于双线性插值的纹理采样。</em></p>
<ul>
<li><p>首先是基于中心坐标的插值（rasterize_triangle方法中）:</p>
<ul>
<li>normal：用于phong shading，顶点的normal记录在obj中。</li>
</ul>
<p><img data-fancybox="gallery" src="/images/GAMES101/output_normal.png" alt="output_normal" data-caption="output_normal" loading="lazy"></p>
<ul>
<li>color：phong shading中的kd，triangle初始化时定义，目前是hardcode的。</li>
<li>texure_coords：通过插值找到当前像素在纹理贴图上的uv坐标，uv坐标取值范围为[0, 1]，将查找到的color作为kd进行shading，顶点的texure_coords记录在obj中。</li>
</ul>
<p><img data-fancybox="gallery" src="/images/GAMES101/output_texture.png" alt="output_texture" data-caption="output_texture" loading="lazy"></p>
<ul>
<li>shading_coods：通过model和view变换之后的position用于shading的计算，因为投影之后失去了3d的几何性质，向量I，向量V都需要这个坐标才可以计算出来。</li>
</ul>
</li>
<li><p>phong_shader中，使用了blinn-phong着色模型，分为ambient，diffuse，specular三个分量，三者叠加。如果环境中有几个光源，那么最终的结果是几个光源分别作用在物体上的三个分量之和的叠加。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   Eigen::Vector3f result_color = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; light : lights)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// <span class="doctag">TODO:</span> For each light source in the code, calculate what the *ambient*, *diffuse*, and *specular* </span></span><br><span class="line">       <span class="comment">// components are. Then, accumulate that result on the *result_color* object.</span></span><br><span class="line">       <span class="type">float</span> r2 = (light.position - point).<span class="built_in">dot</span>(light.position - point);</span><br><span class="line">       Eigen::Vector3f l = (light.position - point).<span class="built_in">normalized</span>();</span><br><span class="line">       <span class="comment">// Eigen::Vector3f n = normal - point;</span></span><br><span class="line">       Eigen::Vector3f v = (eye_pos - point).<span class="built_in">normalized</span>();</span><br><span class="line">       <span class="comment">// 要用矩阵的对应元素相乘cwiseProduct才可以，因为rgb三个方向的强度、ka\kb\ks可能都不一样，分开计算。</span></span><br><span class="line">       <span class="comment">// 向量只有点乘和叉乘，点乘得到数，叉乘得到向量。</span></span><br><span class="line">       <span class="comment">// 点乘可以用a.dot(b), 也可以a.transpose() * b (a,b是行数相同的vector)</span></span><br><span class="line">       Eigen::Vector3f ambient = ka.<span class="built_in">cwiseProduct</span>(amb_light_intensity);</span><br><span class="line">       Eigen::Vector3f diffuse = kd.<span class="built_in">cwiseProduct</span>(light.intensity / r2) * std::<span class="built_in">max</span>(<span class="number">0.0f</span>, normal.<span class="built_in">dot</span>(l));</span><br><span class="line">       Eigen::Vector3f specular =  ks.<span class="built_in">cwiseProduct</span>(light.intensity / r2) * <span class="built_in">pow</span>(std::<span class="built_in">max</span>(<span class="number">0.0f</span>, normal.<span class="built_in">dot</span>((l + v).<span class="built_in">normalized</span>())), p);</span><br><span class="line">       result_color += ambient + diffuse + specular;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img data-fancybox="gallery" src="/images/GAMES101/output_phong.png" alt="output_phong" data-caption="output_phong" loading="lazy"></p>
<ul>
<li>bump和displacement贴图都是需要使用TBN和微分计算出来的位移切线方向来计算新的normal向量，在这个作业中，bump_shader直接输出的时normal作为颜色；displacement_shader在此基础上，还要重新计算position_view（因为顶点是真的发生了移动），然后重新应用phong_shading来进行着色。</li>
<li>在bump内我加了blinn-phong模型与displacement的效果进行对比。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> kh = <span class="number">0.2</span>, kn = <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Implement displacement mapping here</span></span><br><span class="line"><span class="comment">// Let n = normal = (x, y, z)</span></span><br><span class="line">Eigen::Vector3f n = normal;</span><br><span class="line"><span class="comment">// Vector t = (x*y/sqrt(x*x+z*z),sqrt(x*x+z*z),z*y/sqrt(x*x+z*z))</span></span><br><span class="line"><span class="type">float</span> x = n.<span class="built_in">x</span>();</span><br><span class="line"><span class="type">float</span> y = n.<span class="built_in">y</span>();</span><br><span class="line"><span class="type">float</span> z = n.<span class="built_in">z</span>();</span><br><span class="line">Eigen::Vector3f t&#123;x*y/<span class="built_in">sqrt</span>(x*x+z*z), <span class="built_in">sqrt</span>(x*x+z*z), z*y/<span class="built_in">sqrt</span>(x*x+z*z)&#125;;</span><br><span class="line"><span class="comment">// Vector b = n cross product t</span></span><br><span class="line">Eigen::Vector3f b = n.<span class="built_in">cross</span>(t);</span><br><span class="line"><span class="comment">// Matrix TBN = [t b n]</span></span><br><span class="line">Eigen::Matrix3f TBN;</span><br><span class="line">TBN &lt;&lt; t, b, n;</span><br><span class="line"><span class="comment">// ??????????????????????????不懂 但好像又有点懂</span></span><br><span class="line"><span class="comment">// dU = kh * kn * (h(u+1/w,v)-h(u,v))</span></span><br><span class="line"><span class="type">float</span> w = payload.texture-&gt;width;</span><br><span class="line"><span class="type">float</span> h = payload.texture-&gt;height;</span><br><span class="line"><span class="type">float</span> u = payload.tex_coords.<span class="built_in">x</span>();</span><br><span class="line"><span class="type">float</span> v = payload.tex_coords.<span class="built_in">y</span>();</span><br><span class="line"><span class="comment">// 在这里norm一下取模长，近似为高度？</span></span><br><span class="line"><span class="type">float</span> dU = kh * kn * (payload.texture-&gt;<span class="built_in">getColor</span>(u+<span class="number">1.0f</span>/w,v).<span class="built_in">norm</span>() - payload.texture-&gt;<span class="built_in">getColor</span>(u,v).<span class="built_in">norm</span>());</span><br><span class="line"><span class="comment">// dV = kh * kn * (h(u,v+1/h)-h(u,v))</span></span><br><span class="line"><span class="type">float</span> dV = kh * kn * (payload.texture-&gt;<span class="built_in">getColor</span>(u,v+<span class="number">1.0f</span>/h).<span class="built_in">norm</span>() - payload.texture-&gt;<span class="built_in">getColor</span>(u,v).<span class="built_in">norm</span>());</span><br><span class="line"><span class="comment">// Vector ln = (-dU, -dV, 1)</span></span><br><span class="line">Eigen::Vector3f ln&#123;-dU, -dV, <span class="number">1.0f</span>&#125;;</span><br><span class="line"><span class="comment">// Position p = p + kn * n * h(u,v)</span></span><br><span class="line">point = point + kn * n * payload.texture-&gt;<span class="built_in">getColor</span>(u,v).<span class="built_in">norm</span>();</span><br><span class="line"><span class="comment">// Normal n = normalize(TBN * ln)</span></span><br><span class="line">n = (TBN * ln).<span class="built_in">normalized</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如下图所示：</p>
<p><img data-fancybox="gallery" src="/images/GAMES101/output_bump.png" alt="output_bump" data-caption="output_bump" loading="lazy"></p>
<p><img data-fancybox="gallery" src="/images/GAMES101/output_displacement.png" alt="output_displacement" data-caption="output_displacement" loading="lazy"></p>
<p><img data-fancybox="gallery" src="/images/GAMES101/output_bump_vs_displacement.png" alt="output_bump_vs_displacement" data-caption="output_bump_vs_displacement" loading="lazy"></p>
<ul>
<li>最后是双线性插值（关键点在注释中）：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双线性插值进行纹理采样</span></span><br><span class="line"><span class="function">Eigen::Vector3f <span class="title">getColorBilinear</span><span class="params">(<span class="type">float</span> u, <span class="type">float</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> u_img = u * <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width);</span><br><span class="line">    <span class="type">float</span> v_img = (<span class="number">1</span> - v) * <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">    <span class="type">float</span> u_img_round = <span class="built_in">round</span>(u_img);</span><br><span class="line">    <span class="type">float</span> v_img_round = <span class="built_in">round</span>(v_img);</span><br><span class="line">    std::vector&lt;Eigen::Vector2f&gt; neighbours</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// opencv的坐标x,y是反的..........</span></span><br><span class="line">        <span class="comment">// https://blog.csdn.net/sc944201630/article/details/82222909</span></span><br><span class="line">        <span class="comment">// ↙</span></span><br><span class="line">        &#123;u_img_round - <span class="number">0.5f</span>, v_img_round + <span class="number">0.5f</span>&#125;,</span><br><span class="line">        <span class="comment">// &#123;u_img_round - 1.0f, v_img_round + 1.0f&#125;,</span></span><br><span class="line">        <span class="comment">// ↘</span></span><br><span class="line">        &#123;u_img_round + <span class="number">0.5f</span>, v_img_round + <span class="number">0.5f</span>&#125;,</span><br><span class="line">        <span class="comment">// &#123;u_img_round , v_img_round + 1.0f&#125;,</span></span><br><span class="line">        <span class="comment">// ↖</span></span><br><span class="line">        &#123;u_img_round - <span class="number">0.5f</span>, v_img_round - <span class="number">0.5f</span>&#125;,</span><br><span class="line">        <span class="comment">// &#123;u_img_round - 1.0f, v_img_round&#125;,</span></span><br><span class="line">        <span class="comment">// ↗</span></span><br><span class="line">        &#123;u_img_round + <span class="number">0.5f</span>, v_img_round - <span class="number">0.5f</span>&#125;</span><br><span class="line">        <span class="comment">// &#123;u_img_round, v_img_round&#125;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">float</span> s = u_img - neighbours[<span class="number">2</span>].<span class="built_in">x</span>();</span><br><span class="line">    <span class="type">float</span> t = v_img - neighbours[<span class="number">2</span>].<span class="built_in">y</span>();</span><br><span class="line">    <span class="comment">// float s = u_img - neighbours[2].x() - 0.5f;</span></span><br><span class="line">    <span class="comment">// float t = v_img - neighbours[2].y() + 0.5f;</span></span><br><span class="line">    <span class="comment">// 对于s/t的计算，不论是以整数为单位还是0.5(pixel中心)为单位，结果都是一样的，无非整体-0.5或+0.5</span></span><br><span class="line">    <span class="comment">// 唯一不同的就是getColor的取值罢了，实验下来，以0.5为单位的结果和未插值的结果是一样的。</span></span><br><span class="line">    Eigen::Vector3f down_lerp = <span class="built_in">lerp</span>(s, <span class="built_in">getColor</span>(neighbours[<span class="number">2</span>]), <span class="built_in">getColor</span>(neighbours[<span class="number">3</span>]));</span><br><span class="line">    Eigen::Vector3f up_lerp = <span class="built_in">lerp</span>(s, <span class="built_in">getColor</span>(neighbours[<span class="number">0</span>]), <span class="built_in">getColor</span>(neighbours[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lerp</span>(t, down_lerp, up_lerp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还要注意的是，opencv的坐标系是从左上方开始的，不是左下方。</p>
<p>悬而未决：以pixel中心的坐标作为opencv的输入才可以得到与未插值的时候相同的结果（是说坐标的偏移等等），为什么？可能是因为opencv本身要求就是输入pixel中心的坐标来得到相应的color吧。</p>
<p>结果如下图，分别是512 * 512(small)以及256 * 256(tiny)的纹理贴图未应用&#x2F;应用了双线性插值：</p>
<p><img data-fancybox="gallery" src="/images/GAMES101/output_small_texure_not_bilinear.png" alt="output_small_texure_not_bilinear" data-caption="output_small_texure_not_bilinear" loading="lazy"></p>
<p>small-未应用</p>
<p><img data-fancybox="gallery" src="/images/GAMES101/output_small_texure_bilinear.png" alt="output_small_texure_bilinear" data-caption="output_small_texure_bilinear" loading="lazy"></p>
<p>small-已应用</p>
<p><img data-fancybox="gallery" src="/images/GAMES101/output_tiny_texure_not_bilinear.png" alt="output_tiny_texure_not_bilinear" data-caption="output_tiny_texure_not_bilinear" loading="lazy"></p>
<p>tiny-未应用</p>
<p><img data-fancybox="gallery" src="/images/GAMES101/output_tiny_texure_bilinear.png" alt="output_tiny_texure_bilinear" data-caption="output_tiny_texure_bilinear" loading="lazy"></p>
<p>tiny-已应用</p>
<p>可以看到，效果还是很明显的，应用了双线性插值之后，马赛克的现象好了很多。</p>
<h2 id="2022-x2F-04-x2F-22"><a href="#2022-x2F-04-x2F-22" class="headerlink" title="2022&#x2F;04&#x2F;22"></a>2022&#x2F;04&#x2F;22</h2><p>Segment Fault</p>
<p>1: Texture.hpp中，根据uv getColor()的时候，uv要先格式化为[0, 1]之间；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(u &gt; <span class="number">1</span>) u = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(v &gt; <span class="number">1</span>) v = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(u &lt; <span class="number">0</span>) u = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(v &lt; <span class="number">0</span>) v = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>2: rock.obj，如果相机离物体太近，也会段错误。所以把eye_pos的z坐标改大。因为物体在世界坐标系原点，相机指向-z方向，相当于朝着z正方向平移（view变换里的矩阵值是-z）。</p>
<p>其他obj的渲染结果如下：</p>
<p><img data-fancybox="gallery" src="/images/GAMES101/output_bunny_normal.png" alt="output_bunny_normal" data-caption="output_bunny_normal" loading="lazy"></p>
<p><img data-fancybox="gallery" src="/images/GAMES101/output_bunny_phong_eye_pos_shading_2.png" alt="output_bunny_phong_eye_pos_shading_2" data-caption="output_bunny_phong_eye_pos_shading_2" loading="lazy"></p>
<p>这是在main改了eye_pos，shader里面的eye_pos同步修改的结果。</p>
<p><img data-fancybox="gallery" src="/images/GAMES101/output_bunny_phong_eye_pos_shading_10.png" alt="output_bunny_phong_eye_pos_shading_10" data-caption="output_bunny_phong_eye_pos_shading_10" loading="lazy"></p>
<p>这是在main改了eye_pos，shader里面的eye_pos未同步修改的结果。</p>
<p>可以看到(0, 0, 2)和(0, 0, 10)的eye_pos在phong shader里面的差别并不大。</p>
<p>然后，为了验证当obj位于相机背后时，成像会是倒立的（小孔成像原理），将eye_pos改为(0, 0, -2)，效果如下，可以看到，确实成像是倒立的，并且是面朝成像平面，而非背部。</p>
<p><img data-fancybox="gallery" src="/images/GAMES101/output_bunny_normal_back.png" alt="output_bunny_normal_back" data-caption="output_bunny_normal_back" loading="lazy"></p>
<p>然后是rock.obj：</p>
<p><img data-fancybox="gallery" src="/images/GAMES101/output_rock_normal.png" alt="output_rock_normal" data-caption="output_rock_normal" loading="lazy"></p>
<p><img data-fancybox="gallery" src="/images/GAMES101/output_rock_phong.png" alt="output_rock_phong" data-caption="output_rock_phong" loading="lazy"></p>
<p><img data-fancybox="gallery" src="/images/GAMES101/output_rock_texture.png" alt="output_rock_texture" data-caption="output_rock_texture" loading="lazy"></p>
<p>cube.obj：</p>
<p><img data-fancybox="gallery" src="/images/GAMES101/output_cube_normal.png" alt="output_cube_normal" data-caption="output_cube_normal" loading="lazy"></p>
<p><img data-fancybox="gallery" src="/images/GAMES101/output_cube_phong.png" alt="output_cube_phong" data-caption="output_cube_phong" loading="lazy"></p>
<p><img data-fancybox="gallery" src="/images/GAMES101/output_cube_texture.png" alt="output_cube_texture" data-caption="output_cube_texture" loading="lazy"></p>
<p><img data-fancybox="gallery" src="/images/GAMES101/output_cube_texture_1.png" alt="output_cube_texture_1" data-caption="output_cube_texture_1" loading="lazy"></p>
<p>Crate1.obj：这个模型本身顶点有问题，详见-&gt;<a target="_blank" rel="noopener" href="https://games-cn.org/forums/topic/%E4%BD%9C%E4%B8%9A3%E6%8D%A2%E6%A8%A1%E5%9E%8B-crate%E5%87%BA%E5%A4%A7%E9%97%AE%E9%A2%98/">作业3换模型—crate出大问题 – 计算机图形学与混合现实在线平台 (games-cn.org)</a>。</p>
<p><img data-fancybox="gallery" src="/images/GAMES101/output_crate_normal.png" alt="output_crate_normal" data-caption="output_crate_normal" loading="lazy"></p>
<p><img data-fancybox="gallery" src="/images/GAMES101/output_crate_phong.png" alt="output_crate_phong" data-caption="output_crate_phong" loading="lazy"></p>
<p><img data-fancybox="gallery" src="/images/GAMES101/output_crate_texture.png" alt="output_crate_texture" data-caption="output_crate_texture" loading="lazy"></p>
<h1 id="Hw04"><a href="#Hw04" class="headerlink" title="Hw04"></a>Hw04</h1><h2 id="2022-x2F-05-x2F-21"><a href="#2022-x2F-05-x2F-21" class="headerlink" title="2022&#x2F;05&#x2F;21"></a>2022&#x2F;05&#x2F;21</h2><p>使用优先队列实现了De Casteljau算法，如下图所示。</p>
<p><img data-fancybox="gallery" src="/images/GAMES101/output_04.png" alt="output" data-caption="output" loading="lazy"></p>
<p><strong>暂时没有实现反走样。</strong></p>
<p>总结一下：</p>
<ol>
<li>iterator如果是const对象的迭代器的话，会比较麻烦，用auto比较方便；访问值要用*it，迭代的时候直接it++即可；</li>
<li>思路是使用优先队列来对曲线上的点进行求取；需要注意的是queue的pop()不会返回值；</li>
<li>opencv库，at()函数用于绘制像素的颜色，[0] [1] [2] 分别是b&#x2F;g&#x2F;r通道；后面的值为通道的颜色的浓淡，255最浓。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cv::Point2f <span class="title">recursive_bezier</span><span class="params">(<span class="type">const</span> std::vector&lt;cv::Point2f&gt; &amp;control_points, <span class="type">float</span> t)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Implement de Casteljau&#x27;s algorithm</span></span><br><span class="line">    std::queue&lt;cv::Point2f&gt; current_points;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = control_points.<span class="built_in">begin</span>(); it != control_points.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        current_points.<span class="built_in">push</span>(*it);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> total_num = current_points.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> count = total_num;</span><br><span class="line">    <span class="keyword">while</span>(total_num != <span class="number">1</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">if</span>(count &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count--;</span><br><span class="line">            cv::Point2f begin_point = current_points.<span class="built_in">front</span>();</span><br><span class="line">            current_points.<span class="built_in">pop</span>();</span><br><span class="line">            cv::Point2f end_point = current_points.<span class="built_in">front</span>();</span><br><span class="line">            current_points.<span class="built_in">push</span>(begin_point + t * (end_point - begin_point));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            current_points.<span class="built_in">pop</span>();</span><br><span class="line">            total_num = current_points.<span class="built_in">size</span>();</span><br><span class="line">            count = total_num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current_points.<span class="built_in">front</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bezier</span><span class="params">(<span class="type">const</span> std::vector&lt;cv::Point2f&gt; &amp;control_points, cv::Mat &amp;window)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Iterate through all t = 0 to t = 1 with small steps, and call de Casteljau&#x27;s </span></span><br><span class="line">    <span class="comment">// recursive Bezier algorithm.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">float</span> t = <span class="number">0.0</span>; t &lt;= <span class="number">1.0</span>; t += <span class="number">0.001</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// at()函数</span></span><br><span class="line">        <span class="comment">// 对于单通道图像&quot;picture1&quot;，picture1.at&lt;uchar&gt;(i,j)就表示在第i行第j列的像素值。</span></span><br><span class="line">        <span class="comment">// 对于多通道图像如RGB图像&quot;picture2&quot;，可以用picture2.at&lt;Vec3b&gt;(i,j)[c]来表示某个通道中在(i,j)位置的像素值。</span></span><br><span class="line">        <span class="comment">// 1）上面的uchar、Vec3b表示图像元素的类型。</span></span><br><span class="line">        <span class="comment">// 2）(i,j)当然就是指像素点的位置，表示第i行第j列。</span></span><br><span class="line">        <span class="comment">// 3）[c]表示的是通道，对于RGB图像而言，c取0就是B分量；c取1就是G分量；c取2就是R分量（要注意在OpenCV中是按BGR的顺序表示的）。</span></span><br><span class="line">        <span class="keyword">auto</span> point = <span class="built_in">recursive_bezier</span>(control_points, t);</span><br><span class="line">        window.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(point.y, point.x)[<span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2022-x2F-06-x2F-07"><a href="#2022-x2F-06-x2F-07" class="headerlink" title="2022&#x2F;06&#x2F;07"></a>2022&#x2F;06&#x2F;07</h2><p>实现了反走样：</p>
<p><img data-fancybox="gallery" src="/images/GAMES101/my_bezier_curve_antialiasing.png" alt="my_bezier_curve_antialiasing" data-caption="my_bezier_curve_antialiasing" loading="lazy"></p>
<p>具体实现如下：</p>
<p>简单来说就是分别查看着色点到它周围9个像素的距离，从而生成颜色的浓度ratio比例，乘上255即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参考: https://blog.csdn.net/ycrsw/article/details/124117190</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">-1</span>; i &lt;= <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">-1</span>; j &lt;= <span class="number">1</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不处理越界像素</span></span><br><span class="line">        <span class="keyword">if</span> (point.x + i &gt; <span class="number">700</span> || point.x + i &lt; <span class="number">0</span> || point.y + j &gt; <span class="number">700</span> || point.y + j &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 计算ratio</span></span><br><span class="line">        ratio = <span class="number">1</span> - <span class="built_in">sqrt</span>(<span class="number">2</span>)*<span class="built_in">sqrt</span>(<span class="built_in">pow</span>(point.y - <span class="built_in">int</span>(point.y + j) - <span class="number">0.5</span>, <span class="number">2</span>) + <span class="built_in">pow</span>(point.x - <span class="built_in">int</span>(point.x + i) - <span class="number">0.5</span>, <span class="number">2</span>)) / <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 计算像素颜色</span></span><br><span class="line">        window.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(point.y + j, point.x + i)[<span class="number">2</span>] = std::<span class="built_in">fmax</span>(window.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(point.y + j, point.x + i)[<span class="number">2</span>], <span class="number">255</span> * ratio);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Hw05"><a href="#Hw05" class="headerlink" title="Hw05"></a>Hw05</h1><h2 id="2022-x2F-05-x2F-29"><a href="#2022-x2F-05-x2F-29" class="headerlink" title="2022&#x2F;05&#x2F;29"></a>2022&#x2F;05&#x2F;29</h2><ol>
<li>Renderer()</li>
</ol>
<p>在这里需要注意Raster Space到NDC Space的变换（归一化到[0, 1]）；</p>
<p>以及NDC Space到Screen Space的变换（缩放到[-1, 1]）。</p>
<p><img data-fancybox="gallery" src="https://img-blog.csdnimg.cn/20210315153608594.png#pic_center" alt="将像素中间点的坐标转换为世界坐标需要几个步骤。这个点的坐标首先在光栅空间中表示(像素坐标加上0.5的偏移量)，然后转换到NDC空间(坐标被映射到范围[0,1])，然后转换到屏幕空间(NDC坐标被映射到[-1,1])。应用最终的相机到世界变换4x4矩阵变换屏幕空间的坐标到世界空间。" data-caption="将像素中间点的坐标转换为世界坐标需要几个步骤。这个点的坐标首先在光栅空间中表示(像素坐标加上0.5的偏移量)，然后转换到NDC空间(坐标被映射到范围[0,1])，然后转换到屏幕空间(NDC坐标被映射到[-1,1])。应用最终的相机到世界变换4x4矩阵变换屏幕空间的坐标到世界空间。" loading="lazy"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; scene.height; ++j)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; scene.width; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// generate primary ray direction</span></span><br><span class="line">        <span class="type">float</span> x;</span><br><span class="line">        <span class="type">float</span> y;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Find the x and y positions of the current pixel to get the direction</span></span><br><span class="line">        <span class="comment">// vector that passes through it.</span></span><br><span class="line">        <span class="comment">// Also, don&#x27;t forget to multiply both of them with the variable *scale*, and</span></span><br><span class="line">        <span class="comment">// x (horizontal) variable with the *imageAspectRatio*</span></span><br><span class="line">        <span class="comment">// https://blog.csdn.net/dong89801033/article/details/114834898?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162216944616780357298394%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=162216944616780357298394&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-2-114834898.pc_search_result_cache&amp;utm_term=games101%E4%BD%9C%E4%B8%9A5&amp;spm=1018.2226.3001.4187</span></span><br><span class="line">        x = (<span class="number">2</span> * (i + <span class="number">0.5</span>) / scene.width - <span class="number">1</span>) * scale * imageAspectRatio;</span><br><span class="line">        y = (<span class="number">1</span> - <span class="number">2</span> * (j + <span class="number">0.5</span>) / scene.height) * scale;      </span><br><span class="line"></span><br><span class="line">        Vector3f dir = <span class="built_in">Vector3f</span>(x, y, <span class="number">-1</span>); <span class="comment">// Don&#x27;t forget to normalize this direction!</span></span><br><span class="line">        <span class="comment">// norm()是返回二范数</span></span><br><span class="line">        <span class="comment">// normalize()是直接把自身的各元素除以二范数</span></span><br><span class="line">        <span class="comment">// normalized()是返回一个标准化的向量</span></span><br><span class="line">        dir = <span class="built_in">normalize</span>(dir);</span><br><span class="line">        framebuffer[m++] = <span class="built_in">castRay</span>(eye_pos, dir, scene, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">UpdateProgress</span>(j / (<span class="type">float</span>)scene.height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，Scale是用于缩放视场的变量；imageAspectRatio是宽高比，因为归一化到[-1, 1]之后可能会对图像造成拉伸，所以需要沿着x轴进行缩放。</p>
<p>From: x’ &#x2F; y &#x3D; width &#x2F; height &#x3D;  imageAspectRatio;</p>
<p>And x &#x3D; y;</p>
<p>Thus: x’ &#x3D; imageAspectRatio * x;</p>
<ol start="2">
<li>CastRay()</li>
</ol>
<p>①菲涅尔方程</p>
<p>②Phong Illuminating Model</p>
<p>③Lambert Cosine Law</p>
<ol start="3">
<li>rayTriangleIntersect()</li>
</ol>
<p>Moller_Trumbore：快速求出光线(origin_point &amp; direction)和三角形(v0, v1, v2)的交点。</p>
<ol start="4">
<li>结果：</li>
</ol>
<p><img data-fancybox="gallery" src="/images/GAMES101/output_05.png" alt="output" data-caption="output" loading="lazy"></p>
<h1 id="Hw06"><a href="#Hw06" class="headerlink" title="Hw06"></a>Hw06</h1><h2 id="2022-x2F-05-x2F-30"><a href="#2022-x2F-05-x2F-30" class="headerlink" title="2022&#x2F;05&#x2F;30"></a>2022&#x2F;05&#x2F;30</h2><h3 id="BVH加速求交："><a href="#BVH加速求交：" class="headerlink" title="BVH加速求交："></a>BVH加速求交：</h3><p>完成了<strong>BVH</strong>加速与物体求交的过程。</p>
<p>其中比较关键的是<strong>建树</strong>和求交这两个过程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建树</span></span><br><span class="line"><span class="function">BVHBuildNode* <span class="title">BVHAccel::recursiveBuild</span><span class="params">(std::vector&lt;Object*&gt; objects)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用new动态申请在heap的空间，需要手动delete，所以可以作为返回值</span></span><br><span class="line">    BVHBuildNode* node = <span class="keyword">new</span> <span class="built_in">BVHBuildNode</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute bounds of all primitives in BVH node</span></span><br><span class="line">    Bounds3 bounds;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; objects.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        bounds = <span class="built_in">Union</span>(bounds, objects[i]-&gt;<span class="built_in">getBounds</span>());</span><br><span class="line">    <span class="keyword">if</span> (objects.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// Create leaf _BVHBuildNode_</span></span><br><span class="line">        node-&gt;bounds = objects[<span class="number">0</span>]-&gt;<span class="built_in">getBounds</span>();</span><br><span class="line">        node-&gt;object = objects[<span class="number">0</span>];</span><br><span class="line">        node-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        node-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (objects.<span class="built_in">size</span>() == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 左值: std::vector&lt;Object*&gt; new_vec = &#123;objects[0]&#125;;</span></span><br><span class="line">        <span class="comment">// std::vector&#123;objects[0]&#125; 创建了一个右值</span></span><br><span class="line">        <span class="comment">// 之所以要这么写是因为这只是一个临时变量，之后用不到</span></span><br><span class="line">        <span class="comment">// 翻译一下传值的过程：</span></span><br><span class="line">        <span class="comment">// 1. 创建匿名变量 std::vector&#123;objects[0]&#125;</span></span><br><span class="line">        <span class="comment">// 2. 函数内：创建局部变量std::vector&lt;Object*&gt; objects = 匿名变量</span></span><br><span class="line">        <span class="comment">// 3. 复制Object* 类型数据objects[0]到objects内存所在区域（因为只是给指针赋值所以不会发生对象的拷贝构造）</span></span><br><span class="line">        node-&gt;left = <span class="built_in">recursiveBuild</span>(std::vector&#123;objects[<span class="number">0</span>]&#125;);</span><br><span class="line">        node-&gt;right = <span class="built_in">recursiveBuild</span>(std::vector&#123;objects[<span class="number">1</span>]&#125;);</span><br><span class="line"></span><br><span class="line">        node-&gt;bounds = <span class="built_in">Union</span>(node-&gt;left-&gt;bounds, node-&gt;right-&gt;bounds);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Bounds3 centroidBounds;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; objects.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            centroidBounds =</span><br><span class="line">                <span class="built_in">Union</span>(centroidBounds, objects[i]-&gt;<span class="built_in">getBounds</span>().<span class="built_in">Centroid</span>());</span><br><span class="line">        <span class="type">int</span> dim = centroidBounds.<span class="built_in">maxExtent</span>();</span><br><span class="line">        <span class="keyword">switch</span> (dim) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            std::<span class="built_in">sort</span>(objects.<span class="built_in">begin</span>(), objects.<span class="built_in">end</span>(), [](<span class="keyword">auto</span> f1, <span class="keyword">auto</span> f2) &#123;</span><br><span class="line">                <span class="keyword">return</span> f1-&gt;<span class="built_in">getBounds</span>().<span class="built_in">Centroid</span>().x &lt;</span><br><span class="line">                       f2-&gt;<span class="built_in">getBounds</span>().<span class="built_in">Centroid</span>().x;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            std::<span class="built_in">sort</span>(objects.<span class="built_in">begin</span>(), objects.<span class="built_in">end</span>(), [](<span class="keyword">auto</span> f1, <span class="keyword">auto</span> f2) &#123;</span><br><span class="line">                <span class="keyword">return</span> f1-&gt;<span class="built_in">getBounds</span>().<span class="built_in">Centroid</span>().y &lt;</span><br><span class="line">                       f2-&gt;<span class="built_in">getBounds</span>().<span class="built_in">Centroid</span>().y;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            std::<span class="built_in">sort</span>(objects.<span class="built_in">begin</span>(), objects.<span class="built_in">end</span>(), [](<span class="keyword">auto</span> f1, <span class="keyword">auto</span> f2) &#123;</span><br><span class="line">                <span class="keyword">return</span> f1-&gt;<span class="built_in">getBounds</span>().<span class="built_in">Centroid</span>().z &lt;</span><br><span class="line">                       f2-&gt;<span class="built_in">getBounds</span>().<span class="built_in">Centroid</span>().z;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> beginning = objects.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">auto</span> middling = objects.<span class="built_in">begin</span>() + (objects.<span class="built_in">size</span>() / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">auto</span> ending = objects.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> leftshapes = std::<span class="built_in">vector</span>&lt;Object*&gt;(beginning, middling);</span><br><span class="line">        <span class="keyword">auto</span> rightshapes = std::<span class="built_in">vector</span>&lt;Object*&gt;(middling, ending);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert</span>(objects.<span class="built_in">size</span>() == (leftshapes.<span class="built_in">size</span>() + rightshapes.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">        node-&gt;left = <span class="built_in">recursiveBuild</span>(leftshapes);</span><br><span class="line">        node-&gt;right = <span class="built_in">recursiveBuild</span>(rightshapes);</span><br><span class="line"></span><br><span class="line">        node-&gt;bounds = <span class="built_in">Union</span>(node-&gt;left-&gt;bounds, node-&gt;right-&gt;bounds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求交</span></span><br><span class="line"><span class="function">Intersection <span class="title">BVHAccel::getIntersection</span><span class="params">(BVHBuildNode* node, <span class="type">const</span> Ray&amp; ray)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// TODO Traverse the BVH to find intersection</span></span><br><span class="line">    Intersection isect;</span><br><span class="line">    <span class="keyword">if</span> (!node-&gt;bounds.<span class="built_in">IntersectP</span>(ray, ray.direction_inv, std::array&#123;(<span class="type">int</span>)ray.direction.x, (<span class="type">int</span>)ray.direction.y, (<span class="type">int</span>)ray.direction.z&#125;))</span><br><span class="line">        <span class="keyword">return</span> isect;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> node-&gt;object-&gt;<span class="built_in">getIntersection</span>(ray);</span><br><span class="line">    Intersection isect_r = <span class="built_in">getIntersection</span>(node-&gt;right, ray);</span><br><span class="line">    Intersection isect_l = <span class="built_in">getIntersection</span>(node-&gt;left, ray);</span><br><span class="line">    <span class="keyword">if</span> (!isect_r.happened &amp;&amp; !isect_l.happened) <span class="keyword">return</span> isect;</span><br><span class="line">    <span class="keyword">return</span> isect_r.distance &lt; isect_l.distance ? isect_r : isect_l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2022-x2F-05-x2F-31"><a href="#2022-x2F-05-x2F-31" class="headerlink" title="2022&#x2F;05&#x2F;31"></a>2022&#x2F;05&#x2F;31</h2><h3 id="SAH加速求交："><a href="#SAH加速求交：" class="headerlink" title="SAH加速求交："></a>SAH加速求交：</h3><ol>
<li>SAH加速的目标主要是在优化</li>
</ol>
<p>C &#x3D; Ctrav + SA&#x2F;SN * NA * Cisect + SB&#x2F;SN * NB * Cisect</p>
<p>这个时间开销上。</p>
<p>又因为，针对同一个父节点，不同划分方式下的子节点Ctrav、SN、Cisect 都相同，所以可以被省略掉，得到一个相对的时间开销：</p>
<p>C* &#x3D; SA * NA + SB * NB</p>
<ol start="2">
<li>于此同时，还可以通过将遍历的次数从N-1，缩小到确定值B来进行加速。<ol>
<li>具体来说，原本一共有N个objects，如果是按照原本的划分方法，一共有N-1次种划分方法，需要循环N-1次；但如果是限制为均匀划分为B个桶，那么只用循环B次。这里设置B为min(10, objects.size())。</li>
<li>要注意迭代器的使用时的边界问题。</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是均匀划分B个桶,这样的话,只用循环B次.</span></span><br><span class="line"><span class="comment">// 优化一下,objects.size()小于10的,那么B = objects.size().</span></span><br><span class="line"><span class="type">int</span> B = std::<span class="built_in">min</span>(<span class="number">10</span>, (<span class="type">int</span>)objects.<span class="built_in">size</span>());</span><br><span class="line"><span class="type">int</span> best_index = <span class="number">1</span>;</span><br><span class="line"><span class="type">double</span> best_time_cost = std::numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; B; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> separate_num = objects.<span class="built_in">size</span>() * i / B;</span><br><span class="line">    Bounds3 bounds_1, bounds_2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; objects.<span class="built_in">size</span>(); ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; separate_num) bounds_1 = <span class="built_in">Union</span>(bounds_1, objects[j]-&gt;<span class="built_in">getBounds</span>());</span><br><span class="line">        <span class="keyword">else</span> bounds_2 = <span class="built_in">Union</span>(bounds_2, objects[j]-&gt;<span class="built_in">getBounds</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> S1 = bounds_1.<span class="built_in">SurfaceArea</span>();</span><br><span class="line">    <span class="type">double</span> S2 = bounds_2.<span class="built_in">SurfaceArea</span>();</span><br><span class="line">    <span class="type">double</span> time_cost = S1 * separate_num + S2 * (objects.<span class="built_in">size</span>() - separate_num);</span><br><span class="line">    <span class="keyword">if</span> (time_cost &lt; best_time_cost)</span><br><span class="line">    &#123;</span><br><span class="line">        best_time_cost = time_cost;</span><br><span class="line">        best_index = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; best_index &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// beginning指向vector第一个元素</span></span><br><span class="line"><span class="comment">// ending指向vector最后一个元素的后面那个空位,而不是最后一位元素</span></span><br><span class="line"><span class="keyword">auto</span> beginning = objects.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> middling = objects.<span class="built_in">begin</span>() + objects.<span class="built_in">size</span>() * best_index / B;</span><br><span class="line"><span class="keyword">auto</span> ending = objects.<span class="built_in">end</span>();</span><br><span class="line"><span class="comment">// 注意,是取不到middling这个下标的,只取得到前一位(左闭右开)</span></span><br><span class="line"><span class="comment">// 所以迭代器begin()+i,下面这种构造方式内就只有i个元素</span></span><br><span class="line"><span class="keyword">auto</span> leftshapes = std::<span class="built_in">vector</span>&lt;Object*&gt;(beginning, middling);</span><br><span class="line"><span class="keyword">auto</span> rightshapes = std::<span class="built_in">vector</span>&lt;Object*&gt;(middling, ending);</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert</span>(objects.<span class="built_in">size</span>() == (leftshapes.<span class="built_in">size</span>() + rightshapes.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">node-&gt;left = <span class="built_in">recursiveBuild</span>(leftshapes);</span><br><span class="line">node-&gt;right = <span class="built_in">recursiveBuild</span>(rightshapes);</span><br><span class="line"></span><br><span class="line">node-&gt;bounds = <span class="built_in">Union</span>(node-&gt;left-&gt;bounds, node-&gt;right-&gt;bounds);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在求交的时候，依旧存在一个加速的方法。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> t_Min_x = (pMin.x - ray.origin.x)*invDir[<span class="number">0</span>];</span><br><span class="line"><span class="type">float</span> t_Min_y = (pMin.y - ray.origin.y)*invDir[<span class="number">1</span>];</span><br><span class="line"><span class="type">float</span> t_Min_z = (pMin.z - ray.origin.z)*invDir[<span class="number">2</span>];</span><br><span class="line"><span class="type">float</span> t_Max_x = (pMax.x - ray.origin.x)*invDir[<span class="number">0</span>];</span><br><span class="line"><span class="type">float</span> t_Max_y = (pMax.y - ray.origin.y)*invDir[<span class="number">1</span>];</span><br><span class="line"><span class="type">float</span> t_Max_z = (pMax.z - ray.origin.z)*invDir[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果发现射线的方向是反的，调换t_min和t_max的位置。</span></span><br><span class="line"><span class="keyword">if</span>(dirIsNeg[<span class="number">0</span>])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> t = t_Min_x;</span><br><span class="line">    t_Min_x = t_Max_x;</span><br><span class="line">    t_Max_x = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dirIsNeg[<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> t = t_Min_y;</span><br><span class="line">    t_Min_y = t_Max_y;</span><br><span class="line">    t_Max_y = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dirIsNeg[<span class="number">2</span>])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> t = t_Min_z;</span><br><span class="line">    t_Min_z = t_Max_z;</span><br><span class="line">    t_Max_z = t;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">float</span> t_enter = std::<span class="built_in">max</span>(t_Min_x, std::<span class="built_in">max</span>(t_Min_y, t_Min_z));</span><br><span class="line"><span class="type">float</span> t_exit  = std::<span class="built_in">min</span>(t_Max_x, std::<span class="built_in">min</span>(t_Max_y, t_Max_z));</span><br><span class="line"><span class="keyword">if</span>(t_enter &lt; t_exit &amp;&amp; t_exit &gt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>dirIsNeg的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Intersection <span class="title">BVHAccel::getIntersection</span><span class="params">(BVHBuildNode* node, <span class="type">const</span> Ray&amp; ray)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// TODO Traverse the BVH to find intersection</span></span><br><span class="line">    Intersection isect;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 3&gt; dirIsNeg;</span><br><span class="line">    dirIsNeg[<span class="number">0</span>] = ray.direction.x &lt; <span class="number">0</span>;</span><br><span class="line">    dirIsNeg[<span class="number">1</span>] = ray.direction.y &lt; <span class="number">0</span>;</span><br><span class="line">    dirIsNeg[<span class="number">2</span>] = ray.direction.z &lt; <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Note：IntersectP()参数最后是一个引用，这里这样写，是直接传了右值std::array&#123;(int)ray.direction.x, (int)ray.direction.y, (int)ray.direction.z&#125;</span></span><br><span class="line">    <span class="comment">// 和引用绑定。这样是不行的，因为右值的内存在语句结束后就会被释放，就算和引用绑定也没有用了。</span></span><br><span class="line">    <span class="comment">// 所以，函数的参数是指针或者引用的时候，不能传右值，只能传左值，因为不会开辟新的内存。&lt;传地址&gt;；</span></span><br><span class="line">    <span class="comment">// 同理，函数的参数传递如果是&lt;传值&gt;，那就可以传右值，因为是开辟了一个新的内存copy。</span></span><br><span class="line">    <span class="comment">// if (!node-&gt;bounds.IntersectP(ray, ray.direction_inv, std::array&#123;(int)ray.direction.x, (int)ray.direction.y, (int)ray.direction.z&#125;))</span></span><br><span class="line">    <span class="keyword">if</span> (!node-&gt;bounds.<span class="built_in">IntersectP</span>(ray, ray.direction_inv, dirIsNeg))</span><br><span class="line">        <span class="keyword">return</span> isect;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> node-&gt;object-&gt;<span class="built_in">getIntersection</span>(ray);</span><br><span class="line">    Intersection isect_r = <span class="built_in">getIntersection</span>(node-&gt;right, ray);</span><br><span class="line">    Intersection isect_l = <span class="built_in">getIntersection</span>(node-&gt;left, ray);</span><br><span class="line">    <span class="keyword">if</span> (!isect_r.happened &amp;&amp; !isect_l.happened) <span class="keyword">return</span> isect;</span><br><span class="line">    <span class="keyword">return</span> isect_r.distance &lt; isect_l.distance ? isect_r : isect_l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么可以用dir的正负来进行求交的加速呢？</strong></p>
<p>这里是由于，p &#x3D; t * dir + oringin，所以 t &#x3D; (p - origin) &#x2F; dir；</p>
<p>pmax点对应计算出的t_max 与 pmin点对应计算出的t_min的大小关系可以相减得到：</p>
<p>t_max - t_min &#x3D; (pmax - pmin) &#x2F; dir ①</p>
<p>又因为pmax的三维分量一定是 &gt; pmin的，所以式①的正负由dir的正负决定。且p_max一定 &gt; p_min，因此t_min ≠ t_max，因此t_min和t_max只有两种大小关系。</p>
<p>又因为x&#x2F;y&#x2F;z轴每个分量的t_min和t_max需要用于计算t_enter和t_exit，我们希望t_min代表进入对面，t_max代表离开对面，这就意味着t_min &lt; t_max一定需要成立。</p>
<p><strong>因此，若dir &gt; 0，那么计算出来的t_min &lt; t_max，满足我们的期望；反之，t_min &gt; t_max，与我们的期望不符合，所以需要将这两个值进行互换。</strong></p>
<h3 id="结果如下："><a href="#结果如下：" class="headerlink" title="结果如下："></a>结果如下：</h3><p>这里是没有加dir&lt;0判断加速的BVH耗时：</p>
<p><img data-fancybox="gallery" src="/images/GAMES101/RunTimeBVH.png" alt="RunTimeBVH" data-caption="RunTimeBVH" loading="lazy"></p>
<p>这里是使用了SAH，dir&lt;0，以及划分桶进行加速的耗时：</p>
<p><img data-fancybox="gallery" src="/images/GAMES101/RunTimeSAH.png" alt="RunTimeSAH" data-caption="RunTimeSAH" loading="lazy"></p>
<p>渲染结果如下图所示：</p>
<p><img data-fancybox="gallery" src="/images/GAMES101/output_BVH.png" alt="output_BVH" data-caption="output_BVH" loading="lazy"></p>
<p>BVH和加速之后的结果一样，这里只放一张。</p>
<h1 id="Hw07"><a href="#Hw07" class="headerlink" title="Hw07"></a>Hw07</h1><h2 id="2022-x2F-06-x2F-08"><a href="#2022-x2F-06-x2F-08" class="headerlink" title="2022&#x2F;06&#x2F;08"></a>2022&#x2F;06&#x2F;08</h2><p>完成了Path Tracing、多线程、Microfacet。</p>
<p>课程讲解主要是遵循diffuse的情况进行的。因此，代码中的material中关于BRDF和光线的采样，以及pdf都是有关联的。</p>
<p>diffuse的采样是在整个半球空间中进行的（因为漫反射方向是四面八方，且光线可逆，因此入射光线的采样方向也是四面八方），且是均匀采样，因此pdf &#x3D; 1&#x2F;2Π；</p>
<p>值得注意的是，因为方形的obj是面，可能会存在n和wo的夹角cos值&lt;0（也就是不在正半球方向上，夹角大于2&#x2F;Π）。其次，如果在triangle求交上，没有在原代码的基础上判断t &lt; 0的情况，那么渲染结果就会缺一角。</p>
<p>同时，在方向角上的积分应用diffuse的性质，可以得到BRDF的值等于abedo&#x2F;Π；abedo∈[0, 1]。</p>
<p><img data-fancybox="gallery" src="/images/GAMES101/t_wrong.png" alt="t_wrong" data-caption="t_wrong" loading="lazy"></p>
<p>因为这个渲染是在CPU上，所以可以用多线程来进行并行渲染，有两种方法，一种是使用thread库，另一种是使用omp库。注意不要忘记virtual box的cpu核心数需要修改。</p>
<p>注意两者写法上的不同。</p>
<p>在这里使用了匿名函数renderRows，具体来说，就是每个线程分配不同行数的像素进行渲染，因为需要写同一个变量，所以需要加互斥锁进行保护。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采样数/pixel</span></span><br><span class="line"><span class="type">int</span> spp = <span class="number">1024</span>;</span><br><span class="line"><span class="comment">// MSAA采样形状一定是方形</span></span><br><span class="line"><span class="type">int</span> size_msaa = <span class="built_in">sqrt</span>(spp);</span><br><span class="line"><span class="type">float</span> spp_step = <span class="number">1.f</span> / (<span class="type">float</span>)size_msaa;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;SPP: &quot;</span> &lt;&lt; spp &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="comment">// for (uint32_t j = 0; j &lt; scene.height; ++j) &#123;</span></span><br><span class="line"><span class="comment">//     for (uint32_t i = 0; i &lt; scene.width; ++i) &#123;</span></span><br><span class="line"><span class="comment">//         // generate primary ray direction</span></span><br><span class="line"><span class="comment">//         float x = (2 * (i + 0.5) / (float)scene.width - 1) *</span></span><br><span class="line"><span class="comment">//                   imageAspectRatio * scale;</span></span><br><span class="line"><span class="comment">//         float y = (1 - 2 * (j + 0.5) / (float)scene.height) * scale;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         Vector3f dir = normalize(Vector3f(-x, y, 1));</span></span><br><span class="line"><span class="comment">//         for (int k = 0; k &lt; spp; k++)&#123;</span></span><br><span class="line"><span class="comment">//             framebuffer[m] += scene.castRay(Ray(eye_pos, dir), 0) / spp;  </span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         m++;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     UpdateProgress(j / (float)scene.height);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="type">int</span> num_threads = <span class="number">16</span>;</span><br><span class="line"><span class="type">int</span> thread_height = scene.height / num_threads;</span><br><span class="line"><span class="comment">// ====================thread====================</span></span><br><span class="line"><span class="comment">// std::thread th[num_threads];</span></span><br><span class="line"><span class="comment">// auto renderRows = [&amp;](uint32_t start_height, uint32_t end_height)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     for (uint32_t j = start_height; j &lt; end_height; ++j)</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         for (uint32_t i = 0; i &lt; scene.width; ++i)</span></span><br><span class="line"><span class="comment">//         &#123;</span></span><br><span class="line"><span class="comment">//             // generate primary ray direction</span></span><br><span class="line"><span class="comment">//             // float x = (2 * (i + 0.5) / (float)scene.width - 1) *</span></span><br><span class="line"><span class="comment">//             //         imageAspectRatio * scale;</span></span><br><span class="line"><span class="comment">//             // float y = (1 - 2 * (j + 0.5) / (float)scene.height) * scale;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//             // Vector3f dir = normalize(Vector3f(-x, y, 1));</span></span><br><span class="line"><span class="comment">//             // for (int k = 0; k &lt; spp; k++)&#123;</span></span><br><span class="line"><span class="comment">//             //     framebuffer[(int)(j * scene.width + i)] += scene.castRay(Ray(eye_pos, dir), 0) / spp;  </span></span><br><span class="line"><span class="comment">//             // &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//             // MSAA 抗锯齿</span></span><br><span class="line"><span class="comment">//             for (int k = 0; k &lt; spp; k++)&#123;</span></span><br><span class="line"><span class="comment">//                 float x = (2.0f * (i + spp_step / 2.0f + k % size_msaa) / (float)scene.width - 1) *</span></span><br><span class="line"><span class="comment">//                         imageAspectRatio * scale;</span></span><br><span class="line"><span class="comment">//                 float y = (1 - 2.0f * (j + spp_step / 2.0f + k / size_msaa) / (float)scene.height) * scale;</span></span><br><span class="line"><span class="comment">//                 Vector3f dir = normalize(Vector3f(-x, y, 1));</span></span><br><span class="line"><span class="comment">//                 framebuffer[(int)(j * scene.width + i)] += scene.castRay(Ray(eye_pos, dir), 0) / spp;  </span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         mtx.lock();</span></span><br><span class="line"><span class="comment">//         progress++;</span></span><br><span class="line"><span class="comment">//         UpdateProgress(progress / (float)scene.height);</span></span><br><span class="line"><span class="comment">//         mtx.unlock();</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"><span class="comment">// for (int t = 0; t &lt; num_threads; ++t)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     th[t] = std::thread(renderRows, t * thread_height, (t + 1) * thread_height);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// for (int t = 0; t &lt; num_threads; ++t)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     th[t].join();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================OpenMP====================</span></span><br><span class="line"><span class="keyword">auto</span> renderRows = [&amp;](<span class="type">uint32_t</span> start_height, <span class="type">uint32_t</span> end_height)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> j = start_height; j &lt; end_height; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; scene.width; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// generate primary ray direction</span></span><br><span class="line">            <span class="comment">// float x = (2 * (i + 0.5) / (float)scene.width - 1) *</span></span><br><span class="line">            <span class="comment">//         imageAspectRatio * scale;</span></span><br><span class="line">            <span class="comment">// float y = (1 - 2 * (j + 0.5) / (float)scene.height) * scale;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Vector3f dir = normalize(Vector3f(-x, y, 1));</span></span><br><span class="line">            <span class="comment">// for (int k = 0; k &lt; spp; k++)&#123;</span></span><br><span class="line">            <span class="comment">//     framebuffer[(int)(j * scene.width + i)] += scene.castRay(Ray(eye_pos, dir), 0) / spp;  </span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// MSAA 抗锯齿</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; spp; k++)&#123;</span><br><span class="line">                <span class="type">float</span> x = (<span class="number">2.0f</span> * (i + spp_step / <span class="number">2.0f</span> + spp_step * (k % size_msaa)) / (<span class="type">float</span>)scene.width - <span class="number">1</span>) *</span><br><span class="line">                    imageAspectRatio * scale;</span><br><span class="line">                <span class="type">float</span> y = (<span class="number">1</span> - <span class="number">2.0f</span> * (j + spp_step / <span class="number">2.0f</span> + spp_step * (k / size_msaa)) / (<span class="type">float</span>)scene.height) * scale;</span><br><span class="line">                Vector3f dir = <span class="built_in">normalize</span>(<span class="built_in">Vector3f</span>(-x, y, <span class="number">1</span>));</span><br><span class="line">                framebuffer[(<span class="type">int</span>)(j * scene.width + i)] += scene.<span class="built_in">castRay</span>(<span class="built_in">Ray</span>(eye_pos, dir), <span class="number">0</span>) / spp;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">omp_set_lock</span>(&amp;lock1);</span><br><span class="line">        progress++;</span><br><span class="line">        <span class="built_in">UpdateProgress</span>(progress / (<span class="type">float</span>)scene.height);</span><br><span class="line">        <span class="built_in">omp_unset_lock</span>(&amp;lock1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt; num_threads; ++t)</span><br><span class="line">    <span class="built_in">renderRows</span>(t * thread_height, (t + <span class="number">1</span>) * thread_height);</span><br><span class="line"></span><br><span class="line"><span class="built_in">UpdateProgress</span>(<span class="number">1.f</span>);</span><br></pre></td></tr></table></figure>

<p>除此之外，需要将CmakeList.txt中加上对应的部分。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &lt;OpenMP&gt;</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CAMKE_CXX_FLAGS&#125; -O3 -fopenmp&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;thread&gt;</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(RayTracing pthread)</span><br></pre></td></tr></table></figure>

<p>同时，需要在框架提供的随机数生成函数中，将三个局部变量设置为static类型，从而减少运行时间：</p>
<p><img data-fancybox="gallery" src="/images/GAMES101/without_static.png" alt="without_static" data-caption="without_static" loading="lazy"></p>
<p>加之前</p>
<p><img data-fancybox="gallery" src="/images/GAMES101/with_static.png" alt="with_static" data-caption="with_static" loading="lazy"></p>
<p>加之后</p>
<p><img data-fancybox="gallery" src="/images/GAMES101/without_MSAA.png" alt="without_MSAA" data-caption="without_MSAA" loading="lazy"></p>
<p>纯镜面反射存在过度曝光问题：</p>
<p><img data-fancybox="gallery" src="/images/GAMES101/specular_wrong.png" alt="specular_wrong" data-caption="specular_wrong" loading="lazy"></p>
<h2 id="2022-x2F-06-x2F-11"><a href="#2022-x2F-06-x2F-11" class="headerlink" title="2022&#x2F;06&#x2F;11"></a>2022&#x2F;06&#x2F;11</h2><p>解决了specular材质的<strong>过度曝光</strong>问题。</p>
<p>首先，思考一下<strong>为什么会产生过度曝光</strong>？因为框架里面的path tracing是根据理想漫反射的情况分为了dir和indir两个部分。然而specular沿用这个框架，在对直接光照进行采样的时候只判断了n和wo的cos是否大于0，而没有判断是否满足镜面反射，所以只要采样的是光源，满足cos&gt;0的全部都加了起来，因此过曝了。</p>
<p>其次，再回顾一下，为什么需要拆分两个部分呢？因为引入了RR之后，如果只对立体角进行采样，那么有一种可能是循环停止时还采样不到光源，那么什么能量都没有，会造成巨大的浪费产生噪声，只能通过增大spp来减小噪声。</p>
<p>如果是理想diffuse上对立体角均匀采样的情况，造成的浪费只会是①dir中ray被物体挡住，以及②indir采到了光源或没碰到物体。</p>
<p>如果使用的是ggx(Microfacet)，对立体角均匀采样，浪费除了①和②，还会有③光线分布不符合D(h)。</p>
<p>之所以diffuse的浪费不包括③，是因为diffuse的D(h)本身就是均匀分布的，在半球上永远会被满足，这是性质，也是前提。</p>
<p>故，为了避免浪费③，才会引入重要性采样（猜测）。而diffuse的pdf和它在Microfacet中对应D(h)的形状是一样的，因此本身就满足了重要性采样的特点。</p>
<h3 id="Specular的采样与pdf："><a href="#Specular的采样与pdf：" class="headerlink" title="Specular的采样与pdf："></a>Specular的采样与pdf：</h3><p>(1)只向镜面方向采样，对应概率为1(不是pdf)，根据D(h)进行重要性采样</p>
<p>采样方向：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SPECULAR:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 只采样 镜面反射方向</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reflect</span>(wi, N);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置对应的pdf为1，而不是∞，因为会被δ(wi-wr)抵消（后面会解释）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SPECULAR:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dotProduct</span>(wo, N) &gt; <span class="number">0.0f</span>) <span class="keyword">return</span> <span class="number">1.0f</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	1)改写BRDF(×): 因为框架拆分了dir和indir，BRDF内部需要判断sampleLight生成的方向是否与wi是关于N对称的，相对来说，判断两个量是否相等是非常困难的，往往需要用差值与一个很小的EPSILON对比，这样会造成误差，所以不能这样做。</p>
<p>​	2)改写Path Tracing(√): 将拆分了dir和indir的框架退化为不拆分的基本框架，依旧引入RR，但是因为引入了重要性采样，所以不会造成浪费。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SPECULAR:</span><br><span class="line">&#123;</span><br><span class="line">    Vector3f L = &#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>&#125;;</span><br><span class="line">    <span class="comment">// 俄罗斯赌盘 是否继续采样</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">get_random_float</span>() &gt; RussianRoulette) <span class="keyword">return</span> L;</span><br><span class="line">    <span class="comment">// 对立体角采样 实际只有一个方向</span></span><br><span class="line">    Vector3f wi = p.m-&gt;<span class="built_in">sample</span>(ray.direction, p.normal);</span><br><span class="line">    <span class="type">float</span> pdf = p.m-&gt;<span class="built_in">pdf</span>(ray.direction, wi, p.normal);</span><br><span class="line">    <span class="function">Ray <span class="title">ray_i_indir</span><span class="params">(p.coords, wi)</span></span>;</span><br><span class="line">    Intersection q = <span class="built_in">intersect</span>(ray_i_indir);</span><br><span class="line">    <span class="keyword">if</span> (q.happened)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> div = pdf * RussianRoulette;</span><br><span class="line">        L = <span class="built_in">castRay</span>(ray_i_indir, ++depth) * p.m-&gt;<span class="built_in">eval</span>(ray.direction, wi, p.normal) * <span class="built_in">dotProduct</span>(wi, p.normal) / std::<span class="built_in">max</span>(div , EPSILON);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2)纯镜面反射的BRDF推导：</p>
<p><img data-fancybox="gallery" src="/images/GAMES101/BRDF_1.jpg" alt="BRDF_1" data-caption="BRDF_1" loading="lazy"></p>
<p><img data-fancybox="gallery" src="/images/GAMES101/BRDF_2.jpg" alt="BRDF_2" data-caption="BRDF_2" loading="lazy"></p>
<p>从上面我们可以看到，不论是重要性采样，还是均匀采样，都可以得到正确的结果，这也是为什么MC方法的分母不管取什么形状的pdf都一定无偏的原因，但是同时我们也知道，如果使用均匀采样(均匀采样的时候，BRDF项需要判断wi和wr是否相等，如果不相等，那么返回值为0，因为重要性采样的时候已经满足了相等的绝对条件，但是记住，判断相等是非常麻烦的一件事)，那么造成的浪费会很大，尤其是这种纯镜面反射的情况(必须要进行非常多的采样，才能采样到镜面方向)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SPECULAR:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Specular只考虑fresnel和delta函数(D(h))</span></span><br><span class="line">    <span class="comment">// 这里 wi一定是和wo相对于n对称的 所以delta函数值一定是∞</span></span><br><span class="line">    <span class="type">float</span> cosalpha = <span class="built_in">dotProduct</span>(N, wo);</span><br><span class="line">    <span class="keyword">if</span> (cosalpha &gt; <span class="number">0.0f</span>) &#123;</span><br><span class="line">        <span class="type">float</span> kr;</span><br><span class="line">        <span class="built_in">fresnel</span>(wi, N, ior, kr);</span><br><span class="line">        <span class="comment">// 是根据全镜面反射的定义来的</span></span><br><span class="line">        <span class="comment">// Lo = Fresnel * Li(i与r关于n对称)</span></span><br><span class="line">        Vector3f specular = kr / std::<span class="built_in">max</span>(cosalpha, EPSILON);</span><br><span class="line">        <span class="keyword">return</span> specular;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Vector3f</span>(<span class="number">0.0f</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里原本fr&#x3D;δ(wi-wr)*F&#x2F;cosθi，但是由于wi&#x3D;&#x3D;wr，所以冲激函数值为∞，它理论上会被渲染方程里面的pdf所抵消，所以这里也和pdf一样设置为1即可。</p>
<p>渲染结果(spp&#x3D;10000)：</p>
<p><img data-fancybox="gallery" src="/images/GAMES101/specular.png" alt="specular" data-caption="specular" loading="lazy"></p>
<h3 id="MSAA-抗锯齿"><a href="#MSAA-抗锯齿" class="headerlink" title="MSAA 抗锯齿"></a>MSAA 抗锯齿</h3><p>在没有实现MSAA的情况下，可以看到边缘会有走样的现象。</p>
<p>因此，参考MSAA的思想，将pixel平均分为spp个方格(super sampling)，向方格中心发射ray进行采样，然后取平均(blur)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MSAA 抗锯齿</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; spp; k++)&#123;</span><br><span class="line">    <span class="type">float</span> x = (<span class="number">2.0f</span> * (i + spp_step / <span class="number">2.0f</span> + spp_step * (k % size_msaa)) / (<span class="type">float</span>)scene.width - <span class="number">1</span>) *</span><br><span class="line">        imageAspectRatio * scale;</span><br><span class="line">    <span class="type">float</span> y = (<span class="number">1</span> - <span class="number">2.0f</span> * (j + spp_step / <span class="number">2.0f</span> + spp_step * (k / size_msaa)) / (<span class="type">float</span>)scene.height) * scale;</span><br><span class="line">    Vector3f dir = <span class="built_in">normalize</span>(<span class="built_in">Vector3f</span>(-x, y, <span class="number">1</span>));</span><br><span class="line">    framebuffer[(<span class="type">int</span>)(j * scene.width + i)] += scene.<span class="built_in">castRay</span>(<span class="built_in">Ray</span>(eye_pos, dir), <span class="number">0</span>) / spp;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：可以看到边缘确实没有锯齿了。</p>
<p><img data-fancybox="gallery" src="/images/GAMES101/MSAA.png" alt="MSAA" data-caption="MSAA" loading="lazy"></p>
<h3 id="GGX-不完整，没推导公式"><a href="#GGX-不完整，没推导公式" class="headerlink" title="GGX (不完整，没推导公式)"></a>GGX (不完整，没推导公式)</h3><p>根据OpenGL教程来编写GGX的Fresnel、D(h)和G(i, o, n)函数。</p>
<p>引入了roughness(影响D以及G值)以及metalness(影响F值)两个参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://learnopengl.com/PBR/Theory</span></span><br><span class="line"><span class="comment">// https://blog.csdn.net/weixin_44518102/article/details/122698851?spm=1001.2101.3001.6650.9&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-9.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-9.pc_relevant_default&amp;utm_relevant_index=12</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">DistributionGGX</span><span class="params">(<span class="type">const</span> Vector3f&amp; N, <span class="type">const</span> Vector3f&amp; H, <span class="type">const</span> <span class="type">float</span>&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> a2 = a * a;</span><br><span class="line">    <span class="type">float</span> NdotH = std::<span class="built_in">max</span>(<span class="built_in">dotProduct</span>(N, H), <span class="number">0.0f</span>);</span><br><span class="line">    <span class="type">float</span> NdotH2 = NdotH * NdotH;</span><br><span class="line">    <span class="type">float</span> nom = a2;</span><br><span class="line">    <span class="type">float</span> denom = (NdotH2 * (a2 - <span class="number">1.0f</span>) + <span class="number">1.0f</span>);</span><br><span class="line">    denom = M_PI * denom * denom;</span><br><span class="line">    <span class="comment">// prevent divide by zero for roughness=0.0 and NdotH=1.0</span></span><br><span class="line">    <span class="keyword">return</span> nom / std::<span class="built_in">max</span>(denom, EPSILON);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">GeometrySchlickGGX</span><span class="params">(<span class="type">const</span> <span class="type">float</span>&amp; NdotV, <span class="type">const</span> <span class="type">float</span>&amp; k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> nom = NdotV;</span><br><span class="line">    <span class="type">float</span> denom = NdotV * (<span class="number">1.0f</span> - k) + k;</span><br><span class="line">    <span class="keyword">return</span> nom / denom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">GeometrySmith</span><span class="params">(<span class="type">const</span> Vector3f&amp; N, <span class="type">const</span> Vector3f&amp; V, <span class="type">const</span> Vector3f&amp; L, <span class="type">const</span> <span class="type">float</span>&amp; k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> NdotV = std::<span class="built_in">max</span>(<span class="built_in">dotProduct</span>(N, V), <span class="number">0.0f</span>);</span><br><span class="line">    <span class="type">float</span> NdotL = std::<span class="built_in">max</span>(<span class="built_in">dotProduct</span>(N, L), <span class="number">0.0f</span>);</span><br><span class="line">    <span class="type">float</span> ggx1 = <span class="built_in">GeometrySchlickGGX</span>(NdotV, k);</span><br><span class="line">    <span class="type">float</span> ggx2 = <span class="built_in">GeometrySchlickGGX</span>(NdotL, k);</span><br><span class="line">    <span class="keyword">return</span> ggx1 * ggx2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Vector3f <span class="title">fresnelSchlick</span><span class="params">(<span class="type">float</span>&amp; cosTheta, Vector3f&amp; F0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> F0 + (<span class="built_in">Vector3f</span>(<span class="number">1.0f</span>) - F0) * <span class="built_in">pow</span>(<span class="number">1.0f</span> - cosTheta, <span class="number">5.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的BRDF：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> GGX:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. Ks 是 Specular 系数，其实就是 DFG 中的F，也就是菲涅尔项。</span></span><br><span class="line">    <span class="comment">// 2. 框架中定义的 Kd 其实是 Color，在 Microfacet 中，Kd 的值应该是 1-Ks。</span></span><br><span class="line">    <span class="comment">// 3. 最后得到的 fr = Kd * fr_diffuse + Ks * fr_specular。也就是要分别计算漫反射部分和高光部分，</span></span><br><span class="line">    <span class="comment">// 所以不要只顾计算 DFG 而忘了前面的漫反射部分。</span></span><br><span class="line">    <span class="comment">// 4. 推荐看一下论坛上关于 Microfacet 讨论的这篇帖子，里面提到了很多典型问题，非常有启发性。</span></span><br><span class="line">    <span class="comment">// 5. （2021年8月17日 更新）重点： 在GAME202 第10讲的最后，闫老师批驳了这种使用 Kd 做光照损失补偿的计算方法，</span></span><br><span class="line">    <span class="comment">// 称其没有任何物理原理可言。使用 Microfacet 方法会导致物体变暗，尤其是 Roughness值较大的物体会变得很暗，</span></span><br><span class="line">    <span class="comment">// 主要原因是因为在计算时没有计算多次光线弹射导致的能量损失。闫老师在 GAMES202 中介绍了 Kulla-Conty 方法</span></span><br><span class="line">    <span class="comment">// 可以用于在实时渲染中进行能量补偿，可以参考。B站评论上有人说使用环境光进行补偿的方式是工业界经常使用的一种近似计算方法，</span></span><br><span class="line">    <span class="comment">// 不过个人感觉既然是在做学术界的作业，还是不要使用这在学术界上没有意义的计算方法。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Normal Distribution Function</span></span><br><span class="line">    <span class="comment">// 粗糙度</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dotProduct</span>(wo, N) &gt; <span class="number">0.0f</span>) &#123;</span><br><span class="line">        Vector3f V = -wi;</span><br><span class="line">        Vector3f L = wo;</span><br><span class="line">        Vector3f H = <span class="built_in">normalize</span>(V + L);</span><br><span class="line">        <span class="type">float</span> D = <span class="built_in">DistributionGGX</span>(N, H, roughness);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Geometry Function</span></span><br><span class="line">        <span class="type">float</span> G = <span class="built_in">GeometrySmith</span>(N, V, L, k);</span><br><span class="line"></span><br><span class="line">        <span class="function">Vector3f <span class="title">F0</span><span class="params">(<span class="number">0.04f</span>)</span></span>;</span><br><span class="line">        F0 = F0 * (<span class="number">1.0f</span> - metalness) + Kd * metalness;</span><br><span class="line">        <span class="type">float</span> cosTheta = <span class="built_in">dotProduct</span>(V, N);</span><br><span class="line">        Vector3f F = <span class="built_in">fresnelSchlick</span>(cosTheta, F0);</span><br><span class="line">        Vector3f ks_ = F;<span class="comment">//反射比率</span></span><br><span class="line">        Vector3f kd_ = <span class="built_in">Vector3f</span>(<span class="number">1.0f</span>) - ks_;<span class="comment">//折射比率</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// float F;</span></span><br><span class="line">        <span class="comment">// float etat = 1.85;</span></span><br><span class="line">        <span class="comment">// fresnel(wi, N, etat, F);</span></span><br><span class="line">        <span class="comment">// // 能量守恒</span></span><br><span class="line">        <span class="comment">// float ks_ = F;//反射比率</span></span><br><span class="line">        <span class="comment">// float kd_ = 1.0f - ks_;//折射比率</span></span><br><span class="line"></span><br><span class="line">        Vector3f diffuse = <span class="number">1.0f</span> / M_PI;</span><br><span class="line">        Vector3f nominator = D * G * F;</span><br><span class="line">        <span class="type">float</span> denominator = <span class="number">4.0f</span> * <span class="built_in">dotProduct</span>(N, V) * <span class="built_in">dotProduct</span>(N, L);</span><br><span class="line">        Vector3f specular = nominator / std::<span class="built_in">max</span>(denominator, EPSILON);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为在 specular 项里已经考虑了反射部分的比例：F。所以反射部分不需要再乘以 ks_ </span></span><br><span class="line">        <span class="comment">// Ks为镜面反射项，Kd为漫反射项。</span></span><br><span class="line">        <span class="comment">// return Ks * specular + kd_ * Kd * diffuse;</span></span><br><span class="line">        <span class="keyword">return</span> specular + kd_ * diffuse;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Vector3f</span>(<span class="number">0.0f</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看一个ggx一个specular的效果，roughness&#x3D;0.1，metalness&#x3D;1.0：</p>
<p><img data-fancybox="gallery" src="/images/GAMES101/specular_ggx.png" alt="specular_ggx" data-caption="specular_ggx" loading="lazy"></p>
<h3 id="重要性采样-还没做"><a href="#重要性采样-还没做" class="headerlink" title="重要性采样  (还没做)"></a>重要性采样  (还没做)</h3><h3 id="Gamma矫正-还没做"><a href="#Gamma矫正-还没做" class="headerlink" title="Gamma矫正 (还没做)"></a>Gamma矫正 (还没做)</h3>
  </article>

  
      
    <div class="nexmoe-post-copyright">
        <strong>Author：</strong>John Doe<br>
        <strong>Link：</strong><a href="http://example.com/2022/11/01/GAMES101/" title="http:&#x2F;&#x2F;example.com&#x2F;2022&#x2F;11&#x2F;01&#x2F;GAMES101&#x2F;" target="_blank" rel="noopener">http:&#x2F;&#x2F;example.com&#x2F;2022&#x2F;11&#x2F;01&#x2F;GAMES101&#x2F;</a><br>
        
            <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
        
    </div>


  
  
  <div class="nexmoe-post-meta nexmoe-rainbow">
    
    
        <a class="nexmoefont icon-tag-fill -none-link" href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6-GAMES101%E4%BD%9C%E4%B8%9A/" rel="tag">图形学 GAMES101作业</a>
    
</div>

  
      <div class="nexmoe-post-footer">
          <section class="nexmoe-comment">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.css">
<div id="gitalk"></div>
<script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '80b2453b6d5f37ad6225',
        clientSecret: '43e99fa852795c9a7b3eb924b2558c64b84bbdeb',
        id: window.location.pathname,
        repo: 'nexmoe.github.io',
        owner: 'nexmoe',
        admin: 'nexmoe'
    })
    gitalk.render('gitalk')
</script>
</section>
      </div>
  
</div>
            <div class="nexmoe-post-right">
              <div class="nexmoe-fixed">
                  <div class="nexmoe-tool"> 
                    
                      
                    
                      <a href="#nexmoe-content" class="toc-link" aria-label="回到顶部" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
                  </div>
              </div>
            </div>
        </div>
    </div>
     
    <div id="nexmoe-search-space">
        <div class="search-container">
            <div class="search-header">
                <div class="search-input-container">
                    <input class="search-input" type="text" placeholder="Search" oninput="sinput();">
                </div>
                <a class="search-close" onclick="sclose();">×</a>
            </div>
            <div class="search-body"></div>
        </div>
    </div>

    
<script src="/lib/mdui_043tiny/mdui.js"></script>
<script src="/lib/jquery.min.js"></script>
<script src="/lib/justifiedGallery/jquery.justifiedGallery.min.js"></script>
<script src="/lib/fancybox/fancybox.umd.js"></script>


 

<script async src="/js/app.js?v=1667310560021"></script>



<script>
	$(".justified-gallery").justifiedGallery({
		rowHeight: 160,
		margins: 10,
	});
</script>


    





</body>

</html>
