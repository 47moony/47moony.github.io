<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>GAMES101 | Moony's World</title><meta name="author" content="Moony"><meta name="copyright" content="Moony"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="GAMES101Studies for GAMES101. Hw01向量绕任意轴旋转的简单推导 | Sulley图形学中有关旋转的一个问题是，一个（三维空间的）向量绕一个任意轴旋转若干角度后的角度是什么。本文简单进行推导，给出显式结果。 方法一：向量分解推导过程首先介绍一个最容易理解的方法——向量分解。假设要旋转的向量是p，要旋转的轴是n，是一个单位向量，要旋转的角度是θ。再设旋转后的轴是p′。">
<meta property="og:type" content="article">
<meta property="og:title" content="GAMES101">
<meta property="og:url" content="http://example.com/2022/11/01/GAMES101/index.html">
<meta property="og:site_name" content="Moony&#39;s World">
<meta property="og:description" content="GAMES101Studies for GAMES101. Hw01向量绕任意轴旋转的简单推导 | Sulley图形学中有关旋转的一个问题是，一个（三维空间的）向量绕一个任意轴旋转若干角度后的角度是什么。本文简单进行推导，给出显式结果。 方法一：向量分解推导过程首先介绍一个最容易理解的方法——向量分解。假设要旋转的向量是p，要旋转的轴是n，是一个单位向量，要旋转的角度是θ。再设旋转后的轴是p′。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-11-01T13:13:51.000Z">
<meta property="article:modified_time" content="2023-01-10T05:05:48.104Z">
<meta property="article:author" content="Moony">
<meta property="article:tag" content="图形学">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/11/01/GAMES101/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'GAMES101',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-01-10 13:05:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Moony's World</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">GAMES101</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-11-01T13:13:51.000Z" title="Created 2022-11-01 21:13:51">2022-11-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-01-10T05:05:48.104Z" title="Updated 2023-01-10 13:05:48">2023-01-10</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="GAMES101"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="GAMES101"><a href="#GAMES101" class="headerlink" title="GAMES101"></a>GAMES101</h1><p>Studies for GAMES101.</p>
<h1 id="Hw01"><a href="#Hw01" class="headerlink" title="Hw01"></a>Hw01</h1><h2 id="向量绕任意轴旋转的简单推导-Sulley"><a href="#向量绕任意轴旋转的简单推导-Sulley" class="headerlink" title="向量绕任意轴旋转的简单推导 | Sulley"></a><a target="_blank" rel="noopener" href="https://sulley.cc/2021/06/07/%E5%90%91%E9%87%8F%E7%BB%95%E4%BB%BB%E6%84%8F%E8%BD%B4%E6%97%8B%E8%BD%AC%E7%9A%84%E7%AE%80%E5%8D%95%E6%8E%A8%E5%AF%BC/">向量绕任意轴旋转的简单推导 | Sulley</a></h2><p>图形学中有关旋转的一个问题是，一个（三维空间的）向量绕一个任意轴旋转若干角度后的角度是什么。本文简单进行推导，给出显式结果。</p>
<h2 id="方法一：向量分解"><a href="#方法一：向量分解" class="headerlink" title="方法一：向量分解"></a>方法一：向量分解</h2><h3 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h3><p>首先介绍一个最容易理解的方法——向量分解。假设要旋转的向量是p，要旋转的轴是n，是一个单位向量，要旋转的角度是θ。再设旋转后的轴是p′。</p>
<p>现在我们把p分解为两个向量，一个平行于n，另一个垂直于n，即：p&#x3D;p⊥+p∥容易知道，平行于n的分向量p∥就是p在n上的投影（推导过程略）：p∥&#x3D;(n⋅p)n从而就能得到p⊥：p⊥&#x3D;p−p∥同样地可以将旋转后的向量分解：p′&#x3D;p⊥′+p∥′显然，旋转后的向量对应的平行分量p∥′是不变的：p∥′&#x3D;p∥这里的关键在于求垂直分量p⊥′。</p>
<p><a target="_blank" rel="noopener" href="https://sulley.cc/images/arbitrary_rotation/1.png"><img src="https://sulley.cc/images/arbitrary_rotation/1.png" alt="将向量分解为一个平行向量和一个垂直向量"></a></p>
<p><em>将向量分解为一个平行向量和一个垂直向量</em></p>
<p>根据已知的旋转轴n，我们就知道它对应的平面V，而向量p与p′的垂直分量就在该平面内。该平面的维度是2，因此只需要找到两个基向量，就可以通过这两个基向量的线性组合表示该平面的任意向量。</p>
<p>其中一个基向量我们已经找到了，就是p⊥，而另一个我们可以通过n与p⊥的叉乘实现，得到的向量与n和p⊥垂直，且在平面V内。且注意到：n×p⊥&#x3D;n×(p−p∥)&#x3D;n×p−n×p∥&#x3D;n×p并且有：‖n×p‖&#x3D;‖n×p⊥‖&#x3D;‖n‖⋅‖p⊥‖⋅sin⁡(π&#x2F;2)&#x3D;‖p⊥‖进而我们能导出旋转后的垂直分量p⊥′：p⊥′&#x3D;cos⁡(θ)‖p⊥‖⋅p⊥‖p⊥‖+sin⁡(θ)‖p⊥‖⋅n×p‖n×p‖&#x3D;cos⁡(θ)p⊥+sin⁡(θ)(n×p)最后，我们得到旋转后的向量p′：</p>
<p>p′&#x3D;p⊥′+p∥′&#x3D;cos⁡(θ)p⊥+sin⁡(θ)(n×p)+p∥&#x3D;cos⁡(θ)(p−p∥)+p∥+sin⁡(θ)(n×p)&#x3D;cos⁡(θ)p+(1−cos⁡(θ))(n⋅p)n+sin⁡(θ)(n×p)</p>
<p>搞定！</p>
<h3 id="矩阵形式"><a href="#矩阵形式" class="headerlink" title="矩阵形式"></a>矩阵形式</h3><p>我们知道向量的叉乘可以表示为：n×p&#x3D;[0−nznynz0−nx−nynx0]p&#x3D;Np注意到，矩阵N有如下的性质：N(Np)&#x3D;N2p&#x3D;n×(n×p)所以我们可以把旋转公式写成下述形式：p′&#x3D;p+(1−cos⁡(θ))N2p+sin⁡(θ)Np&#x3D;Rp其中R&#x3D;I+sin⁡(θ)N+(1−cos⁡(θ))N2。上面的等式需要注意到(n⋅p)n&#x3D;p+N2p。</p>
<p>所以，使用Rodrigues’旋转公式，只需要首先令N&#x3D;[0−nznynz0−nx−nynx0]，然后再计算R&#x3D;I+sin⁡(θ)N+(1−cos⁡(θ))N2，就能得到旋转后的向量为p′&#x3D;Rp。</p>
<h2 id="方法二：坐标轴对齐"><a href="#方法二：坐标轴对齐" class="headerlink" title="方法二：坐标轴对齐"></a>方法二：坐标轴对齐</h2><p>既然直接绕着任意轴旋转比较困难，那为啥不先进行整个空间的旋转，把旋转轴旋转为坐标轴，这样就能把向量绕任意轴旋转转化为向量绕标准坐标轴旋转。这就是我们非常熟悉的问题了。</p>
<p>假定我们考虑的是三维空间的旋转（对更高维的情况容易推论），即标准坐标系为x&#x3D;(1,0,0),y&#x3D;(0,1,0),z&#x3D;(0,0,1)。我们有旋转轴n,‖n‖&#x3D;1和待旋转向量p。</p>
<p>首先，我们构建一个坐标系u,v,w，该坐标系的一个轴就是n，我们利用叉乘实现：</p>
<p>u&#x3D;n,v&#x3D;n×p‖n×p‖,w&#x3D;n×v</p>
<p>现在，我们要把坐标轴u,v,w分别旋转到坐标轴x,y,z的位置，这可以用下面的旋转矩阵实现：</p>
<p>Q&#x3D;[uvw]&#x3D;[xuyuzuxvyvzvxwywzw]</p>
<p>很容易验证：x&#x3D;Qu,y&#x3D;Qv,z&#x3D;Qw，从而就有I&#x3D;QQ⊤&#x3D;Q⊤Q，这就验证了Q是正交的。</p>
<p>现在，原来的向量p就变成了Qp，原来绕n旋转（也就是绕u旋转）就变成了绕x旋转，而我们知道绕x轴旋转θ的旋转矩阵是：T&#x3D;[1000cos⁡(θ)−sin⁡(θ)0sin⁡(θ)cos⁡(θ)]因此，旋转后的向量就是TQp。现在，只需要把旋转后的向量再旋转回原来的位置就好了，我们只需要再乘以Q的逆即可。由于Q是正交的，所以有Q−1&#x3D;Q⊤。把上面的结果合起来，就能得到最终的结果是：p′&#x3D;Q⊤TQp</p>
<h3 id="检验"><a href="#检验" class="headerlink" title="检验"></a>检验</h3><p>现在我们用代码来检验一下上述三种方法是否能得到同样的结果，以及它们的运算效率如何。比较的方法包括： 1. 向量分解-向量形式 2. 向量分解-矩阵形式 3. 对标轴对齐</p>
<p>程序在虚拟机上运行，RAM为4G，硬盘20G，处理器为2个Intel Core i5-10400F CPU @ 2.90GHz。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;eigen3/Eigen/Eigen&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.1415926</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rotation using vector decomposation - the vector form</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DecomposeVector</span><span class="params">(<span class="type">const</span> Eigen::Vector3f &amp;n, <span class="type">const</span> Eigen::Vector3f &amp;p, <span class="type">float</span> angle)</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> rotationAngle = angle / <span class="number">180.0</span> * PI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> startTime = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">Eigen::Vector3f rotatedVector = <span class="built_in">cos</span>(rotationAngle) * p </span><br><span class="line">                                + (<span class="number">1</span> - <span class="built_in">cos</span>(rotationAngle)) * (n.<span class="built_in">dot</span>(p)) * n </span><br><span class="line">                                + <span class="built_in">sin</span>(rotationAngle) * (n.<span class="built_in">cross</span>(p));</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> endTime = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="type">double</span> deltaTime = std::chrono::<span class="built_in">duration</span>&lt;<span class="type">double</span>, std::milli&gt;(endTime-startTime).<span class="built_in">count</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Method: vector decomposition - the vector form. The rotated vector p&#x27; is (&quot;</span> </span><br><span class="line">     &lt;&lt; <span class="built_in">rotatedVector</span>(<span class="number">0</span>) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">rotatedVector</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">rotatedVector</span>(<span class="number">2</span>)</span><br><span class="line">     &lt;&lt; <span class="string">&quot;). The time used is &quot;</span> &lt;&lt; deltaTime &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rotation using vector decomposation - the matrix form</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DecomposeMatrix</span><span class="params">(<span class="type">const</span> Eigen::Vector3f &amp;n, <span class="type">const</span> Eigen::Vector3f &amp;p, <span class="type">float</span> angle)</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> rotationAngle = angle / <span class="number">180.0</span> * PI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> startTime = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">Eigen::Matrix3f N = Eigen::Matrix3f::<span class="built_in">Identity</span>();</span><br><span class="line">N &lt;&lt; <span class="number">0</span>, -<span class="built_in">n</span>(<span class="number">2</span>), <span class="built_in">n</span>(<span class="number">1</span>),</span><br><span class="line">     <span class="built_in">n</span>(<span class="number">2</span>), <span class="number">0</span>, -<span class="built_in">n</span>(<span class="number">0</span>),</span><br><span class="line">     -<span class="built_in">n</span>(<span class="number">1</span>), <span class="built_in">n</span>(<span class="number">0</span>), <span class="number">0</span>;</span><br><span class="line">Eigen::Matrix3f R = Eigen::Matrix3f::<span class="built_in">Identity</span>() + <span class="built_in">sin</span>(rotationAngle) * N + (<span class="number">1</span> - <span class="built_in">cos</span>(rotationAngle)) * N * N;</span><br><span class="line">Eigen::Vector3f rotatedVector = R * p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> endTime = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="type">double</span> deltaTime = std::chrono::<span class="built_in">duration</span>&lt;<span class="type">double</span>, std::milli&gt;(endTime-startTime).<span class="built_in">count</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Method: vector decomposition - the matrix form. The rotated vector p&#x27; is (&quot;</span> </span><br><span class="line">     &lt;&lt; <span class="built_in">rotatedVector</span>(<span class="number">0</span>) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">rotatedVector</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">rotatedVector</span>(<span class="number">2</span>)</span><br><span class="line">     &lt;&lt; <span class="string">&quot;). The time used is &quot;</span> &lt;&lt; deltaTime &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rotation using axis coordination</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AxisCoordination</span><span class="params">(<span class="type">const</span> Eigen::Vector3f &amp;n, <span class="type">const</span> Eigen::Vector3f &amp;p, <span class="type">float</span> angle)</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> rotationAngle = angle / <span class="number">180.0</span> * PI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> startTime = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">Eigen::Vector3f crossed = n.<span class="built_in">cross</span>(p);</span><br><span class="line">Eigen::Vector3f u = n;</span><br><span class="line">Eigen::Vector3f v = crossed / crossed.<span class="built_in">norm</span>();</span><br><span class="line">Eigen::Vector3f w = n.<span class="built_in">cross</span>(v);</span><br><span class="line">Eigen::Matrix3f Q = Eigen::Matrix3f::<span class="built_in">Identity</span>(), T = Eigen::Matrix3f::<span class="built_in">Identity</span>();</span><br><span class="line">Q.<span class="built_in">row</span>(<span class="number">0</span>) = u;</span><br><span class="line">Q.<span class="built_in">row</span>(<span class="number">1</span>) = v;</span><br><span class="line">Q.<span class="built_in">row</span>(<span class="number">2</span>) = w;</span><br><span class="line">T &lt;&lt; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">     <span class="number">0</span>, <span class="built_in">cos</span>(rotationAngle), -<span class="built_in">sin</span>(rotationAngle),</span><br><span class="line">     <span class="number">0</span>, <span class="built_in">sin</span>(rotationAngle), <span class="built_in">cos</span>(rotationAngle);</span><br><span class="line">Eigen::Vector3f rotatedVector = Q.<span class="built_in">transpose</span>() * T * Q * p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> endTime = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="type">double</span> deltaTime = std::chrono::<span class="built_in">duration</span>&lt;<span class="type">double</span>, std::milli&gt;(endTime-startTime).<span class="built_in">count</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Method: axis coordination. The rotated vector p&#x27; is (&quot;</span> </span><br><span class="line">     &lt;&lt; <span class="built_in">rotatedVector</span>(<span class="number">0</span>) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">rotatedVector</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">rotatedVector</span>(<span class="number">2</span>)</span><br><span class="line">     &lt;&lt; <span class="string">&quot;). The time used is &quot;</span> &lt;&lt; deltaTime &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> angle = <span class="number">60</span>;</span><br><span class="line">    <span class="function">Eigen::Vector3f <span class="title">p</span><span class="params">(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Eigen::Vector3f <span class="title">n</span><span class="params">(<span class="number">2.0</span>, <span class="number">8.6</span>, <span class="number">-3.1</span>)</span></span>;</span><br><span class="line">    n.<span class="built_in">normalize</span>(); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// execute functions</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The vector p is (&quot;</span> &lt;&lt; <span class="built_in">p</span>(<span class="number">0</span>) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">p</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">p</span>(<span class="number">2</span>) &lt;&lt; <span class="string">&quot;). &quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;The rotation axis n is (&quot;</span> &lt;&lt; <span class="built_in">n</span>(<span class="number">0</span>) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">n</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">n</span>(<span class="number">2</span>) &lt;&lt; <span class="string">&quot;). &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">DecomposeVector</span>(n, p, angle);</span><br><span class="line">    <span class="built_in">DecomposeMatrix</span>(n, p, angle);</span><br><span class="line">    <span class="built_in">AxisCoordination</span>(n, p, angle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">The vector p <span class="title">is</span> <span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span>. The rotation axis n <span class="title">is</span> <span class="params">(<span class="number">0.213724</span>,<span class="number">0.919011</span>,<span class="number">-0.331271</span>)</span>. </span></span><br><span class="line"><span class="function">Method: vector decomposition - the vector form. The rotated vector p<span class="string">&#x27; is (3.57449,0.643966,0.899062). The time used is 0.016354</span></span></span><br><span class="line"><span class="string"><span class="function">Method: vector decomposition - the matrix form. The rotated vector p&#x27;</span> is (<span class="number">3.57449</span>,<span class="number">0.643966</span>,<span class="number">0.899062</span>). The time used is <span class="number">0.016642</span></span></span><br><span class="line"><span class="function">Method: axis coordination. The rotated vector p<span class="string">&#x27; is (3.57449,0.643966,0.899062). The time used is 0.021062</span></span></span><br></pre></td></tr></table></figure>

<p>再多试几组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">The vector p <span class="title">is</span> <span class="params">(<span class="number">1</span>,<span class="number">-654.1</span>,<span class="number">12.88</span>)</span>. The rotation axis n <span class="title">is</span> <span class="params">(<span class="number">0.995044</span>,<span class="number">0.0136933</span>,<span class="number">-0.0984901</span>)</span>. </span></span><br><span class="line"><span class="function">Method: vector decomposition - the vector form. The rotated vector p<span class="string">&#x27; is (-59.7309,-338.298,-556.777). The time used is 0.015503</span></span></span><br><span class="line"><span class="string"><span class="function">Method: vector decomposition - the matrix form. The rotated vector p&#x27;</span> is (<span class="number">-59.7309</span>,<span class="number">-338.298</span>,<span class="number">-556.777</span>). The time used is <span class="number">0.015297</span></span></span><br><span class="line"><span class="function">Method: axis coordination. The rotated vector p<span class="string">&#x27; is (-59.7309,-338.298,-556.777). The time used is 0.021547</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">The vector p <span class="title">is</span> <span class="params">(<span class="number">32.5</span>,<span class="number">45.1</span>,<span class="number">-2.2</span>)</span>. The rotation axis n <span class="title">is</span> <span class="params">(<span class="number">0.57735</span>,<span class="number">0.57735</span>,<span class="number">0.57735</span>)</span>. </span></span><br><span class="line"><span class="function">Method: vector decomposition - the vector form. The rotated vector p<span class="string">&#x27; is (5.16667,52.4667,17.7667). The time used is 0.015558</span></span></span><br><span class="line"><span class="string"><span class="function">Method: vector decomposition - the matrix form. The rotated vector p&#x27;</span> is (<span class="number">5.16667</span>,<span class="number">52.4667</span>,<span class="number">17.7667</span>). The time used is <span class="number">0.015215</span></span></span><br><span class="line"><span class="function">Method: axis coordination. The rotated vector p<span class="string">&#x27; is (5.16667,52.4667,17.7667). The time used is 0.020841</span></span></span><br><span class="line"><span class="string"><span class="function">The vector p is (666,0,0). The rotation axis n is (0,0,1). </span></span></span><br><span class="line"><span class="string"><span class="function">Method: vector decomposition - the vector form. The rotated vector p&#x27;</span> is (<span class="number">1.78454e-05</span>,<span class="number">666</span>,<span class="number">0</span>). The time used is <span class="number">0.01517</span></span></span><br><span class="line"><span class="function">Method: vector decomposition - the matrix form. The rotated vector p<span class="string">&#x27; is (0,666,0). The time used is 0.015402</span></span></span><br><span class="line"><span class="string"><span class="function">Method: axis coordination. The rotated vector p&#x27;</span> is (<span class="number">1.78454e-05</span>,<span class="number">666</span>,<span class="number">0</span>). The time used is <span class="number">0.020898</span></span></span><br></pre></td></tr></table></figure>

<p>最后一组出现了精度问题，所以代码中还应该加入判断</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(value - <span class="built_in">round</span>(value)) &lt; epsilon)</span><br><span class="line">     value = <span class="built_in">round</span>(value);</span><br></pre></td></tr></table></figure>



<p>从上面的例子来看，<strong>向量分解-向量形式</strong>与<strong>向量分解-矩阵形式</strong>运行效率是一致的，而<strong>坐标轴对齐</strong>的效率较低，这主要是由计算三次矩阵乘法导致的。</p>
<p>上面这个推导公式有问题，参考了下面的公式，更通用。</p>
<p><a target="_blank" rel="noopener" href="http://betheme.net/news/txtlist_i213886v.html">【GAMES101】作业1（提高）与框架理解 (betheme.net)</a></p>
<h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>1， Eigen中的矩阵和向量运算不会自动适应行列数，需要在编程的时候保证参与运算的矩阵和向量行列数可以进行运算<br>2，头文件&lt;Eigen&#x2F;Core&gt; 中包含【+，-，<em>，&#x2F;，+&#x3D;，-&#x3D;，</em>&#x3D;，.transpose()…sum()，.prod()，.mean()，minCoeff()，.maxCoeff，.trace()】等运算符<br>3，头文件&lt;Eigen&#x2F;Dense&gt; 中包含【.dot()，.cross()，adjoint()】等运算符<br>4，以下讨论的符号约定(假设满足运算的行列数要求)<br>矩阵：a，b<br>向量：u，v<br>常数：c</p>
<h3 id="1，【-，-x3D-，-，-x3D-】"><a href="#1，【-，-x3D-，-，-x3D-】" class="headerlink" title="1，【+，+&#x3D;，-，-&#x3D;】"></a>1，【+，+&#x3D;，-，-&#x3D;】</h3><p>适用于尺寸相同的矩阵之间、尺寸相同的向量之间的对应元素相加减</p>
<h3 id="2，【，-x3D-】"><a href="#2，【，-x3D-】" class="headerlink" title="2，【，&#x3D;】"></a>2，【<em>，</em>&#x3D;】</h3><p>1，用于矩阵与矩阵：尺寸合适的矩阵的一般矩阵乘法。此时，向量可以看成是矩阵<br>2，用于矩阵与标量：矩阵与标量的一般乘法，矩阵每个元素与标量相乘。此时，向量可以看成是矩阵</p>
<h3 id="3，【-transpose-】"><a href="#3，【-transpose-】" class="headerlink" title="3，【.transpose()】"></a>3，【.transpose()】</h3><p>返回矩阵的转置。此时，向量可以看成是矩阵</p>
<h3 id="4，【-dot-，-cross-，-adjoint-】"><a href="#4，【-dot-，-cross-，-adjoint-】" class="headerlink" title="4，【.dot()，.cross()，.adjoint()】"></a>4，【.dot()，.cross()，.adjoint()】</h3><p>只用于向量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">u.<span class="built_in">dot</span>(v):u和v的点乘，即对应元素乘积的和，返回一个标量。与v.<span class="built_in">dot</span>(u)，u.<span class="built_in">transpose</span>()*v，v.<span class="built_in">transpose</span>()*u相同。</span><br><span class="line"></span><br><span class="line">u.<span class="built_in">cross</span>(v):u和v的叉积，返回一个向量。与v.<span class="built_in">cross</span>(u)相差一个负号。</span><br><span class="line"></span><br><span class="line">u.<span class="built_in">adjoint</span>():返回u的共轭向量，若u为实向量，则返回结果与u相同。</span><br></pre></td></tr></table></figure>

<h3 id="5，针对矩阵元素进行的操作【-sum-，-prod-，-mean-，minCoeff-，-maxCoeff，-trace-】"><a href="#5，针对矩阵元素进行的操作【-sum-，-prod-，-mean-，minCoeff-，-maxCoeff，-trace-】" class="headerlink" title="5，针对矩阵元素进行的操作【.sum()，.prod()，.mean()，minCoeff()，.maxCoeff，.trace()】"></a>5，针对矩阵元素进行的操作【.sum()，.prod()，.mean()，minCoeff()，.maxCoeff，.trace()】</h3><p>本部分所有操作都可对矩阵和向量进行，将向量看做矩阵即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="built_in">sum</span>()：		返回矩阵a中所有元素的和</span><br><span class="line">a.<span class="built_in">prod</span>()：		返回矩阵a中所有元素的积</span><br><span class="line">a.<span class="built_in">mean</span>()：		返回矩阵a中所有有元素的平均值</span><br><span class="line">a.<span class="built_in">trace</span>():		返回矩阵的迹，即返回主对角线上元素的和。如果不是方阵或者为向量，仍返回对角线元素的和。</span><br><span class="line">a.<span class="built_in">minCoeff</span>()：	返回矩阵中最小的元素</span><br><span class="line">a.<span class="built_in">maxCoeff</span>()：	返回矩阵中最大的元素</span><br><span class="line"></span><br><span class="line">另外，对于.<span class="built_in">minCoeff</span>()，.<span class="built_in">maxCoeff</span>()，有以下用法：</span><br><span class="line"><span class="type">int</span> i,j;<span class="comment">//或std::ptrdiff_t i, j</span></span><br><span class="line"><span class="keyword">auto</span> min = a.<span class="built_in">minCoeff</span>(i,j);返回a的最小元素赋值给min，并将最小元素所在行号、列号赋值给i、j。</span><br><span class="line"><span class="keyword">auto</span> max = a.<span class="built_in">maxCoeff</span>(p,q);返回a的最大元素赋值给max，并将最大元素所在行号、列号赋值给q、p。</span><br></pre></td></tr></table></figure>

<h3 id="6，【-norm-】向量求模，矩阵范数"><a href="#6，【-norm-】向量求模，矩阵范数" class="headerlink" title="6，【.norm()】向量求模，矩阵范数"></a>6，【.norm()】向量求模，矩阵<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%8C%83%E6%95%B0&spm=1001.2101.3001.7020">范数</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.norm();//返回矩阵的Frobenius范数，即元素平方的和的平方根</span><br><span class="line">u.norm();//返回向量的模</span><br></pre></td></tr></table></figure>

<h1 id="Hw02"><a href="#Hw02" class="headerlink" title="Hw02"></a>Hw02</h1><h2 id="2022-x2F-04-x2F-12"><a href="#2022-x2F-04-x2F-12" class="headerlink" title="2022&#x2F;04&#x2F;12"></a>2022&#x2F;04&#x2F;12</h2><p>完成了作业二以及MSAA。目前没有学习z-buffer的插值函数，所以直接用了框架提供的代码。</p>
<p>目前效果是：如下图所示，三角形周围有黑线。</p>
<p><img src="/images/GAMES101/MSAA%E9%BB%91%E7%BA%BF_class7.png" alt="MSAA黑线_class7"></p>
<p>对应代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> rst::rasterizer::<span class="built_in">updateColorAndDepth</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> Triangle&amp; t, <span class="type">float</span> color_percent = <span class="number">1.0f</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 转换为齐次坐标</span></span><br><span class="line">    <span class="comment">// 在这一步，已经经过了MVP变换为了屏幕上的点，所以只需要知道x, y的信息即可</span></span><br><span class="line">    <span class="keyword">auto</span> v = t.<span class="built_in">toVector4</span>();</span><br><span class="line">    <span class="comment">// If so, use the following code to get the interpolated z value.</span></span><br><span class="line">    <span class="comment">// 这是插值函数，目前还没学到（刚上完p7）；这里加0.5f没有出错</span></span><br><span class="line">    <span class="comment">// auto[alpha, beta, gamma] = computeBarycentric2D(x + 0.5f, y + 0.5f, t.v);</span></span><br><span class="line">    <span class="keyword">auto</span>[alpha, beta, gamma] = <span class="built_in">computeBarycentric2D</span>(x, y, t.v);</span><br><span class="line">    <span class="type">float</span> w_reciprocal = <span class="number">1.0</span>/(alpha / v[<span class="number">0</span>].<span class="built_in">w</span>() + beta / v[<span class="number">1</span>].<span class="built_in">w</span>() + gamma / v[<span class="number">2</span>].<span class="built_in">w</span>());</span><br><span class="line">    <span class="type">float</span> z_interpolated = alpha * v[<span class="number">0</span>].<span class="built_in">z</span>() / v[<span class="number">0</span>].<span class="built_in">w</span>() + beta * v[<span class="number">1</span>].<span class="built_in">z</span>() / v[<span class="number">1</span>].<span class="built_in">w</span>() + gamma * v[<span class="number">2</span>].<span class="built_in">z</span>() / v[<span class="number">2</span>].<span class="built_in">w</span>();</span><br><span class="line">    z_interpolated *= w_reciprocal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还是z的问题，因为z是负值，所以如果越近，z越大</span></span><br><span class="line">    <span class="comment">// 因此depth_buf初始化的时候应该是用-inf来初始化才对</span></span><br><span class="line">    <span class="keyword">if</span>(z_interpolated &gt; depth_buf[<span class="built_in">get_index</span>(x, y)])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// TODO : set the current pixel (use the set_pixel function) to the color of the triangle (use getColor function) if it should be painted.</span></span><br><span class="line">        <span class="comment">// 用像素的中心来判断 但是加了0.5会导致缺一块   </span></span><br><span class="line">        <span class="comment">// 猜测加了0.5f出错是因为x, y应该是像素的index而不是像素中心的坐标点</span></span><br><span class="line">        Eigen::Vector3f point = Eigen::<span class="built_in">Vector3f</span>(x, y, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="built_in">set_pixel</span>(point, t.<span class="built_in">getColor</span>() * color_percent);</span><br><span class="line">        <span class="comment">// 更新depth_buf</span></span><br><span class="line">        depth_buf[<span class="built_in">get_index</span>(x, y)] = z_interpolated;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(MSAA)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义super-sampling的形状</span></span><br><span class="line">    <span class="type">int</span> m = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">2</span>;</span><br><span class="line">    <span class="type">float</span> total_samples = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(m * n);</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">Eigen::Vector2f <span class="title">p</span><span class="params">(x+(<span class="number">0.5f</span>+i)/m, y+(<span class="number">0.5f</span>+j)/n)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">insideTrianglePoint</span>(p, t.v)) count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">float</span> color_percent = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(count) / total_samples;</span><br><span class="line">    <span class="keyword">if</span>(color_percent &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">updateColorAndDepth</span>(x, y, t, color_percent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2022-x2F-04-x2F-19"><a href="#2022-x2F-04-x2F-19" class="headerlink" title="2022&#x2F;04&#x2F;19"></a>2022&#x2F;04&#x2F;19</h2><p><strong>去掉了黑线</strong></p>
<p><img src="/images/GAMES101/MSAA%E5%8E%BB%E6%8E%89%E9%BB%91%E7%BA%BF_class9.png" alt="MSAA去掉黑线_class9"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> rst::rasterizer::<span class="built_in">updateColorAndDepth</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> Triangle&amp; t, <span class="type">float</span> color_percent = <span class="number">1.0f</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ind = <span class="built_in">get_index</span>(x, y);</span><br><span class="line">    <span class="comment">// 转换为齐次坐标</span></span><br><span class="line">    <span class="comment">// 在这一步，已经经过了MVP变换为了屏幕上的点，所以只需要知道x, y的信息即可</span></span><br><span class="line">    <span class="keyword">auto</span> v = t.<span class="built_in">toVector4</span>();</span><br><span class="line">    <span class="comment">// If so, use the following code to get the interpolated z value.</span></span><br><span class="line">    <span class="comment">// 这是插值函数，目前还没学到（刚上完p7）；这里加0.5f没有出错</span></span><br><span class="line">    <span class="comment">// auto[alpha, beta, gamma] = computeBarycentric2D(x + 0.5f, y + 0.5f, t.v);</span></span><br><span class="line">    <span class="keyword">auto</span>[alpha, beta, gamma] = <span class="built_in">computeBarycentric2D</span>(x, y, t.v);</span><br><span class="line">    <span class="type">float</span> w_reciprocal = <span class="number">1.0</span>/(alpha / v[<span class="number">0</span>].<span class="built_in">w</span>() + beta / v[<span class="number">1</span>].<span class="built_in">w</span>() + gamma / v[<span class="number">2</span>].<span class="built_in">w</span>());</span><br><span class="line">    <span class="type">float</span> z_interpolated = alpha * v[<span class="number">0</span>].<span class="built_in">z</span>() / v[<span class="number">0</span>].<span class="built_in">w</span>() + beta * v[<span class="number">1</span>].<span class="built_in">z</span>() / v[<span class="number">1</span>].<span class="built_in">w</span>() + gamma * v[<span class="number">2</span>].<span class="built_in">z</span>() / v[<span class="number">2</span>].<span class="built_in">w</span>();</span><br><span class="line">    z_interpolated *= w_reciprocal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还是z的问题，因为z是负值，所以如果越近，z越大</span></span><br><span class="line">    <span class="comment">// 因此depth_buf初始化的时候应该是用-inf来初始化才对</span></span><br><span class="line">    <span class="keyword">if</span>(z_interpolated &gt; depth_buf[ind])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// TODO : set the current pixel (use the set_pixel function) to the color of the triangle (use getColor function) if it should be painted.</span></span><br><span class="line">        <span class="comment">// 用像素的中心来判断 但是加了0.5会导致缺一块   </span></span><br><span class="line">        <span class="comment">// 猜测加了0.5f出错是因为x, y应该是像素的index而不是像素中心的坐标点</span></span><br><span class="line">        Eigen::Vector3f point = Eigen::<span class="built_in">Vector3f</span>(x, y, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="built_in">set_pixel</span>(point, t.<span class="built_in">getColor</span>() * color_percent + frame_buf[ind] * (<span class="number">1</span> - color_percent));</span><br><span class="line">        <span class="comment">// 更新depth_buf</span></span><br><span class="line">        depth_buf[ind] = z_interpolated;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为了将边界处的深度初始化，因为如果存在重叠的情况，需要更新下方的颜色，否则比较大小内不会执行（颜色不更新）</span></span><br><span class="line">    <span class="keyword">if</span>(color_percent &lt; <span class="number">1.0f</span>) depth_buf[ind] = - std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">infinity</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体来说，首先着色的是绿色的三角形，如果是边界，那么color_percent一定小于1，这时，由于是第一次着色，所以原本的frame_buffer中存的是黑色(0, 0, 0)，如果有颜色的占比很小，那么MSAA混合出来的颜色就会很深，看着就像一条黑线。所以需要将depth_buffer初始化，在而后对处于下方的蓝色三角形进行着色时，这个原本的黑色边界就会被着色为蓝色，边界也就不存在了。</p>
<h2 id="黑边问题"><a href="#黑边问题" class="headerlink" title="黑边问题"></a>黑边问题</h2><p>产生黑边的<strong>原因</strong>主要为：这时采用的为原图片大小的深度缓存空间，两个三角形位置为关系为绿色在上（前），蓝色在下（后）面，绘制时的顺序也按照这样。在计算完绿色三角形之后，帧缓存和深度缓存均已更新，三角形边缘的地方像素颜色采用覆盖比率插值计算，深度值为绿色三角形在该坐标所计算出的深度插值。根据上面的话，这条黑色的边其实并不是真的的黑色，而是插值之后的绿色，只不过是由于覆盖比率很小在插值之后rgb值变得很低，颜色的饱和度与亮度会随之下降。例如原rgb值为（200,200,100），若覆盖比率为4&#x2F;16的话，如下面效果，若覆盖率更低那么会更接近黑色。（参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_51928794/article/details/117256226%EF%BC%89">https://blog.csdn.net/weixin_51928794/article/details/117256226）</a></p>
<p><img src="https://img-blog.csdnimg.cn/20210525152530754.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTkyODc5NA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210525152530802.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTkyODc5NA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>在计算完第一个绿色的三角形之后，开始计算第二个蓝色的三角形，这时又遍历到了上面异常的黑边处，也就是有一点点绿色的黑边，需要比较深度缓存来决定蓝色三角形是否要在该像素绘制。在每个像素采样计算时，三角形的覆盖是按照4x4采样计算的，但是深度值是按照像素级别1x1计算和存储来的， 之前该像素位置只存储了绿色三角形的深度值，蓝色三角形在绿色之后，所以深度比较失败，从而导致了该处不会再更新像素值。</p>
<p><strong>解决方法</strong>：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/454001952">Games101｜作业2 + 光栅化 + SSAA vs MSAA + 黑边问题 - 知乎 (zhihu.com)</a></p>
<p>为了解决这个问题，我们可以在光栅化的时候，确保边界上的每个三角形的每个小像素都被考虑到，即在过完每个 边界上的像素后，我们确保记录下它的frame buffer，<strong>并清除它的depth buffer</strong>。这样上图的蓝色小像素就不会因为depth_buf的原因，而没被记录。如何确定哪个像素在边界上？通过在三角形的小像素的个数。</p>
<p>翻译一下这个方案，就是通过比较上下重叠的两个物体，谁在边界处对像素的samples覆盖得更多，取覆盖的更多的那个颜色（且不稀释？）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Screen space rasterization</span></span><br><span class="line"><span class="type">void</span> rst::rasterizer::<span class="built_in">rasterize_triangle</span>(<span class="type">const</span> Triangle&amp; t) &#123;</span><br><span class="line">    <span class="keyword">auto</span> v = t.<span class="built_in">toVector4</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> min_x = width;</span><br><span class="line">    <span class="type">float</span> max_x = <span class="number">0</span>;</span><br><span class="line">    <span class="type">float</span> min_y = height;</span><br><span class="line">    <span class="type">float</span> max_y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find out the bounding box of current triangle</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        min_x = std::<span class="built_in">min</span>(v[i].<span class="built_in">x</span>(), min_x);</span><br><span class="line">        max_x = std::<span class="built_in">max</span>(v[i].<span class="built_in">x</span>(), max_x);</span><br><span class="line">        min_y = std::<span class="built_in">min</span>(v[i].<span class="built_in">y</span>(), min_y);</span><br><span class="line">        max_y = std::<span class="built_in">max</span>(v[i].<span class="built_in">y</span>(), max_y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iterate through the pixel</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y = min_y; y &lt; max_y; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x = min_x; x &lt; max_x; x++) &#123;</span><br><span class="line">            <span class="type">int</span> index = <span class="built_in">get_index</span>(x, y);</span><br><span class="line">            <span class="type">float</span> count = <span class="number">0.0</span>;</span><br><span class="line">            <span class="type">float</span> max_count = ssaa_w*ssaa_h;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">float</span> j = start_point; j &lt; <span class="number">1.0</span>; j+=pixel_size_sm) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">float</span> i = start_point; i &lt; <span class="number">1.0</span>; i+=pixel_size_sm) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">insideTriangle</span>(x+i, y+j, t.v)) &#123;</span><br><span class="line">                        count += <span class="number">1.0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// find if the current pixel is inside the triangle</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">insideTriangle</span>(x+<span class="number">0.5</span>, y+<span class="number">0.5</span>, t.v)) &#123;</span><br><span class="line">                <span class="comment">// if so, use the following code to get the interpolated z value.</span></span><br><span class="line">                <span class="keyword">auto</span>[alpha, beta, gamma] = <span class="built_in">computeBarycentric2D</span>(x+<span class="number">0.5</span>, y+<span class="number">0.5</span>, t.v);</span><br><span class="line">                <span class="type">float</span> w_reciprocal = <span class="number">1.0</span>/(alpha / v[<span class="number">0</span>].<span class="built_in">w</span>() + beta / v[<span class="number">1</span>].<span class="built_in">w</span>() + gamma / v[<span class="number">2</span>].<span class="built_in">w</span>());</span><br><span class="line">                <span class="type">float</span> z_interpolated = alpha * v[<span class="number">0</span>].<span class="built_in">z</span>() / v[<span class="number">0</span>].<span class="built_in">w</span>() + beta * v[<span class="number">1</span>].<span class="built_in">z</span>() / v[<span class="number">1</span>].<span class="built_in">w</span>() + gamma * v[<span class="number">2</span>].<span class="built_in">z</span>() / v[<span class="number">2</span>].<span class="built_in">w</span>();</span><br><span class="line">                z_interpolated *= w_reciprocal;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// set the current pixel (use the set_pixel function) </span></span><br><span class="line">                <span class="comment">// to the color of the triangle (use getColor function)</span></span><br><span class="line">                <span class="comment">// if it should be painted.</span></span><br><span class="line">                <span class="keyword">if</span>(z_interpolated &lt; depth_buf[index]) &#123;</span><br><span class="line">                    Eigen::Vector3f p;</span><br><span class="line">                    p &lt;&lt; x, y, z_interpolated;</span><br><span class="line">                    Eigen::Vector3f color = t.<span class="built_in">getColor</span>()*(count/max_count)+((max_count-count)/max_count)*frame_buf[index];</span><br><span class="line">                    <span class="built_in">set_pixel</span>(p, color);</span><br><span class="line">                    depth_buf[index] = z_interpolated;</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count &lt; max_count) &#123;</span><br><span class="line">                depth_buf[index] = std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">infinity</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Hw03"><a href="#Hw03" class="headerlink" title="Hw03"></a>Hw03</h1><h2 id="2022-04-21"><a href="#2022-04-21" class="headerlink" title="2022.04.21"></a>2022.04.21</h2><p><em>完成了Hw3，包括基于双线性插值的纹理采样。</em></p>
<ul>
<li><p>首先是基于中心坐标的插值（rasterize_triangle方法中）:</p>
<ul>
<li>normal：用于phong shading，顶点的normal记录在obj中。</li>
</ul>
<p><img src="/images/GAMES101/output_normal.png" alt="output_normal"></p>
<ul>
<li>color：phong shading中的kd，triangle初始化时定义，目前是hardcode的。</li>
<li>texure_coords：通过插值找到当前像素在纹理贴图上的uv坐标，uv坐标取值范围为[0, 1]，将查找到的color作为kd进行shading，顶点的texure_coords记录在obj中。</li>
</ul>
<p><img src="/images/GAMES101/output_texture.png" alt="output_texture"></p>
<ul>
<li>shading_coods：通过model和view变换之后的position用于shading的计算，因为投影之后失去了3d的几何性质，向量I，向量V都需要这个坐标才可以计算出来。</li>
</ul>
</li>
<li><p>phong_shader中，使用了blinn-phong着色模型，分为ambient，diffuse，specular三个分量，三者叠加。如果环境中有几个光源，那么最终的结果是几个光源分别作用在物体上的三个分量之和的叠加。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   Eigen::Vector3f result_color = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; light : lights)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// <span class="doctag">TODO:</span> For each light source in the code, calculate what the *ambient*, *diffuse*, and *specular* </span></span><br><span class="line">       <span class="comment">// components are. Then, accumulate that result on the *result_color* object.</span></span><br><span class="line">       <span class="type">float</span> r2 = (light.position - point).<span class="built_in">dot</span>(light.position - point);</span><br><span class="line">       Eigen::Vector3f l = (light.position - point).<span class="built_in">normalized</span>();</span><br><span class="line">       <span class="comment">// Eigen::Vector3f n = normal - point;</span></span><br><span class="line">       Eigen::Vector3f v = (eye_pos - point).<span class="built_in">normalized</span>();</span><br><span class="line">       <span class="comment">// 要用矩阵的对应元素相乘cwiseProduct才可以，因为rgb三个方向的强度、ka\kb\ks可能都不一样，分开计算。</span></span><br><span class="line">       <span class="comment">// 向量只有点乘和叉乘，点乘得到数，叉乘得到向量。</span></span><br><span class="line">       <span class="comment">// 点乘可以用a.dot(b), 也可以a.transpose() * b (a,b是行数相同的vector)</span></span><br><span class="line">       Eigen::Vector3f ambient = ka.<span class="built_in">cwiseProduct</span>(amb_light_intensity);</span><br><span class="line">       Eigen::Vector3f diffuse = kd.<span class="built_in">cwiseProduct</span>(light.intensity / r2) * std::<span class="built_in">max</span>(<span class="number">0.0f</span>, normal.<span class="built_in">dot</span>(l));</span><br><span class="line">       Eigen::Vector3f specular =  ks.<span class="built_in">cwiseProduct</span>(light.intensity / r2) * <span class="built_in">pow</span>(std::<span class="built_in">max</span>(<span class="number">0.0f</span>, normal.<span class="built_in">dot</span>((l + v).<span class="built_in">normalized</span>())), p);</span><br><span class="line">       result_color += ambient + diffuse + specular;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/GAMES101/output_phong.png" alt="output_phong"></p>
<ul>
<li>bump和displacement贴图都是需要使用TBN和微分计算出来的位移切线方向来计算新的normal向量，在这个作业中，bump_shader直接输出的时normal作为颜色；displacement_shader在此基础上，还要重新计算position_view（因为顶点是真的发生了移动），然后重新应用phong_shading来进行着色。</li>
<li>在bump内我加了blinn-phong模型与displacement的效果进行对比。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> kh = <span class="number">0.2</span>, kn = <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Implement displacement mapping here</span></span><br><span class="line"><span class="comment">// Let n = normal = (x, y, z)</span></span><br><span class="line">Eigen::Vector3f n = normal;</span><br><span class="line"><span class="comment">// Vector t = (x*y/sqrt(x*x+z*z),sqrt(x*x+z*z),z*y/sqrt(x*x+z*z))</span></span><br><span class="line"><span class="type">float</span> x = n.<span class="built_in">x</span>();</span><br><span class="line"><span class="type">float</span> y = n.<span class="built_in">y</span>();</span><br><span class="line"><span class="type">float</span> z = n.<span class="built_in">z</span>();</span><br><span class="line">Eigen::Vector3f t&#123;x*y/<span class="built_in">sqrt</span>(x*x+z*z), <span class="built_in">sqrt</span>(x*x+z*z), z*y/<span class="built_in">sqrt</span>(x*x+z*z)&#125;;</span><br><span class="line"><span class="comment">// Vector b = n cross product t</span></span><br><span class="line">Eigen::Vector3f b = n.<span class="built_in">cross</span>(t);</span><br><span class="line"><span class="comment">// Matrix TBN = [t b n]</span></span><br><span class="line">Eigen::Matrix3f TBN;</span><br><span class="line">TBN &lt;&lt; t, b, n;</span><br><span class="line"><span class="comment">// ??????????????????????????不懂 但好像又有点懂</span></span><br><span class="line"><span class="comment">// dU = kh * kn * (h(u+1/w,v)-h(u,v))</span></span><br><span class="line"><span class="type">float</span> w = payload.texture-&gt;width;</span><br><span class="line"><span class="type">float</span> h = payload.texture-&gt;height;</span><br><span class="line"><span class="type">float</span> u = payload.tex_coords.<span class="built_in">x</span>();</span><br><span class="line"><span class="type">float</span> v = payload.tex_coords.<span class="built_in">y</span>();</span><br><span class="line"><span class="comment">// 在这里norm一下取模长，近似为高度？</span></span><br><span class="line"><span class="type">float</span> dU = kh * kn * (payload.texture-&gt;<span class="built_in">getColor</span>(u+<span class="number">1.0f</span>/w,v).<span class="built_in">norm</span>() - payload.texture-&gt;<span class="built_in">getColor</span>(u,v).<span class="built_in">norm</span>());</span><br><span class="line"><span class="comment">// dV = kh * kn * (h(u,v+1/h)-h(u,v))</span></span><br><span class="line"><span class="type">float</span> dV = kh * kn * (payload.texture-&gt;<span class="built_in">getColor</span>(u,v+<span class="number">1.0f</span>/h).<span class="built_in">norm</span>() - payload.texture-&gt;<span class="built_in">getColor</span>(u,v).<span class="built_in">norm</span>());</span><br><span class="line"><span class="comment">// Vector ln = (-dU, -dV, 1)</span></span><br><span class="line">Eigen::Vector3f ln&#123;-dU, -dV, <span class="number">1.0f</span>&#125;;</span><br><span class="line"><span class="comment">// Position p = p + kn * n * h(u,v)</span></span><br><span class="line">point = point + kn * n * payload.texture-&gt;<span class="built_in">getColor</span>(u,v).<span class="built_in">norm</span>();</span><br><span class="line"><span class="comment">// Normal n = normalize(TBN * ln)</span></span><br><span class="line">n = (TBN * ln).<span class="built_in">normalized</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如下图所示：</p>
<p><img src="/images/GAMES101/output_bump.png" alt="output_bump"></p>
<p><img src="/images/GAMES101/output_displacement.png" alt="output_displacement"></p>
<p><img src="/images/GAMES101/output_bump_vs_displacement.png" alt="output_bump_vs_displacement"></p>
<ul>
<li>最后是双线性插值（关键点在注释中）：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双线性插值进行纹理采样</span></span><br><span class="line"><span class="function">Eigen::Vector3f <span class="title">getColorBilinear</span><span class="params">(<span class="type">float</span> u, <span class="type">float</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> u_img = u * <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width);</span><br><span class="line">    <span class="type">float</span> v_img = (<span class="number">1</span> - v) * <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">    <span class="type">float</span> u_img_round = <span class="built_in">round</span>(u_img);</span><br><span class="line">    <span class="type">float</span> v_img_round = <span class="built_in">round</span>(v_img);</span><br><span class="line">    std::vector&lt;Eigen::Vector2f&gt; neighbours</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// opencv的坐标x,y是反的..........</span></span><br><span class="line">        <span class="comment">// https://blog.csdn.net/sc944201630/article/details/82222909</span></span><br><span class="line">        <span class="comment">// ↙</span></span><br><span class="line">        &#123;u_img_round - <span class="number">0.5f</span>, v_img_round + <span class="number">0.5f</span>&#125;,</span><br><span class="line">        <span class="comment">// &#123;u_img_round - 1.0f, v_img_round + 1.0f&#125;,</span></span><br><span class="line">        <span class="comment">// ↘</span></span><br><span class="line">        &#123;u_img_round + <span class="number">0.5f</span>, v_img_round + <span class="number">0.5f</span>&#125;,</span><br><span class="line">        <span class="comment">// &#123;u_img_round , v_img_round + 1.0f&#125;,</span></span><br><span class="line">        <span class="comment">// ↖</span></span><br><span class="line">        &#123;u_img_round - <span class="number">0.5f</span>, v_img_round - <span class="number">0.5f</span>&#125;,</span><br><span class="line">        <span class="comment">// &#123;u_img_round - 1.0f, v_img_round&#125;,</span></span><br><span class="line">        <span class="comment">// ↗</span></span><br><span class="line">        &#123;u_img_round + <span class="number">0.5f</span>, v_img_round - <span class="number">0.5f</span>&#125;</span><br><span class="line">        <span class="comment">// &#123;u_img_round, v_img_round&#125;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">float</span> s = u_img - neighbours[<span class="number">2</span>].<span class="built_in">x</span>();</span><br><span class="line">    <span class="type">float</span> t = v_img - neighbours[<span class="number">2</span>].<span class="built_in">y</span>();</span><br><span class="line">    <span class="comment">// float s = u_img - neighbours[2].x() - 0.5f;</span></span><br><span class="line">    <span class="comment">// float t = v_img - neighbours[2].y() + 0.5f;</span></span><br><span class="line">    <span class="comment">// 对于s/t的计算，不论是以整数为单位还是0.5(pixel中心)为单位，结果都是一样的，无非整体-0.5或+0.5</span></span><br><span class="line">    <span class="comment">// 唯一不同的就是getColor的取值罢了，实验下来，以0.5为单位的结果和未插值的结果是一样的。</span></span><br><span class="line">    Eigen::Vector3f down_lerp = <span class="built_in">lerp</span>(s, <span class="built_in">getColor</span>(neighbours[<span class="number">2</span>]), <span class="built_in">getColor</span>(neighbours[<span class="number">3</span>]));</span><br><span class="line">    Eigen::Vector3f up_lerp = <span class="built_in">lerp</span>(s, <span class="built_in">getColor</span>(neighbours[<span class="number">0</span>]), <span class="built_in">getColor</span>(neighbours[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lerp</span>(t, down_lerp, up_lerp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还要注意的是，opencv的坐标系是从左上方开始的，不是左下方。</p>
<p>悬而未决：以pixel中心的坐标作为opencv的输入才可以得到与未插值的时候相同的结果（是说坐标的偏移等等），为什么？可能是因为opencv本身要求就是输入pixel中心的坐标来得到相应的color吧。</p>
<p>结果如下图，分别是512 * 512(small)以及256 * 256(tiny)的纹理贴图未应用&#x2F;应用了双线性插值：</p>
<p><img src="/images/GAMES101/output_small_texure_not_bilinear.png" alt="output_small_texure_not_bilinear"></p>
<p>small-未应用</p>
<p><img src="/images/GAMES101/output_small_texure_bilinear.png" alt="output_small_texure_bilinear"></p>
<p>small-已应用</p>
<p><img src="/images/GAMES101/output_tiny_texure_not_bilinear.png" alt="output_tiny_texure_not_bilinear"></p>
<p>tiny-未应用</p>
<p><img src="/images/GAMES101/output_tiny_texure_bilinear.png" alt="output_tiny_texure_bilinear"></p>
<p>tiny-已应用</p>
<p>可以看到，效果还是很明显的，应用了双线性插值之后，马赛克的现象好了很多。</p>
<p>补充：</p>
<ol>
<li><p>该框架光栅化的时候，遍历pixel是从坐标0开始++到699（其实是像素的左下角去判断是不是在三角形内并进行插值，而不是像素中心）；</p>
<blockquote>
<p>光栅化时，对像素的坐标点的取值会影响纹理坐标的计算，如果是texel大小 &#x3D;&#x3D; pixel大小的情况，那么纹理坐标应该是整数；类似的，如果光栅化遍历的时候是从0.5开始（也就是像素中心），那么纹理坐标计算出来应该是0.5的倍数。</p>
<p><strong>纹理坐标取值的判断会影响处理失真时使用的方案。</strong></p>
</blockquote>
</li>
<li><p>uv坐标直接乘width和height，而不是width-1和height-1；</p>
</li>
<li><p>opencv取texel值应该是将坐标值<strong>向下取整</strong>，比如：x ∈ [0, 1)时的坐标值取到的都是第0列texel的值，<strong>即这个方格面积所覆盖的范围都是取同一个texel值</strong>。因此，双线性插值时，纹理坐标是需要<strong>round四舍五入</strong>找到最近的一个texel<strong>交叉点</strong>之后再分别取这个<strong>交叉点周围的四个</strong>texel的中心点（画图就可以理解，但是要注意的是opencv的屏幕坐标系原点是从左上角开始的）。</p>
</li>
</ol>
<h2 id="2022-x2F-04-x2F-22"><a href="#2022-x2F-04-x2F-22" class="headerlink" title="2022&#x2F;04&#x2F;22"></a>2022&#x2F;04&#x2F;22</h2><p>Segment Fault</p>
<p>1: Texture.hpp中，根据uv getColor()的时候，uv要先格式化为[0, 1]之间；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(u &gt; <span class="number">1</span>) u = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(v &gt; <span class="number">1</span>) v = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(u &lt; <span class="number">0</span>) u = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(v &lt; <span class="number">0</span>) v = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>2: rock.obj，如果相机离物体太近，也会段错误。所以把eye_pos的z坐标改大。因为物体在世界坐标系原点，相机指向-z方向，相当于朝着z正方向平移（view变换里的矩阵值是-z）。</p>
<p>其他obj的渲染结果如下：</p>
<p><img src="/images/GAMES101/output_bunny_normal.png" alt="output_bunny_normal"></p>
<p><img src="/images/GAMES101/output_bunny_phong_eye_pos_shading_2.png" alt="output_bunny_phong_eye_pos_shading_2"></p>
<p>这是在main改了eye_pos，shader里面的eye_pos同步修改的结果。</p>
<p><img src="/images/GAMES101/output_bunny_phong_eye_pos_shading_10.png" alt="output_bunny_phong_eye_pos_shading_10"></p>
<p>这是在main改了eye_pos，shader里面的eye_pos未同步修改的结果。</p>
<p>可以看到(0, 0, 2)和(0, 0, 10)的eye_pos在phong shader里面的差别并不大。</p>
<p>然后，为了验证当obj位于相机背后时，成像会是倒立的（小孔成像原理），将eye_pos改为(0, 0, -2)，效果如下，可以看到，确实成像是倒立的，并且是面朝成像平面，而非背部。</p>
<p><img src="/images/GAMES101/output_bunny_normal_back.png" alt="output_bunny_normal_back"></p>
<p>然后是rock.obj：</p>
<p><img src="/images/GAMES101/output_rock_normal.png" alt="output_rock_normal"></p>
<p><img src="/images/GAMES101/output_rock_phong.png" alt="output_rock_phong"></p>
<p><img src="/images/GAMES101/output_rock_texture.png" alt="output_rock_texture"></p>
<p>cube.obj：</p>
<p><img src="/images/GAMES101/output_cube_normal.png" alt="output_cube_normal"></p>
<p><img src="/images/GAMES101/output_cube_phong.png" alt="output_cube_phong"></p>
<p><img src="/images/GAMES101/output_cube_texture.png" alt="output_cube_texture"></p>
<p><img src="/images/GAMES101/output_cube_texture_1.png" alt="output_cube_texture_1"></p>
<p>Crate1.obj：这个模型本身顶点有问题，详见-&gt;<a target="_blank" rel="noopener" href="https://games-cn.org/forums/topic/%E4%BD%9C%E4%B8%9A3%E6%8D%A2%E6%A8%A1%E5%9E%8B-crate%E5%87%BA%E5%A4%A7%E9%97%AE%E9%A2%98/">作业3换模型—crate出大问题 – 计算机图形学与混合现实在线平台 (games-cn.org)</a>。</p>
<p><img src="/images/GAMES101/output_crate_normal.png" alt="output_crate_normal"></p>
<p><img src="/images/GAMES101/output_crate_phong.png" alt="output_crate_phong"></p>
<p><img src="/images/GAMES101/output_crate_texture.png" alt="output_crate_texture"></p>
<h1 id="Hw04"><a href="#Hw04" class="headerlink" title="Hw04"></a>Hw04</h1><h2 id="2022-x2F-05-x2F-21"><a href="#2022-x2F-05-x2F-21" class="headerlink" title="2022&#x2F;05&#x2F;21"></a>2022&#x2F;05&#x2F;21</h2><p>使用优先队列实现了De Casteljau算法，如下图所示。</p>
<p><img src="/images/GAMES101/output_04.png" alt="output"></p>
<p><strong>暂时没有实现反走样。</strong></p>
<p>总结一下：</p>
<ol>
<li>iterator如果是const对象的迭代器的话，会比较麻烦，用auto比较方便；访问值要用*it，迭代的时候直接it++即可；</li>
<li>思路是使用优先队列来对曲线上的点进行求取；需要注意的是queue的pop()不会返回值；</li>
<li>opencv库，at()函数用于绘制像素的颜色，[0] [1] [2] 分别是b&#x2F;g&#x2F;r通道；后面的值为通道的颜色的浓淡，255最浓。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cv::Point2f <span class="title">recursive_bezier</span><span class="params">(<span class="type">const</span> std::vector&lt;cv::Point2f&gt; &amp;control_points, <span class="type">float</span> t)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Implement de Casteljau&#x27;s algorithm</span></span><br><span class="line">    std::queue&lt;cv::Point2f&gt; current_points;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = control_points.<span class="built_in">begin</span>(); it != control_points.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        current_points.<span class="built_in">push</span>(*it);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> total_num = current_points.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> count = total_num;</span><br><span class="line">    <span class="keyword">while</span>(total_num != <span class="number">1</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">if</span>(count &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count--;</span><br><span class="line">            cv::Point2f begin_point = current_points.<span class="built_in">front</span>();</span><br><span class="line">            current_points.<span class="built_in">pop</span>();</span><br><span class="line">            cv::Point2f end_point = current_points.<span class="built_in">front</span>();</span><br><span class="line">            current_points.<span class="built_in">push</span>(begin_point + t * (end_point - begin_point));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            current_points.<span class="built_in">pop</span>();</span><br><span class="line">            total_num = current_points.<span class="built_in">size</span>();</span><br><span class="line">            count = total_num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current_points.<span class="built_in">front</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bezier</span><span class="params">(<span class="type">const</span> std::vector&lt;cv::Point2f&gt; &amp;control_points, cv::Mat &amp;window)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Iterate through all t = 0 to t = 1 with small steps, and call de Casteljau&#x27;s </span></span><br><span class="line">    <span class="comment">// recursive Bezier algorithm.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">float</span> t = <span class="number">0.0</span>; t &lt;= <span class="number">1.0</span>; t += <span class="number">0.001</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// at()函数</span></span><br><span class="line">        <span class="comment">// 对于单通道图像&quot;picture1&quot;，picture1.at&lt;uchar&gt;(i,j)就表示在第i行第j列的像素值。</span></span><br><span class="line">        <span class="comment">// 对于多通道图像如RGB图像&quot;picture2&quot;，可以用picture2.at&lt;Vec3b&gt;(i,j)[c]来表示某个通道中在(i,j)位置的像素值。</span></span><br><span class="line">        <span class="comment">// 1）上面的uchar、Vec3b表示图像元素的类型。</span></span><br><span class="line">        <span class="comment">// 2）(i,j)当然就是指像素点的位置，表示第i行第j列。</span></span><br><span class="line">        <span class="comment">// 3）[c]表示的是通道，对于RGB图像而言，c取0就是B分量；c取1就是G分量；c取2就是R分量（要注意在OpenCV中是按BGR的顺序表示的）。</span></span><br><span class="line">        <span class="keyword">auto</span> point = <span class="built_in">recursive_bezier</span>(control_points, t);</span><br><span class="line">        window.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(point.y, point.x)[<span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2022-x2F-06-x2F-07"><a href="#2022-x2F-06-x2F-07" class="headerlink" title="2022&#x2F;06&#x2F;07"></a>2022&#x2F;06&#x2F;07</h2><p>实现了反走样：</p>
<p><img src="/images/GAMES101/my_bezier_curve_antialiasing.png" alt="my_bezier_curve_antialiasing"></p>
<p>具体实现如下：</p>
<p>简单来说就是分别查看着色点到它周围9个像素的距离，从而生成颜色的浓度ratio比例，乘上255即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参考: https://blog.csdn.net/ycrsw/article/details/124117190</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">-1</span>; i &lt;= <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">-1</span>; j &lt;= <span class="number">1</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不处理越界像素</span></span><br><span class="line">        <span class="keyword">if</span> (point.x + i &gt; <span class="number">700</span> || point.x + i &lt; <span class="number">0</span> || point.y + j &gt; <span class="number">700</span> || point.y + j &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 计算ratio</span></span><br><span class="line">        ratio = <span class="number">1</span> - <span class="built_in">sqrt</span>(<span class="number">2</span>)*<span class="built_in">sqrt</span>(<span class="built_in">pow</span>(point.y - <span class="built_in">int</span>(point.y + j) - <span class="number">0.5</span>, <span class="number">2</span>) + <span class="built_in">pow</span>(point.x - <span class="built_in">int</span>(point.x + i) - <span class="number">0.5</span>, <span class="number">2</span>)) / <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 计算像素颜色</span></span><br><span class="line">        window.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(point.y + j, point.x + i)[<span class="number">2</span>] = std::<span class="built_in">fmax</span>(window.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(point.y + j, point.x + i)[<span class="number">2</span>], <span class="number">255</span> * ratio);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Hw05"><a href="#Hw05" class="headerlink" title="Hw05"></a>Hw05</h1><h2 id="2022-x2F-05-x2F-29"><a href="#2022-x2F-05-x2F-29" class="headerlink" title="2022&#x2F;05&#x2F;29"></a>2022&#x2F;05&#x2F;29</h2><ol>
<li>Renderer()</li>
</ol>
<p>在这里需要注意Raster Space到NDC Space的变换（归一化到[0, 1]）；</p>
<p>以及NDC Space到Screen Space的变换（缩放到[-1, 1]）。</p>
<p><img src="https://img-blog.csdnimg.cn/20210315153608594.png#pic_center" alt="将像素中间点的坐标转换为世界坐标需要几个步骤。这个点的坐标首先在光栅空间中表示(像素坐标加上0.5的偏移量)，然后转换到NDC空间(坐标被映射到范围[0,1])，然后转换到屏幕空间(NDC坐标被映射到[-1,1])。应用最终的相机到世界变换4x4矩阵变换屏幕空间的坐标到世界空间。"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; scene.height; ++j)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; scene.width; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// generate primary ray direction</span></span><br><span class="line">        <span class="type">float</span> x;</span><br><span class="line">        <span class="type">float</span> y;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Find the x and y positions of the current pixel to get the direction</span></span><br><span class="line">        <span class="comment">// vector that passes through it.</span></span><br><span class="line">        <span class="comment">// Also, don&#x27;t forget to multiply both of them with the variable *scale*, and</span></span><br><span class="line">        <span class="comment">// x (horizontal) variable with the *imageAspectRatio*</span></span><br><span class="line">        <span class="comment">// https://blog.csdn.net/dong89801033/article/details/114834898?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162216944616780357298394%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=162216944616780357298394&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-2-114834898.pc_search_result_cache&amp;utm_term=games101%E4%BD%9C%E4%B8%9A5&amp;spm=1018.2226.3001.4187</span></span><br><span class="line">        x = (<span class="number">2</span> * (i + <span class="number">0.5</span>) / scene.width - <span class="number">1</span>) * scale * imageAspectRatio;</span><br><span class="line">        y = (<span class="number">1</span> - <span class="number">2</span> * (j + <span class="number">0.5</span>) / scene.height) * scale;      </span><br><span class="line"></span><br><span class="line">        Vector3f dir = <span class="built_in">Vector3f</span>(x, y, <span class="number">-1</span>); <span class="comment">// Don&#x27;t forget to normalize this direction!</span></span><br><span class="line">        <span class="comment">// norm()是返回二范数</span></span><br><span class="line">        <span class="comment">// normalize()是直接把自身的各元素除以二范数</span></span><br><span class="line">        <span class="comment">// normalized()是返回一个标准化的向量</span></span><br><span class="line">        dir = <span class="built_in">normalize</span>(dir);</span><br><span class="line">        framebuffer[m++] = <span class="built_in">castRay</span>(eye_pos, dir, scene, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">UpdateProgress</span>(j / (<span class="type">float</span>)scene.height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，Scale是用于缩放视场的变量；imageAspectRatio是宽高比，因为归一化到[-1, 1]之后可能会对图像造成拉伸，所以需要沿着x轴进行缩放。</p>
<p>From: x’ &#x2F; y &#x3D; width &#x2F; height &#x3D;  imageAspectRatio;</p>
<p>And x &#x3D; y;</p>
<p>Thus: x’ &#x3D; imageAspectRatio * x;</p>
<ol start="2">
<li>CastRay()</li>
</ol>
<p>①菲涅尔方程</p>
<p>②Phong Illuminating Model</p>
<p>③Lambert Cosine Law</p>
<ol start="3">
<li>rayTriangleIntersect()</li>
</ol>
<p>Moller_Trumbore：快速求出光线(origin_point &amp; direction)和三角形(v0, v1, v2)的交点。</p>
<ol start="4">
<li>结果：</li>
</ol>
<p><img src="/images/GAMES101/output_05.png" alt="output"></p>
<h1 id="Hw06"><a href="#Hw06" class="headerlink" title="Hw06"></a>Hw06</h1><h2 id="2022-x2F-05-x2F-30"><a href="#2022-x2F-05-x2F-30" class="headerlink" title="2022&#x2F;05&#x2F;30"></a>2022&#x2F;05&#x2F;30</h2><h3 id="BVH加速求交："><a href="#BVH加速求交：" class="headerlink" title="BVH加速求交："></a>BVH加速求交：</h3><p>完成了<strong>BVH</strong>加速与物体求交的过程。</p>
<p>其中比较关键的是<strong>建树</strong>和求交这两个过程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建树</span></span><br><span class="line"><span class="function">BVHBuildNode* <span class="title">BVHAccel::recursiveBuild</span><span class="params">(std::vector&lt;Object*&gt; objects)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用new动态申请在heap的空间，需要手动delete，所以可以作为返回值</span></span><br><span class="line">    BVHBuildNode* node = <span class="keyword">new</span> <span class="built_in">BVHBuildNode</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute bounds of all primitives in BVH node</span></span><br><span class="line">    Bounds3 bounds;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; objects.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        bounds = <span class="built_in">Union</span>(bounds, objects[i]-&gt;<span class="built_in">getBounds</span>());</span><br><span class="line">    <span class="keyword">if</span> (objects.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// Create leaf _BVHBuildNode_</span></span><br><span class="line">        node-&gt;bounds = objects[<span class="number">0</span>]-&gt;<span class="built_in">getBounds</span>();</span><br><span class="line">        node-&gt;object = objects[<span class="number">0</span>];</span><br><span class="line">        node-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        node-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (objects.<span class="built_in">size</span>() == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 左值: std::vector&lt;Object*&gt; new_vec = &#123;objects[0]&#125;;</span></span><br><span class="line">        <span class="comment">// std::vector&#123;objects[0]&#125; 创建了一个右值</span></span><br><span class="line">        <span class="comment">// 之所以要这么写是因为这只是一个临时变量，之后用不到</span></span><br><span class="line">        <span class="comment">// 翻译一下传值的过程：</span></span><br><span class="line">        <span class="comment">// 1. 创建匿名变量 std::vector&#123;objects[0]&#125;</span></span><br><span class="line">        <span class="comment">// 2. 函数内：创建局部变量std::vector&lt;Object*&gt; objects = 匿名变量</span></span><br><span class="line">        <span class="comment">// 3. 复制Object* 类型数据objects[0]到objects内存所在区域（因为只是给指针赋值所以不会发生对象的拷贝构造）</span></span><br><span class="line">        node-&gt;left = <span class="built_in">recursiveBuild</span>(std::vector&#123;objects[<span class="number">0</span>]&#125;);</span><br><span class="line">        node-&gt;right = <span class="built_in">recursiveBuild</span>(std::vector&#123;objects[<span class="number">1</span>]&#125;);</span><br><span class="line"></span><br><span class="line">        node-&gt;bounds = <span class="built_in">Union</span>(node-&gt;left-&gt;bounds, node-&gt;right-&gt;bounds);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Bounds3 centroidBounds;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; objects.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            centroidBounds =</span><br><span class="line">                <span class="built_in">Union</span>(centroidBounds, objects[i]-&gt;<span class="built_in">getBounds</span>().<span class="built_in">Centroid</span>());</span><br><span class="line">        <span class="type">int</span> dim = centroidBounds.<span class="built_in">maxExtent</span>();</span><br><span class="line">        <span class="keyword">switch</span> (dim) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            std::<span class="built_in">sort</span>(objects.<span class="built_in">begin</span>(), objects.<span class="built_in">end</span>(), [](<span class="keyword">auto</span> f1, <span class="keyword">auto</span> f2) &#123;</span><br><span class="line">                <span class="keyword">return</span> f1-&gt;<span class="built_in">getBounds</span>().<span class="built_in">Centroid</span>().x &lt;</span><br><span class="line">                       f2-&gt;<span class="built_in">getBounds</span>().<span class="built_in">Centroid</span>().x;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            std::<span class="built_in">sort</span>(objects.<span class="built_in">begin</span>(), objects.<span class="built_in">end</span>(), [](<span class="keyword">auto</span> f1, <span class="keyword">auto</span> f2) &#123;</span><br><span class="line">                <span class="keyword">return</span> f1-&gt;<span class="built_in">getBounds</span>().<span class="built_in">Centroid</span>().y &lt;</span><br><span class="line">                       f2-&gt;<span class="built_in">getBounds</span>().<span class="built_in">Centroid</span>().y;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            std::<span class="built_in">sort</span>(objects.<span class="built_in">begin</span>(), objects.<span class="built_in">end</span>(), [](<span class="keyword">auto</span> f1, <span class="keyword">auto</span> f2) &#123;</span><br><span class="line">                <span class="keyword">return</span> f1-&gt;<span class="built_in">getBounds</span>().<span class="built_in">Centroid</span>().z &lt;</span><br><span class="line">                       f2-&gt;<span class="built_in">getBounds</span>().<span class="built_in">Centroid</span>().z;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> beginning = objects.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">auto</span> middling = objects.<span class="built_in">begin</span>() + (objects.<span class="built_in">size</span>() / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">auto</span> ending = objects.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> leftshapes = std::<span class="built_in">vector</span>&lt;Object*&gt;(beginning, middling);</span><br><span class="line">        <span class="keyword">auto</span> rightshapes = std::<span class="built_in">vector</span>&lt;Object*&gt;(middling, ending);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert</span>(objects.<span class="built_in">size</span>() == (leftshapes.<span class="built_in">size</span>() + rightshapes.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">        node-&gt;left = <span class="built_in">recursiveBuild</span>(leftshapes);</span><br><span class="line">        node-&gt;right = <span class="built_in">recursiveBuild</span>(rightshapes);</span><br><span class="line"></span><br><span class="line">        node-&gt;bounds = <span class="built_in">Union</span>(node-&gt;left-&gt;bounds, node-&gt;right-&gt;bounds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求交</span></span><br><span class="line"><span class="function">Intersection <span class="title">BVHAccel::getIntersection</span><span class="params">(BVHBuildNode* node, <span class="type">const</span> Ray&amp; ray)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// TODO Traverse the BVH to find intersection</span></span><br><span class="line">    Intersection isect;</span><br><span class="line">    <span class="keyword">if</span> (!node-&gt;bounds.<span class="built_in">IntersectP</span>(ray, ray.direction_inv, std::array&#123;(<span class="type">int</span>)ray.direction.x, (<span class="type">int</span>)ray.direction.y, (<span class="type">int</span>)ray.direction.z&#125;))</span><br><span class="line">        <span class="keyword">return</span> isect;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> node-&gt;object-&gt;<span class="built_in">getIntersection</span>(ray);</span><br><span class="line">    Intersection isect_r = <span class="built_in">getIntersection</span>(node-&gt;right, ray);</span><br><span class="line">    Intersection isect_l = <span class="built_in">getIntersection</span>(node-&gt;left, ray);</span><br><span class="line">    <span class="keyword">if</span> (!isect_r.happened &amp;&amp; !isect_l.happened) <span class="keyword">return</span> isect;</span><br><span class="line">    <span class="keyword">return</span> isect_r.distance &lt; isect_l.distance ? isect_r : isect_l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2022-x2F-05-x2F-31"><a href="#2022-x2F-05-x2F-31" class="headerlink" title="2022&#x2F;05&#x2F;31"></a>2022&#x2F;05&#x2F;31</h2><h3 id="SAH加速求交："><a href="#SAH加速求交：" class="headerlink" title="SAH加速求交："></a>SAH加速求交：</h3><ol>
<li>SAH加速的目标主要是在优化</li>
</ol>
<p>$$<br>C &#x3D; Ctrav + SA&#x2F;SN * NA * Cisect + SB&#x2F;SN * NB * Cisect<br>$$</p>
<p>这个时间开销上。</p>
<p>又因为，针对同一个父节点，不同划分方式下的子节点Ctrav、SN、Cisect 都相同，所以可以被省略掉，得到一个相对的时间开销：</p>
<p>$$<br>C* &#x3D; SA * NA + SB * NB<br>$$</p>
<ol start="2">
<li>于此同时，还可以通过将遍历的次数从N-1，缩小到确定值B来进行加速。<ol>
<li>具体来说，原本一共有N个objects，如果是按照原本的划分方法，一共有N-1次种划分方法，需要循环N-1次；但如果是限制为均匀划分为B个桶，那么只用循环B次。这里设置B为min(10, objects.size())。</li>
<li>要注意迭代器的使用时的边界问题。</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是均匀划分B个桶,这样的话,只用循环B次.</span></span><br><span class="line"><span class="comment">// 优化一下,objects.size()小于10的,那么B = objects.size().</span></span><br><span class="line"><span class="type">int</span> B = std::<span class="built_in">min</span>(<span class="number">10</span>, (<span class="type">int</span>)objects.<span class="built_in">size</span>());</span><br><span class="line"><span class="type">int</span> best_index = <span class="number">1</span>;</span><br><span class="line"><span class="type">double</span> best_time_cost = std::numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; B; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> separate_num = objects.<span class="built_in">size</span>() * i / B;</span><br><span class="line">    Bounds3 bounds_1, bounds_2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; objects.<span class="built_in">size</span>(); ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; separate_num) bounds_1 = <span class="built_in">Union</span>(bounds_1, objects[j]-&gt;<span class="built_in">getBounds</span>());</span><br><span class="line">        <span class="keyword">else</span> bounds_2 = <span class="built_in">Union</span>(bounds_2, objects[j]-&gt;<span class="built_in">getBounds</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> S1 = bounds_1.<span class="built_in">SurfaceArea</span>();</span><br><span class="line">    <span class="type">double</span> S2 = bounds_2.<span class="built_in">SurfaceArea</span>();</span><br><span class="line">    <span class="type">double</span> time_cost = S1 * separate_num + S2 * (objects.<span class="built_in">size</span>() - separate_num);</span><br><span class="line">    <span class="keyword">if</span> (time_cost &lt; best_time_cost)</span><br><span class="line">    &#123;</span><br><span class="line">        best_time_cost = time_cost;</span><br><span class="line">        best_index = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; best_index &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// beginning指向vector第一个元素</span></span><br><span class="line"><span class="comment">// ending指向vector最后一个元素的后面那个空位,而不是最后一位元素</span></span><br><span class="line"><span class="keyword">auto</span> beginning = objects.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> middling = objects.<span class="built_in">begin</span>() + objects.<span class="built_in">size</span>() * best_index / B;</span><br><span class="line"><span class="keyword">auto</span> ending = objects.<span class="built_in">end</span>();</span><br><span class="line"><span class="comment">// 注意,是取不到middling这个下标的,只取得到前一位(左闭右开)</span></span><br><span class="line"><span class="comment">// 所以迭代器begin()+i,下面这种构造方式内就只有i个元素</span></span><br><span class="line"><span class="keyword">auto</span> leftshapes = std::<span class="built_in">vector</span>&lt;Object*&gt;(beginning, middling);</span><br><span class="line"><span class="keyword">auto</span> rightshapes = std::<span class="built_in">vector</span>&lt;Object*&gt;(middling, ending);</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert</span>(objects.<span class="built_in">size</span>() == (leftshapes.<span class="built_in">size</span>() + rightshapes.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">node-&gt;left = <span class="built_in">recursiveBuild</span>(leftshapes);</span><br><span class="line">node-&gt;right = <span class="built_in">recursiveBuild</span>(rightshapes);</span><br><span class="line"></span><br><span class="line">node-&gt;bounds = <span class="built_in">Union</span>(node-&gt;left-&gt;bounds, node-&gt;right-&gt;bounds);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在求交的时候，依旧存在一个加速的方法。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> t_Min_x = (pMin.x - ray.origin.x)*invDir[<span class="number">0</span>];</span><br><span class="line"><span class="type">float</span> t_Min_y = (pMin.y - ray.origin.y)*invDir[<span class="number">1</span>];</span><br><span class="line"><span class="type">float</span> t_Min_z = (pMin.z - ray.origin.z)*invDir[<span class="number">2</span>];</span><br><span class="line"><span class="type">float</span> t_Max_x = (pMax.x - ray.origin.x)*invDir[<span class="number">0</span>];</span><br><span class="line"><span class="type">float</span> t_Max_y = (pMax.y - ray.origin.y)*invDir[<span class="number">1</span>];</span><br><span class="line"><span class="type">float</span> t_Max_z = (pMax.z - ray.origin.z)*invDir[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果发现射线的方向是反的，调换t_min和t_max的位置。</span></span><br><span class="line"><span class="keyword">if</span>(dirIsNeg[<span class="number">0</span>])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> t = t_Min_x;</span><br><span class="line">    t_Min_x = t_Max_x;</span><br><span class="line">    t_Max_x = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dirIsNeg[<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> t = t_Min_y;</span><br><span class="line">    t_Min_y = t_Max_y;</span><br><span class="line">    t_Max_y = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dirIsNeg[<span class="number">2</span>])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> t = t_Min_z;</span><br><span class="line">    t_Min_z = t_Max_z;</span><br><span class="line">    t_Max_z = t;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">float</span> t_enter = std::<span class="built_in">max</span>(t_Min_x, std::<span class="built_in">max</span>(t_Min_y, t_Min_z));</span><br><span class="line"><span class="type">float</span> t_exit  = std::<span class="built_in">min</span>(t_Max_x, std::<span class="built_in">min</span>(t_Max_y, t_Max_z));</span><br><span class="line"><span class="keyword">if</span>(t_enter &lt; t_exit &amp;&amp; t_exit &gt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>dirIsNeg的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Intersection <span class="title">BVHAccel::getIntersection</span><span class="params">(BVHBuildNode* node, <span class="type">const</span> Ray&amp; ray)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// TODO Traverse the BVH to find intersection</span></span><br><span class="line">    Intersection isect;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 3&gt; dirIsNeg;</span><br><span class="line">    dirIsNeg[<span class="number">0</span>] = ray.direction.x &lt; <span class="number">0</span>;</span><br><span class="line">    dirIsNeg[<span class="number">1</span>] = ray.direction.y &lt; <span class="number">0</span>;</span><br><span class="line">    dirIsNeg[<span class="number">2</span>] = ray.direction.z &lt; <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Note：IntersectP()参数最后是一个引用，这里这样写，是直接传了右值std::array&#123;(int)ray.direction.x, (int)ray.direction.y, (int)ray.direction.z&#125;</span></span><br><span class="line">    <span class="comment">// 和引用绑定。这样是不行的，因为右值的内存在语句结束后就会被释放，就算和引用绑定也没有用了。</span></span><br><span class="line">    <span class="comment">// 所以，函数的参数是指针或者引用的时候，不能传右值，只能传左值，因为不会开辟新的内存。&lt;传地址&gt;；</span></span><br><span class="line">    <span class="comment">// 同理，函数的参数传递如果是&lt;传值&gt;，那就可以传右值，因为是开辟了一个新的内存copy。</span></span><br><span class="line">    <span class="comment">// if (!node-&gt;bounds.IntersectP(ray, ray.direction_inv, std::array&#123;(int)ray.direction.x, (int)ray.direction.y, (int)ray.direction.z&#125;))</span></span><br><span class="line">    <span class="keyword">if</span> (!node-&gt;bounds.<span class="built_in">IntersectP</span>(ray, ray.direction_inv, dirIsNeg))</span><br><span class="line">        <span class="keyword">return</span> isect;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> node-&gt;object-&gt;<span class="built_in">getIntersection</span>(ray);</span><br><span class="line">    Intersection isect_r = <span class="built_in">getIntersection</span>(node-&gt;right, ray);</span><br><span class="line">    Intersection isect_l = <span class="built_in">getIntersection</span>(node-&gt;left, ray);</span><br><span class="line">    <span class="keyword">if</span> (!isect_r.happened &amp;&amp; !isect_l.happened) <span class="keyword">return</span> isect;</span><br><span class="line">    <span class="keyword">return</span> isect_r.distance &lt; isect_l.distance ? isect_r : isect_l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么可以用dir的正负来进行求交的加速呢？</strong></p>
<p>这里是由于：<br>$$<br>p &#x3D; t * dir + oringin，所以 t &#x3D; (p - origin) &#x2F; dir<br>$$<br>pmax点对应计算出的t_max 与 pmin点对应计算出的t_min的大小关系可以相减得到：</p>
<p>$$<br>t_max - t_min &#x3D; (pmax - pmin) &#x2F; dir ①<br>$$<br>又因为pmax的三维分量一定是 &gt; pmin的，所以式①的正负由dir的正负决定。且p_max一定 &gt; p_min，因此t_min ≠ t_max，因此t_min和t_max只有两种大小关系。</p>
<p>又因为x&#x2F;y&#x2F;z轴每个分量的t_min和t_max需要用于计算t_enter和t_exit，我们希望t_min代表进入对面，t_max代表离开对面，这就意味着t_min &lt; t_max一定需要成立。</p>
<p><strong>因此，若dir &gt; 0，那么计算出来的t_min &lt; t_max，满足我们的期望；反之，t_min &gt; t_max，与我们的期望不符合，所以需要将这两个值进行互换。</strong></p>
<h3 id="结果如下："><a href="#结果如下：" class="headerlink" title="结果如下："></a>结果如下：</h3><p>这里是没有加dir&lt;0判断加速的BVH耗时：</p>
<p><img src="/images/GAMES101/RunTimeBVH.png" alt="RunTimeBVH"></p>
<p>这里是使用了SAH，dir&lt;0，以及划分桶进行加速的耗时：</p>
<p><img src="/images/GAMES101/RunTimeSAH.png" alt="RunTimeSAH"></p>
<p>渲染结果如下图所示：</p>
<p><img src="/images/GAMES101/output_BVH.png" alt="output_BVH"></p>
<p>BVH和加速之后的结果一样，这里只放一张。</p>
<h1 id="Hw07"><a href="#Hw07" class="headerlink" title="Hw07"></a>Hw07</h1><h2 id="2022-x2F-06-x2F-08"><a href="#2022-x2F-06-x2F-08" class="headerlink" title="2022&#x2F;06&#x2F;08"></a>2022&#x2F;06&#x2F;08</h2><p>完成了Path Tracing、多线程、Microfacet。</p>
<p>课程讲解主要是遵循diffuse的情况进行的。因此，代码中的material中关于BRDF和光线的采样，以及pdf都是有关联的。</p>
<p>diffuse的采样是在整个半球空间中进行的（因为漫反射方向是四面八方，且光线可逆，因此入射光线的采样方向也是四面八方），且是均匀采样，因此pdf &#x3D; 1&#x2F;2Π；</p>
<p>值得注意的是，因为方形的obj是面，可能会存在n和wo的夹角cos值&lt;0（也就是不在正半球方向上，夹角大于2&#x2F;Π）。其次，如果在triangle求交上，没有在原代码的基础上判断t &lt; 0的情况，那么渲染结果就会缺一角。</p>
<p>同时，在方向角上的积分应用diffuse的性质，可以得到BRDF的值等于abedo&#x2F;Π；abedo∈[0, 1]。</p>
<p><img src="/images/GAMES101/t_wrong.png" alt="t_wrong"></p>
<p>因为这个渲染是在CPU上，所以可以用多线程来进行并行渲染，有两种方法，一种是使用thread库，另一种是使用omp库。注意不要忘记virtual box的cpu核心数需要修改。</p>
<p>注意两者写法上的不同。</p>
<p>在这里使用了匿名函数renderRows，具体来说，就是每个线程分配不同行数的像素进行渲染，因为需要写同一个变量，所以需要加互斥锁进行保护。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采样数/pixel</span></span><br><span class="line"><span class="type">int</span> spp = <span class="number">1024</span>;</span><br><span class="line"><span class="comment">// MSAA采样形状一定是方形</span></span><br><span class="line"><span class="type">int</span> size_msaa = <span class="built_in">sqrt</span>(spp);</span><br><span class="line"><span class="type">float</span> spp_step = <span class="number">1.f</span> / (<span class="type">float</span>)size_msaa;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;SPP: &quot;</span> &lt;&lt; spp &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="comment">// for (uint32_t j = 0; j &lt; scene.height; ++j) &#123;</span></span><br><span class="line"><span class="comment">//     for (uint32_t i = 0; i &lt; scene.width; ++i) &#123;</span></span><br><span class="line"><span class="comment">//         // generate primary ray direction</span></span><br><span class="line"><span class="comment">//         float x = (2 * (i + 0.5) / (float)scene.width - 1) *</span></span><br><span class="line"><span class="comment">//                   imageAspectRatio * scale;</span></span><br><span class="line"><span class="comment">//         float y = (1 - 2 * (j + 0.5) / (float)scene.height) * scale;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         Vector3f dir = normalize(Vector3f(-x, y, 1));</span></span><br><span class="line"><span class="comment">//         for (int k = 0; k &lt; spp; k++)&#123;</span></span><br><span class="line"><span class="comment">//             framebuffer[m] += scene.castRay(Ray(eye_pos, dir), 0) / spp;  </span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         m++;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     UpdateProgress(j / (float)scene.height);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="type">int</span> num_threads = <span class="number">16</span>;</span><br><span class="line"><span class="type">int</span> thread_height = scene.height / num_threads;</span><br><span class="line"><span class="comment">// ====================thread====================</span></span><br><span class="line"><span class="comment">// std::thread th[num_threads];</span></span><br><span class="line"><span class="comment">// auto renderRows = [&amp;](uint32_t start_height, uint32_t end_height)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     for (uint32_t j = start_height; j &lt; end_height; ++j)</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         for (uint32_t i = 0; i &lt; scene.width; ++i)</span></span><br><span class="line"><span class="comment">//         &#123;</span></span><br><span class="line"><span class="comment">//             // generate primary ray direction</span></span><br><span class="line"><span class="comment">//             // float x = (2 * (i + 0.5) / (float)scene.width - 1) *</span></span><br><span class="line"><span class="comment">//             //         imageAspectRatio * scale;</span></span><br><span class="line"><span class="comment">//             // float y = (1 - 2 * (j + 0.5) / (float)scene.height) * scale;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//             // Vector3f dir = normalize(Vector3f(-x, y, 1));</span></span><br><span class="line"><span class="comment">//             // for (int k = 0; k &lt; spp; k++)&#123;</span></span><br><span class="line"><span class="comment">//             //     framebuffer[(int)(j * scene.width + i)] += scene.castRay(Ray(eye_pos, dir), 0) / spp;  </span></span><br><span class="line"><span class="comment">//             // &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//             // MSAA 抗锯齿</span></span><br><span class="line"><span class="comment">//             for (int k = 0; k &lt; spp; k++)&#123;</span></span><br><span class="line"><span class="comment">//                 float x = (2.0f * (i + spp_step / 2.0f + k % size_msaa) / (float)scene.width - 1) *</span></span><br><span class="line"><span class="comment">//                         imageAspectRatio * scale;</span></span><br><span class="line"><span class="comment">//                 float y = (1 - 2.0f * (j + spp_step / 2.0f + k / size_msaa) / (float)scene.height) * scale;</span></span><br><span class="line"><span class="comment">//                 Vector3f dir = normalize(Vector3f(-x, y, 1));</span></span><br><span class="line"><span class="comment">//                 framebuffer[(int)(j * scene.width + i)] += scene.castRay(Ray(eye_pos, dir), 0) / spp;  </span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         mtx.lock();</span></span><br><span class="line"><span class="comment">//         progress++;</span></span><br><span class="line"><span class="comment">//         UpdateProgress(progress / (float)scene.height);</span></span><br><span class="line"><span class="comment">//         mtx.unlock();</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"><span class="comment">// for (int t = 0; t &lt; num_threads; ++t)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     th[t] = std::thread(renderRows, t * thread_height, (t + 1) * thread_height);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// for (int t = 0; t &lt; num_threads; ++t)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     th[t].join();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================OpenMP====================</span></span><br><span class="line"><span class="keyword">auto</span> renderRows = [&amp;](<span class="type">uint32_t</span> start_height, <span class="type">uint32_t</span> end_height)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> j = start_height; j &lt; end_height; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; scene.width; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// generate primary ray direction</span></span><br><span class="line">            <span class="comment">// float x = (2 * (i + 0.5) / (float)scene.width - 1) *</span></span><br><span class="line">            <span class="comment">//         imageAspectRatio * scale;</span></span><br><span class="line">            <span class="comment">// float y = (1 - 2 * (j + 0.5) / (float)scene.height) * scale;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Vector3f dir = normalize(Vector3f(-x, y, 1));</span></span><br><span class="line">            <span class="comment">// for (int k = 0; k &lt; spp; k++)&#123;</span></span><br><span class="line">            <span class="comment">//     framebuffer[(int)(j * scene.width + i)] += scene.castRay(Ray(eye_pos, dir), 0) / spp;  </span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// MSAA 抗锯齿</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; spp; k++)&#123;</span><br><span class="line">                <span class="type">float</span> x = (<span class="number">2.0f</span> * (i + spp_step / <span class="number">2.0f</span> + spp_step * (k % size_msaa)) / (<span class="type">float</span>)scene.width - <span class="number">1</span>) *</span><br><span class="line">                    imageAspectRatio * scale;</span><br><span class="line">                <span class="type">float</span> y = (<span class="number">1</span> - <span class="number">2.0f</span> * (j + spp_step / <span class="number">2.0f</span> + spp_step * (k / size_msaa)) / (<span class="type">float</span>)scene.height) * scale;</span><br><span class="line">                Vector3f dir = <span class="built_in">normalize</span>(<span class="built_in">Vector3f</span>(-x, y, <span class="number">1</span>));</span><br><span class="line">                framebuffer[(<span class="type">int</span>)(j * scene.width + i)] += scene.<span class="built_in">castRay</span>(<span class="built_in">Ray</span>(eye_pos, dir), <span class="number">0</span>) / spp;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">omp_set_lock</span>(&amp;lock1);</span><br><span class="line">        progress++;</span><br><span class="line">        <span class="built_in">UpdateProgress</span>(progress / (<span class="type">float</span>)scene.height);</span><br><span class="line">        <span class="built_in">omp_unset_lock</span>(&amp;lock1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt; num_threads; ++t)</span><br><span class="line">    <span class="built_in">renderRows</span>(t * thread_height, (t + <span class="number">1</span>) * thread_height);</span><br><span class="line"></span><br><span class="line"><span class="built_in">UpdateProgress</span>(<span class="number">1.f</span>);</span><br></pre></td></tr></table></figure>

<p>除此之外，需要将CmakeList.txt中加上对应的部分。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &lt;OpenMP&gt;</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CAMKE_CXX_FLAGS&#125; -O3 -fopenmp&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;thread&gt;</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(RayTracing pthread)</span><br></pre></td></tr></table></figure>

<p>同时，需要在框架提供的随机数生成函数中，将三个局部变量设置为static类型，从而减少运行时间：</p>
<p><img src="/images/GAMES101/without_static.png" alt="without_static"></p>
<p>加之前</p>
<p><img src="/images/GAMES101/with_static.png" alt="with_static"></p>
<p>加之后</p>
<p><img src="/images/GAMES101/without_MSAA.png" alt="without_MSAA"></p>
<p>纯镜面反射存在过度曝光问题：</p>
<p><img src="/images/GAMES101/specular_wrong.png" alt="specular_wrong"></p>
<h2 id="2022-x2F-06-x2F-11"><a href="#2022-x2F-06-x2F-11" class="headerlink" title="2022&#x2F;06&#x2F;11"></a>2022&#x2F;06&#x2F;11</h2><h3 id="回顾："><a href="#回顾：" class="headerlink" title="回顾："></a>回顾：</h3><p>因为使用的是<strong>蒙特卡洛</strong>方法近似渲染方程的结果：<br>$$<br>Lo &#x3D; Li * fr * cos(n, wi) &#x2F; p(wi)<br>$$<br>因此采样和计算都是基于这个框架进行的，需要做的就是修改渲染方程里面的BRDF(fr)。</p>
<h3 id="半球上的均匀采样："><a href="#半球上的均匀采样：" class="headerlink" title="半球上的均匀采样："></a>半球上的均匀采样：</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/49746076">球谐光照与PRT学习笔记（二）：蒙特卡洛积分与球面上的均匀采样 - 知乎 (zhihu.com)</a></p>
<p><img src="/images/GAMES101/%E5%9D%87%E5%8C%80%E9%87%87%E6%A0%B7.png" alt="均匀采样"></p>
<p>如果法线在世界坐标系中不是垂直向上，还要进行<strong>法线矫正</strong>，简单来说就是先将法线进行旋转，采样之后再将光线相对法线旋转回原来的位置。</p>
<p>额外参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/MASILEJFOAISEGJIAE/article/details/109532994">《用余生学习光线追踪》3.生成球坐标随机方向_Jack Mai的博客-CSDN博客</a></p>
<h3 id="解决了specular材质的过度曝光问题。"><a href="#解决了specular材质的过度曝光问题。" class="headerlink" title="解决了specular材质的过度曝光问题。"></a>解决了specular材质的<strong>过度曝光</strong>问题。</h3><p>首先，思考一下<strong>为什么会产生过度曝光</strong>？因为框架里面的path tracing是根据理想漫反射的情况分为了dir和indir两个部分（dir是<strong>对光源直接采样</strong>，indir是对非光源的部分进行采样，实际上是采到光源之后不进行处理，<strong>将其忽略掉</strong>，避免重复计算；并且<strong>能量大部分都是直接光照提供的，因此就算在这里实际上进行了两次采样，结果也不用&#x2F;2</strong>）。然而如果specular沿用这个框架，在对直接光照进行采样的时候<strong>只判断了n和wo的cos是否大于0</strong>，而没有判断是否满足镜面反射，所以只要采样的是光源，满足cos&gt;0的全部都加了起来，因此过曝了。</p>
<p>其次，再回顾一下，为什么需要拆分两个部分呢？因为引入了RR之后，如果只对立体角进行采样，那么有一种可能是循环停止时还采样不到光源，那么什么能量都没有，会造成巨大的浪费产生噪声，只能通过增大spp来减小噪声。</p>
<p>如果是理想diffuse上对立体角均匀采样的情况，造成的浪费只会是①dir中ray被物体挡住，以及②indir采到了光源或没碰到物体。</p>
<p>如果使用的是ggx(Microfacet)，对立体角均匀采样，浪费除了①和②，还会有③采样的光线分布不符合D(h)。</p>
<p>之所以diffuse的浪费不包括③，是因为diffuse的D(h)本身就是均匀分布的，在半球上永远会被满足，这是性质，也是前提。</p>
<p>故，为了避免浪费③，才会引入重要性采样（猜测）。而diffuse的pdf和它在Microfacet中对应D(h)的形状是一样的，因此本身就满足了重要性采样的特点。</p>
<h3 id="Specular的采样与pdf："><a href="#Specular的采样与pdf：" class="headerlink" title="Specular的采样与pdf："></a>Specular的采样与pdf：</h3><p>(1)只向镜面方向采样，对应概率为1(不是pdf)，根据D(h)进行重要性采样</p>
<p>采样方向：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SPECULAR:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 只采样 镜面反射方向</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reflect</span>(wi, N);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置对应的pdf为1（计算镜面反射出射能量的公式：Lo &#x3D; Li * Fresnel，但是不能直接用这个公式，因为引入了RR，需要除以这个部分的概率），而不是∞，因为会被δ(wi-wr)抵消（后面会解释）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SPECULAR:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dotProduct</span>(wo, N) &gt; <span class="number">0.0f</span>) <span class="keyword">return</span> <span class="number">1.0f</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	1)改写BRDF(×): 因为框架拆分了dir和indir，BRDF内部需要判断sampleLight生成的方向是否与wi是关于N对称的，相对来说，判断两个量是否相等是非常困难的，往往需要用差值与一个很小的EPSILON对比，这样会造成误差，所以不能这样做。</p>
<p>​	2)改写Path Tracing(√): 将拆分了dir和indir的框架退化为不拆分的基本框架，依旧引入RR，但是因为引入了重要性采样（只采样镜面反射的方向），所以不会造成浪费。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SPECULAR:</span><br><span class="line">&#123;</span><br><span class="line">    Vector3f L = &#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>&#125;;</span><br><span class="line">    <span class="comment">// 俄罗斯赌盘 是否继续采样</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">get_random_float</span>() &gt; RussianRoulette) <span class="keyword">return</span> L;</span><br><span class="line">    <span class="comment">// 对立体角采样 实际只有一个方向</span></span><br><span class="line">    Vector3f wi = p.m-&gt;<span class="built_in">sample</span>(ray.direction, p.normal);</span><br><span class="line">    <span class="type">float</span> pdf = p.m-&gt;<span class="built_in">pdf</span>(ray.direction, wi, p.normal);</span><br><span class="line">    <span class="function">Ray <span class="title">ray_i_indir</span><span class="params">(p.coords, wi)</span></span>;</span><br><span class="line">    Intersection q = <span class="built_in">intersect</span>(ray_i_indir);</span><br><span class="line">    <span class="keyword">if</span> (q.happened)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> div = pdf * RussianRoulette;</span><br><span class="line">        L = <span class="built_in">castRay</span>(ray_i_indir, ++depth) * p.m-&gt;<span class="built_in">eval</span>(ray.direction, wi, p.normal) * <span class="built_in">dotProduct</span>(wi, p.normal) / std::<span class="built_in">max</span>(div , EPSILON);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2)纯镜面反射的BRDF推导：</p>
<p><img src="/images/GAMES101/BRDF_1.jpg" alt="BRDF_1"></p>
<p><img src="/images/GAMES101/BRDF_2.jpg" alt="BRDF_2"></p>
<p>若使①&#x3D;②式，那么delta函数与p(wi)的值相除得 &#x3D; 1，那么在<strong>代码</strong>中，采样镜面方向的pdf则是1，delta函数的值也设置为1（其实就是直接忽略brdf中的delta和p以及cos，直接用公式①，这样也没问题，将brdf的部分简化为只有fresnel项，然后与一个Li相乘即可，这里只是推导全镜面反射的brdf如何求）。</p>
<p>从上面我们可以看到，不论是重要性采样（只采样一个方向，因为是完全镜面的，姑且叫做重要性采样），还是均匀采样，都可以得到正确的结果，这也是为什么MC方法的分母不管取什么形状的pdf都一定无偏的原因，但是同时我们也知道，如果使用均匀采样(均匀采样的时候，BRDF项需要判断wi和wr是否相等，如果不相等，那么返回值为0，因为重要性采样的时候已经满足了相等的绝对条件，但是记住，判断相等是非常麻烦的一件事)，那么造成的浪费会很大，尤其是这种纯镜面反射的情况(必须要进行非常多的采样，才能采样到镜面方向)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SPECULAR:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Specular只考虑fresnel和delta函数(D(h))</span></span><br><span class="line">    <span class="comment">// 这里 wi一定是和wo相对于n对称的 所以delta函数值一定是∞</span></span><br><span class="line">    <span class="type">float</span> cosalpha = <span class="built_in">dotProduct</span>(N, wo);</span><br><span class="line">    <span class="keyword">if</span> (cosalpha &gt; <span class="number">0.0f</span>) &#123;</span><br><span class="line">        <span class="type">float</span> kr;</span><br><span class="line">        <span class="built_in">fresnel</span>(wi, N, ior, kr);</span><br><span class="line">        <span class="comment">// 是根据全镜面反射的定义来的</span></span><br><span class="line">        <span class="comment">// Lo = Fresnel * Li(i与r关于n对称)</span></span><br><span class="line">        Vector3f specular = kr / std::<span class="built_in">max</span>(cosalpha, EPSILON);</span><br><span class="line">        <span class="keyword">return</span> specular;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Vector3f</span>(<span class="number">0.0f</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里原本fr&#x3D;δ(wi-wr)*F&#x2F;cosθi，但是由于wi&#x3D;&#x3D;wr，所以冲激函数值为∞，它理论上会被渲染方程里面的pdf所抵消，所以这里也和pdf一样设置为1即可。</p>
<h3 id="追加："><a href="#追加：" class="headerlink" title="追加："></a>追加：</h3><p>那么可能有的同学会问，既然镜面反射只需要采样一个方向，那么是不是不用采样这么多次再取平均呢？</p>
<p>注意，虽然蒙特卡罗方法确实是通过反复模拟求平均来接近真实值，但是这个反复采样的过程不是在着色点上进行的。回顾一下，最开始的思路确实是在着色点上采样N次，但是这样会导致递归的时候循环指数爆炸，因此进行简化，只在像素上进行N次采样的。也就是说，只要场景中存在需要随机采样入射光线方向的材质（比如纯漫反射材质），那么就会存在随机性，就算确实这条光线之后会采样到同一个镜面材质的着色点，但它的wo可能不一样，那么wi一定就不一样。</p>
<p>渲染结果(spp&#x3D;10000)：</p>
<p><img src="/images/GAMES101/specular.png" alt="specular"></p>
<h3 id="MSAA-抗锯齿"><a href="#MSAA-抗锯齿" class="headerlink" title="MSAA 抗锯齿"></a>MSAA 抗锯齿</h3><p>在没有实现MSAA的情况下，可以看到边缘会有走样的现象。</p>
<p>因此，参考MSAA的思想，将pixel平均分为spp个方格(super sampling)，向方格中心发射ray进行采样，然后取平均(blur)。</p>
<p>回顾：超采样划分出来的小像素的<strong>面积</strong>作为概率（一般都是平均划分，所以是均匀分布），值为向小像素中心发射出的射线计算出的颜色，其实最后的大像素的值就是各个小像素的颜色的<strong>期望</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MSAA 抗锯齿</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; spp; k++)&#123;</span><br><span class="line">    <span class="type">float</span> x = (<span class="number">2.0f</span> * (i + spp_step / <span class="number">2.0f</span> + spp_step * (k % size_msaa)) / (<span class="type">float</span>)scene.width - <span class="number">1</span>) *</span><br><span class="line">        imageAspectRatio * scale;</span><br><span class="line">    <span class="type">float</span> y = (<span class="number">1</span> - <span class="number">2.0f</span> * (j + spp_step / <span class="number">2.0f</span> + spp_step * (k / size_msaa)) / (<span class="type">float</span>)scene.height) * scale;</span><br><span class="line">    Vector3f dir = <span class="built_in">normalize</span>(<span class="built_in">Vector3f</span>(-x, y, <span class="number">1</span>));</span><br><span class="line">    framebuffer[(<span class="type">int</span>)(j * scene.width + i)] += scene.<span class="built_in">castRay</span>(<span class="built_in">Ray</span>(eye_pos, dir), <span class="number">0</span>) / spp;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：可以看到边缘确实没有锯齿了。</p>
<p><img src="/images/GAMES101/MSAA.png" alt="MSAA"></p>
<h3 id="GGX-不完整，没推导公式"><a href="#GGX-不完整，没推导公式" class="headerlink" title="GGX (不完整，没推导公式)"></a>GGX (不完整，没推导公式)</h3><p>根据OpenGL教程来编写GGX的Fresnel、D(h)和G(i, o, n)函数。</p>
<p>引入了roughness(影响D以及G值)以及metalness(影响F值)两个参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://learnopengl.com/PBR/Theory</span></span><br><span class="line"><span class="comment">// https://blog.csdn.net/weixin_44518102/article/details/122698851?spm=1001.2101.3001.6650.9&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-9.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-9.pc_relevant_default&amp;utm_relevant_index=12</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">DistributionGGX</span><span class="params">(<span class="type">const</span> Vector3f&amp; N, <span class="type">const</span> Vector3f&amp; H, <span class="type">const</span> <span class="type">float</span>&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> a2 = a * a;</span><br><span class="line">    <span class="type">float</span> NdotH = std::<span class="built_in">max</span>(<span class="built_in">dotProduct</span>(N, H), <span class="number">0.0f</span>);</span><br><span class="line">    <span class="type">float</span> NdotH2 = NdotH * NdotH;</span><br><span class="line">    <span class="type">float</span> nom = a2;</span><br><span class="line">    <span class="type">float</span> denom = (NdotH2 * (a2 - <span class="number">1.0f</span>) + <span class="number">1.0f</span>);</span><br><span class="line">    denom = M_PI * denom * denom;</span><br><span class="line">    <span class="comment">// prevent divide by zero for roughness=0.0 and NdotH=1.0</span></span><br><span class="line">    <span class="keyword">return</span> nom / std::<span class="built_in">max</span>(denom, EPSILON);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">GeometrySchlickGGX</span><span class="params">(<span class="type">const</span> <span class="type">float</span>&amp; NdotV, <span class="type">const</span> <span class="type">float</span>&amp; k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> nom = NdotV;</span><br><span class="line">    <span class="type">float</span> denom = NdotV * (<span class="number">1.0f</span> - k) + k;</span><br><span class="line">    <span class="keyword">return</span> nom / denom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">GeometrySmith</span><span class="params">(<span class="type">const</span> Vector3f&amp; N, <span class="type">const</span> Vector3f&amp; V, <span class="type">const</span> Vector3f&amp; L, <span class="type">const</span> <span class="type">float</span>&amp; k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> NdotV = std::<span class="built_in">max</span>(<span class="built_in">dotProduct</span>(N, V), <span class="number">0.0f</span>);</span><br><span class="line">    <span class="type">float</span> NdotL = std::<span class="built_in">max</span>(<span class="built_in">dotProduct</span>(N, L), <span class="number">0.0f</span>);</span><br><span class="line">    <span class="type">float</span> ggx1 = <span class="built_in">GeometrySchlickGGX</span>(NdotV, k);</span><br><span class="line">    <span class="type">float</span> ggx2 = <span class="built_in">GeometrySchlickGGX</span>(NdotL, k);</span><br><span class="line">    <span class="keyword">return</span> ggx1 * ggx2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Vector3f <span class="title">fresnelSchlick</span><span class="params">(<span class="type">float</span>&amp; cosTheta, Vector3f&amp; F0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> F0 + (<span class="built_in">Vector3f</span>(<span class="number">1.0f</span>) - F0) * <span class="built_in">pow</span>(<span class="number">1.0f</span> - cosTheta, <span class="number">5.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的BRDF：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> GGX:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. Ks 是 Specular 系数，其实就是 DFG 中的F，也就是菲涅尔项。</span></span><br><span class="line">    <span class="comment">// 2. 框架中定义的 Kd 其实是 Color，在 Microfacet 中，Kd 的值应该是 1-Ks。</span></span><br><span class="line">    <span class="comment">// 3. 最后得到的 fr = Kd * fr_diffuse + Ks * fr_specular。也就是要分别计算漫反射部分和高光部分，</span></span><br><span class="line">    <span class="comment">// 所以不要只顾计算 DFG 而忘了前面的漫反射部分。</span></span><br><span class="line">    <span class="comment">// 4. 推荐看一下论坛上关于 Microfacet 讨论的这篇帖子，里面提到了很多典型问题，非常有启发性。</span></span><br><span class="line">    <span class="comment">// 5. （2021年8月17日 更新）重点： 在GAME202 第10讲的最后，闫老师批驳了这种使用 Kd 做光照损失补偿的计算方法，</span></span><br><span class="line">    <span class="comment">// 称其没有任何物理原理可言。使用 Microfacet 方法会导致物体变暗，尤其是 Roughness值较大的物体会变得很暗，</span></span><br><span class="line">    <span class="comment">// 主要原因是因为在计算时没有计算多次光线弹射导致的能量损失。闫老师在 GAMES202 中介绍了 Kulla-Conty 方法</span></span><br><span class="line">    <span class="comment">// 可以用于在实时渲染中进行能量补偿，可以参考。B站评论上有人说使用环境光进行补偿的方式是工业界经常使用的一种近似计算方法，</span></span><br><span class="line">    <span class="comment">// 不过个人感觉既然是在做学术界的作业，还是不要使用这在学术界上没有意义的计算方法。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Normal Distribution Function</span></span><br><span class="line">    <span class="comment">// 粗糙度</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dotProduct</span>(wo, N) &gt; <span class="number">0.0f</span>) &#123;</span><br><span class="line">        Vector3f V = -wi;</span><br><span class="line">        Vector3f L = wo;</span><br><span class="line">        Vector3f H = <span class="built_in">normalize</span>(V + L);</span><br><span class="line">        <span class="type">float</span> D = <span class="built_in">DistributionGGX</span>(N, H, roughness);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Geometry Function</span></span><br><span class="line">        <span class="type">float</span> G = <span class="built_in">GeometrySmith</span>(N, V, L, k);</span><br><span class="line"></span><br><span class="line">        <span class="function">Vector3f <span class="title">F0</span><span class="params">(<span class="number">0.04f</span>)</span></span>;</span><br><span class="line">        F0 = F0 * (<span class="number">1.0f</span> - metalness) + Kd * metalness;</span><br><span class="line">        <span class="type">float</span> cosTheta = <span class="built_in">dotProduct</span>(V, N);</span><br><span class="line">        Vector3f F = <span class="built_in">fresnelSchlick</span>(cosTheta, F0);</span><br><span class="line">        Vector3f ks_ = F;<span class="comment">//反射比率</span></span><br><span class="line">        Vector3f kd_ = <span class="built_in">Vector3f</span>(<span class="number">1.0f</span>) - ks_;<span class="comment">//折射比率</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// float F;</span></span><br><span class="line">        <span class="comment">// float etat = 1.85;</span></span><br><span class="line">        <span class="comment">// fresnel(wi, N, etat, F);</span></span><br><span class="line">        <span class="comment">// // 能量守恒</span></span><br><span class="line">        <span class="comment">// float ks_ = F;//反射比率</span></span><br><span class="line">        <span class="comment">// float kd_ = 1.0f - ks_;//折射比率</span></span><br><span class="line"></span><br><span class="line">        Vector3f diffuse = <span class="number">1.0f</span> / M_PI;</span><br><span class="line">        Vector3f nominator = D * G * F;</span><br><span class="line">        <span class="type">float</span> denominator = <span class="number">4.0f</span> * <span class="built_in">dotProduct</span>(N, V) * <span class="built_in">dotProduct</span>(N, L);</span><br><span class="line">        Vector3f specular = nominator / std::<span class="built_in">max</span>(denominator, EPSILON);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为在 specular 项里已经考虑了反射部分的比例：F。所以反射部分不需要再乘以 ks_ </span></span><br><span class="line">        <span class="comment">// Ks为镜面反射项，Kd为漫反射项。</span></span><br><span class="line">        <span class="comment">// return Ks * specular + kd_ * Kd * diffuse;</span></span><br><span class="line">        <span class="keyword">return</span> specular + kd_ * diffuse;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Vector3f</span>(<span class="number">0.0f</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看一个ggx一个specular的效果，roughness&#x3D;0.1，metalness&#x3D;1.0：</p>
<p><img src="/images/GAMES101/specular_ggx.png" alt="specular_ggx"></p>
<h4 id="自遮挡"><a href="#自遮挡" class="headerlink" title="自遮挡"></a>自遮挡</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/412659008">图形渲染基础：微表面材质模型 - 知乎 (zhihu.com)</a></p>
<p><img src="C:\Users\Moony\AppData\Roaming\Typora\typora-user-images\image-20230110091143969.png" alt="image-20230110091143969"></p>
<p>所以，能量补偿是因为粗糙度增加的时候，G造成的能量损失。</p>
<p><img src="C:\Users\Moony\AppData\Roaming\Typora\typora-user-images\image-20230110091439015.png" alt="image-20230110091439015"></p>
<h3 id="重要性采样-还没做"><a href="#重要性采样-还没做" class="headerlink" title="重要性采样  (还没做)"></a>重要性采样  (还没做)</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/337044893">蒙特卡洛积分与重要性采样 - 知乎 (zhihu.com)</a>：这是强化学习中，为了计算f(x)的期望引入的重要性采样，图形学是直接计算f(x)的积分。虽然他们的共同点在于都使用了蒙特卡洛积分的思想。前者是利用“通过按照函数的分布进行采样求和来近似这个函数”；后者是直接用蒙特卡洛积分进行数值求解。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/396618080">采样理论概述（逆变换采样、拒绝采样） - 知乎 (zhihu.com)</a>：用在皮肤渲染中</p>
<p>前面我们说可以使用任意一个PDF来进行采样以计算蒙特卡洛积分，那么究竟哪种PDF是最好的呢？这就是重要性采样所回答的问题。一般来说，衡量的标准有如下两种：</p>
<ol>
<li>相同的样本数先达到收敛</li>
<li>达到收敛所用到的样本数量越少越好</li>
</ol>
<p><strong>PDF和积分函数形越的像，则该PDF越好</strong>。实际中如果无法确定积分函数 f(x) 的形状，可以先用很少的样本采样，拟合一个简单的曲线，再根据该曲线进行采样，这种方法也叫做 <code>adapt sampling</code> 方法。</p>
<p><strong>多重重要性采样</strong></p>
<p>前面我们说过，概率密度函数（PDF）和积分函数形状越相似，效果越好。现有如下所示的积分函数 f(x) 和两个概率密度函数 p1(x),p2(x) ，是否有一种方法可以联合这两个PDF，以使积分达到最好的效果呢？</p>
<p><img src="C:\Users\Moony\AppData\Roaming\Typora\typora-user-images\image-20230109022135215.png" alt="image-20230109022135215"></p>
<h4 id="逆累计分布函数"><a href="#逆累计分布函数" class="headerlink" title="逆累计分布函数"></a>逆累计分布函数</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/396618080">采样理论概述（逆变换采样、拒绝采样） - 知乎 (zhihu.com)</a></p>
<p><img src="C:\Users\Moony\AppData\Roaming\Typora\typora-user-images\image-20230109150644062.png" alt="image-20230109150644062"></p>
<p>在重要性采样中的应用则是，找到了一个和f(x)形状类似的pdf后，无法通过计算机直接对x进行采样，这时：</p>
<ol>
<li>通过pdf计算cdf；</li>
<li>对cdf的值域进行均匀采样，也就是rand[0,1]；</li>
<li>然后对cdf求逆找到y对应的x，完成对x的采样。</li>
</ol>
<blockquote>
<p>要注意的是，上图的cdf的柱状体的高是pdf的高，也就是概率密度，不是概率，概率应该是柱形的面积，所以直接把最高的叠加h认为是1是错误的。</p>
<p>但是由于面积都是h*dx得到的，而dx是相等的，所以面积和h是成正比的，所以这个示意图关于cdf每个部分概率的结构是正确的。</p>
</blockquote>
<h4 id="NDF"><a href="#NDF" class="headerlink" title="NDF"></a>NDF</h4><p><strong>一般都是直接用NDF来进行重要性采样。</strong></p>
<p>首先，NDF是指表面的法线分布函数，且这个分布是<strong>垂直向上</strong>的。已知一个入射方向，且这个顶点的法线也是已知的，那么我们就可以求出一个反射方向。那么就先计算出NDF的CDF，然后0-1均匀采样，之后求逆分别得到θ和fi。</p>
<p>但是由于材质的法线是满足NDF的，所以这个顶点的法线原本应该需要采样得到，然后再去进行镜面反射得到反射方向。这个方式也等同于直接计算出原来的反射方向，然后将放射方向置于垂直水平向上，然后根据NDF去进行重要性采样，得到一个真正的反射方向。此时这个方向与原本垂直向上的相对夹角已知，最后将垂直向上的方向旋转至之前计算得到的原本的反射方向（也就是相对旋转），就可以真正采样得到的反射方向了。</p>
<p>补充：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/505284731">四、brdf重要性采样 - 知乎 (zhihu.com)</a></p>
<p><img src="C:\Users\Moony\AppData\Roaming\Typora\typora-user-images\image-20230110090636628.png" alt="image-20230110090636628"></p>
<h3 id="Gamma矫正-还没做"><a href="#Gamma矫正-还没做" class="headerlink" title="Gamma矫正 (还没做)"></a>Gamma矫正 (还没做)</h3><h1 id="光追怎么用贴图？"><a href="#光追怎么用贴图？" class="headerlink" title="光追怎么用贴图？"></a>光追怎么用贴图？</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/masilejfoaisegjiae/article/details/105804301">《用一周学习光线追踪》5.球面纹理贴图_Jack Mai的博客-CSDN博客_光线追踪 球体纹理</a></p>
<p><a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">Ray Tracing in One Weekend</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/MASILEJFOAISEGJIAE/article/details/104601464">《用两天学习光线追踪》1.项目介绍和ppm图片输出_Jack Mai的博客-CSDN博客</a></p>
<p>个人猜想：</p>
<p>导入renderer的obj的顶点应该也有自己的uv，光线与物体求交之后的着色点根据重心坐标插值uv，然后直接对纹理进行采样，然后根据纹理属性直接作为光照计算的参数即可。</p>
<p>其实插值过程和光栅化是一样的，不过一个是像素中心插值（需要根据depth还原到世界坐标系下然后再进行插值，即插值矫正），一个是世界坐标系下的交点插值（3D）。</p>
<h1 id="光追的相机的原理？"><a href="#光追的相机的原理？" class="headerlink" title="光追的相机的原理？"></a>光追的相机的原理？</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/masilejfoaisegjiae/article/details/104614989">(79条消息) 《用两天学习光线追踪》9.可放置相机_Jack Mai的博客-CSDN博客_uvn相机</a></p>
<h1 id="怎么将渲染方程用在实时渲染"><a href="#怎么将渲染方程用在实时渲染" class="headerlink" title="怎么将渲染方程用在实时渲染"></a>怎么将渲染方程用在实时渲染</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/158025828">彻底看懂PBR&#x2F;BRDF方程 - 知乎 (zhihu.com)</a></p>
<p>这个回答（第9点）主要解决了一个疑问：<strong>怎么将渲染方程用在实时渲染？</strong></p>
<p>方法是<strong>按照光源分类讨论，并且简化光源</strong>。</p>
<p>比如点光源：将光源看做一个点（只在固定的<strong>一个</strong>方向上有能量，也就是<strong>光源-&gt;着色点</strong>这个已知的方向，其他方向的能量统统不考虑，<strong>因此也不会进行递归，仿佛是只进行了一次弹射的光追</strong>），<strong>使用delta函数对渲染方程中的Li项进行转换</strong>，积分就变成了计算一个含有BRDF项的，与光源方向、距离、光照强度均有关的方程的值。</p>
<p>其实也可以发现这个做法和GAMES101作业中<strong>全镜面反射</strong>的公式中BRDF的推导有相似性（也是用的delta函数），有2种理解方式：</p>
<ol>
<li>原始方程积分：全镜面反射公式中的delta函数项将Li隐式转化到镜面反射方向Lo；</li>
<li>蒙特卡洛公式近似：如果将实时渲染看作用<strong>蒙特卡洛</strong>方法来近似，那么因为只采样<strong>一个已知方向</strong>上的光线，那么分母上fr内包含的delta函数值 &#x3D;&#x3D; ∞和分子上的p(wi) &#x3D;&#x3D; ∞又抵消了；</li>
<li>蒙特卡洛公式近似和直接积分的<strong>结果也是一样的</strong>。</li>
</ol>
<p>所以因此可以看出来，实时渲染和光追存在一些异同：</p>
<blockquote>
<p>共同点：</p>
<p>基于PBR的渲染，不论实时还是光追，都是根据<strong>渲染方程</strong>推导出射方向的能量；只是实时渲染对渲染方程中<strong>关于入射方向的采样进行了简化</strong>。</p>
<p>差异点：</p>
<ol>
<li>实时渲染使用PBR，是<strong>已知出射方向和入射方向</strong>，相当于只对直接光源进行一次固定方向的“采样”，因此<strong>不存在随机性</strong>（可以从蒙特卡洛积分中分子的p已经和delta抵消看出来）；所以相当于从一开始，蒙特卡洛方法中的N就 &#x3D; 1（因为N不管取多少平均值都一样）；</li>
<li>光追使用PBR，是<strong>已知出射方向</strong>，<strong>对入射方向进行采样</strong>，且分别需要对直接光源和<strong>非光源</strong>进行采样（因此是全局光照），<strong>存在随机性</strong>。蒙特卡洛方法中在着色点发射的光线的N虽然简化为了1，但是在pixel发射光线的时候需要增大采样数，从而减少噪声。</li>
<li>根据2-3点可以看出来，实时渲染得到的结果理论上应该是光追的一个<strong>子集</strong>，实时渲染只考虑入射&#x3D;直接光照的部分，而光追需要在半球上对入射方向进行采样，因此不仅考虑了入射&#x3D;直接光照的部分，还考虑了入射&#x3D;间接光照的部分，是全局光照。</li>
<li>另：抗锯齿（以MSAA为例）</li>
<li>实时渲染是对每一个面片遍历pixel进行着色，将pixel划分为小格，每个格子分别先判断其<strong>中心</strong>是否在三角面片中，然后再使用插值得到的这个中心位置的属性值进行着色（<strong>一次</strong>）之后blur；</li>
<li>光追是将每一个pixel划分为N &#x3D; 采样数的小格，然后分别向小格<strong>中心</strong>发射光束，进行RT计算出结果（因为存在间接光照，会<strong>着色很多次</strong>），然后进行blur。</li>
</ol>
<p>综上，光追的计算开销相对于实时渲染而言会更大，但是因为考虑了全局光照因此会更加接近真实。</p>
</blockquote>
<h1 id="光照计算的框架"><a href="#光照计算的框架" class="headerlink" title="光照计算的框架"></a>光照计算的框架</h1><p><strong>描述光照计算的具体计算框架 &#x3D;&#x3D; 光照模型。</strong></p>
<p>从Phong Shading开始，光照计算就已经分为了两个大的部分：漫反射分量+镜面反射分量。其中，漫反射分量基于Lambertian模型，后续有在视觉上进行改进的half-Lambertian模型；镜面反射则基于Phong或Blinn-Phong模型。尽管上述的模型是<strong>经验模型</strong>，但光照计算的大体框架已经形成。</p>
<p>如今，已经发展至基于PBR的渲染，其光照计算虽然从渲染方程出发，但是依旧分为漫反射分量+镜面反射分量两大块。其中，每一块的理论基础都是渲染方程，<strong>唯一不同的就是渲染方程中的BRDF项</strong>。因此，关于渲染方程的建模，其本质即BRDF如何建模（如何写出不同材质的BRDF决定式？），是一个很大的研究课题。</p>
<h2 id="BRDF和渲染方程"><a href="#BRDF和渲染方程" class="headerlink" title="BRDF和渲染方程"></a>BRDF和渲染方程</h2><p>BRDF：使用<strong>光学</strong>的手段，研究出射方向的能量和入射方向的能量的关系。</p>
<p>需要注意，Cook-Torrance BRDF是第一个基于物理的BRDF决定式模型，在1982年提出，早于渲染方程的提出（1986）。</p>
<p>此后，渲染方程的提出以及之后对渲染方程的求解，推动了图形学的发展，使得可以利用BRDF的决定式或用光学仪器测量出的BRDF数值，使用<strong>计算机技术</strong>进行场景的渲染；之后图形学的发展，反向推动了更精确的对基于物理的BRDF的建模。</p>
<ol>
<li>BRDF定义式引入辐射度量学 + 能量守恒 &#x3D;&gt; 渲染方程，奠定基于物理的渲染的基础</li>
<li>渲染方程用于计算光照着色 &#x3D;&gt; 推动BRDF决定式的更精确的建模</li>
</ol>
<h2 id="BRDF和材质"><a href="#BRDF和材质" class="headerlink" title="BRDF和材质"></a>BRDF和材质</h2><p>不同材质(material)有不同的视觉效果，这种视觉效果是因为光线在物体表面产生了不同的交互形成的，而BRDF就是用于描述出射光线能量与入射光线能量之间的关系的，即不同的材质有不同的BRDF，<strong>研究材质就等于研究BRDF</strong>。</p>
<h2 id="什么是经验-x2F-物理BRDF"><a href="#什么是经验-x2F-物理BRDF" class="headerlink" title="什么是经验&#x2F;物理BRDF"></a>什么是经验&#x2F;物理BRDF</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/500811555">一些有光泽材质的经验模型：Phong BRDF、Ward BRDF、Ashikhmin-Shirley BRDF - 知乎 (zhihu.com)</a></p>
<p>就是通过测量光学数据后，对入射和反射进行拟合近似的模型，可能不符合一些物理特性；而物理BRDF则是完全基于物理原理和公式的模型。</p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>BTDF：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/508488223">实时皮肤渲染——BTDF - 知乎 (zhihu.com)</a></p>
<p>BSDF：<a target="_blank" rel="noopener" href="https://docs.blender.org/manual/zh-hans/dev/render/shader_nodes/shader/principled.html">原理化BSDF — Blender Manual</a></p>
<p>Disney BSDF：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/407007915">【渲染】Disney BSDF 深度解析 - 知乎 (zhihu.com)</a></p>
<p>BSDF &#x3D; BRDF + BTDF：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/26389307">(14 封私信 &#x2F; 80 条消息) 怎么正确理解BSDF和BRDF以及二者的关系？ - 知乎 (zhihu.com)</a></p>
<p>BSSRDF</p>
<p>概念可以参考：《Real-time Rendering 3rd》</p>
<h2 id="BSSRDF"><a href="#BSSRDF" class="headerlink" title="BSSRDF"></a>BSSRDF</h2><h3 id="光追"><a href="#光追" class="headerlink" title="光追"></a>光追</h3><p>其实也是用于表征入射点和出射点，入射光和出射光的比值。</p>
<p>如果是用在光追中，那么就是模拟在介质中发生的碰撞和吸收等物理现象。</p>
<p>所以，如果这个物体有无限的厚度和面积，那么光一定无法透过这个物体，只能从入射光相同的一侧出射。故，它无法得到从背面传递的能量，因此无法看到背后的物体。</p>
<p>近似方法有jessen提出的bssrdf方程。</p>
<h3 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h3><p>通过一系列近似方法进行计算，比如blur等。</p>
<h1 id="什么是基于物理的渲染-PBR-？"><a href="#什么是基于物理的渲染-PBR-？" class="headerlink" title="什么是基于物理的渲染(PBR)？"></a>什么是基于物理的渲染(PBR)？</h1><p>个人认为，基于物理是一个指应用在图形学渲染中的<strong>宽泛的概念</strong>，并不是指一个特定的概念，比如：</p>
<ol>
<li>PBR中渲染方程是基于<strong>辐射度量学</strong>这个物理现象提出的，考虑了能量的流动和守恒等；</li>
<li>BRDF的决定式中，漫反射BRDF中有cos(n, θi)的部分也是基于物理提出的；镜面反射BRDF中最常用的Micro-Facet模型中也是考虑了<strong>几何遮挡</strong>、<strong>表面法线的分布</strong>这样的物理现象。</li>
</ol>
<p>人们将可能影响到渲染结果的不同物理现象考虑在对渲染方程的建模中，从而达到接近真实的目的，毕竟，图形学是“如果看起来是对的，那么它就是对的”。<strong>图形学本质是对现实世界的仿真，而不是重现。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">Moony</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2022/11/01/GAMES101/">http://example.com/2022/11/01/GAMES101/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/11/01/%E7%BB%86%E6%9E%9D%E6%9C%AB%E8%8A%82/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">细枝末节</div></div></a></div><div class="next-post pull-right"><a href="/2022/11/01/hello-world/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Hello World</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Moony</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#GAMES101"><span class="toc-number">1.</span> <span class="toc-text">GAMES101</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hw01"><span class="toc-number">2.</span> <span class="toc-text">Hw01</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E7%BB%95%E4%BB%BB%E6%84%8F%E8%BD%B4%E6%97%8B%E8%BD%AC%E7%9A%84%E7%AE%80%E5%8D%95%E6%8E%A8%E5%AF%BC-Sulley"><span class="toc-number">2.1.</span> <span class="toc-text">向量绕任意轴旋转的简单推导 | Sulley</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%90%91%E9%87%8F%E5%88%86%E8%A7%A3"><span class="toc-number">2.2.</span> <span class="toc-text">方法一：向量分解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E5%AF%BC%E8%BF%87%E7%A8%8B"><span class="toc-number">2.2.1.</span> <span class="toc-text">推导过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E5%BD%A2%E5%BC%8F"><span class="toc-number">2.2.2.</span> <span class="toc-text">矩阵形式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%9D%90%E6%A0%87%E8%BD%B4%E5%AF%B9%E9%BD%90"><span class="toc-number">2.3.</span> <span class="toc-text">方法二：坐标轴对齐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E9%AA%8C"><span class="toc-number">2.3.1.</span> <span class="toc-text">检验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tips"><span class="toc-number">2.3.2.</span> <span class="toc-text">tips</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%8C%E3%80%90-%EF%BC%8C-x3D-%EF%BC%8C-%EF%BC%8C-x3D-%E3%80%91"><span class="toc-number">2.3.3.</span> <span class="toc-text">1，【+，+&#x3D;，-，-&#x3D;】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%8C%E3%80%90%EF%BC%8C-x3D-%E3%80%91"><span class="toc-number">2.3.4.</span> <span class="toc-text">2，【，&#x3D;】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%8C%E3%80%90-transpose-%E3%80%91"><span class="toc-number">2.3.5.</span> <span class="toc-text">3，【.transpose()】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%8C%E3%80%90-dot-%EF%BC%8C-cross-%EF%BC%8C-adjoint-%E3%80%91"><span class="toc-number">2.3.6.</span> <span class="toc-text">4，【.dot()，.cross()，.adjoint()】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%8C%E9%92%88%E5%AF%B9%E7%9F%A9%E9%98%B5%E5%85%83%E7%B4%A0%E8%BF%9B%E8%A1%8C%E7%9A%84%E6%93%8D%E4%BD%9C%E3%80%90-sum-%EF%BC%8C-prod-%EF%BC%8C-mean-%EF%BC%8CminCoeff-%EF%BC%8C-maxCoeff%EF%BC%8C-trace-%E3%80%91"><span class="toc-number">2.3.7.</span> <span class="toc-text">5，针对矩阵元素进行的操作【.sum()，.prod()，.mean()，minCoeff()，.maxCoeff，.trace()】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%EF%BC%8C%E3%80%90-norm-%E3%80%91%E5%90%91%E9%87%8F%E6%B1%82%E6%A8%A1%EF%BC%8C%E7%9F%A9%E9%98%B5%E8%8C%83%E6%95%B0"><span class="toc-number">2.3.8.</span> <span class="toc-text">6，【.norm()】向量求模，矩阵范数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hw02"><span class="toc-number">3.</span> <span class="toc-text">Hw02</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2022-x2F-04-x2F-12"><span class="toc-number">3.1.</span> <span class="toc-text">2022&#x2F;04&#x2F;12</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2022-x2F-04-x2F-19"><span class="toc-number">3.2.</span> <span class="toc-text">2022&#x2F;04&#x2F;19</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%91%E8%BE%B9%E9%97%AE%E9%A2%98"><span class="toc-number">3.3.</span> <span class="toc-text">黑边问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hw03"><span class="toc-number">4.</span> <span class="toc-text">Hw03</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2022-04-21"><span class="toc-number">4.1.</span> <span class="toc-text">2022.04.21</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2022-x2F-04-x2F-22"><span class="toc-number">4.2.</span> <span class="toc-text">2022&#x2F;04&#x2F;22</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hw04"><span class="toc-number">5.</span> <span class="toc-text">Hw04</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2022-x2F-05-x2F-21"><span class="toc-number">5.1.</span> <span class="toc-text">2022&#x2F;05&#x2F;21</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2022-x2F-06-x2F-07"><span class="toc-number">5.2.</span> <span class="toc-text">2022&#x2F;06&#x2F;07</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hw05"><span class="toc-number">6.</span> <span class="toc-text">Hw05</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2022-x2F-05-x2F-29"><span class="toc-number">6.1.</span> <span class="toc-text">2022&#x2F;05&#x2F;29</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hw06"><span class="toc-number">7.</span> <span class="toc-text">Hw06</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2022-x2F-05-x2F-30"><span class="toc-number">7.1.</span> <span class="toc-text">2022&#x2F;05&#x2F;30</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BVH%E5%8A%A0%E9%80%9F%E6%B1%82%E4%BA%A4%EF%BC%9A"><span class="toc-number">7.1.1.</span> <span class="toc-text">BVH加速求交：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2022-x2F-05-x2F-31"><span class="toc-number">7.2.</span> <span class="toc-text">2022&#x2F;05&#x2F;31</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SAH%E5%8A%A0%E9%80%9F%E6%B1%82%E4%BA%A4%EF%BC%9A"><span class="toc-number">7.2.1.</span> <span class="toc-text">SAH加速求交：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">7.2.2.</span> <span class="toc-text">结果如下：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hw07"><span class="toc-number">8.</span> <span class="toc-text">Hw07</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2022-x2F-06-x2F-08"><span class="toc-number">8.1.</span> <span class="toc-text">2022&#x2F;06&#x2F;08</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2022-x2F-06-x2F-11"><span class="toc-number">8.2.</span> <span class="toc-text">2022&#x2F;06&#x2F;11</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE%EF%BC%9A"><span class="toc-number">8.2.1.</span> <span class="toc-text">回顾：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8A%E7%90%83%E4%B8%8A%E7%9A%84%E5%9D%87%E5%8C%80%E9%87%87%E6%A0%B7%EF%BC%9A"><span class="toc-number">8.2.2.</span> <span class="toc-text">半球上的均匀采样：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E4%BA%86specular%E6%9D%90%E8%B4%A8%E7%9A%84%E8%BF%87%E5%BA%A6%E6%9B%9D%E5%85%89%E9%97%AE%E9%A2%98%E3%80%82"><span class="toc-number">8.2.3.</span> <span class="toc-text">解决了specular材质的过度曝光问题。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Specular%E7%9A%84%E9%87%87%E6%A0%B7%E4%B8%8Epdf%EF%BC%9A"><span class="toc-number">8.2.4.</span> <span class="toc-text">Specular的采样与pdf：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%BD%E5%8A%A0%EF%BC%9A"><span class="toc-number">8.2.5.</span> <span class="toc-text">追加：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MSAA-%E6%8A%97%E9%94%AF%E9%BD%BF"><span class="toc-number">8.2.6.</span> <span class="toc-text">MSAA 抗锯齿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GGX-%E4%B8%8D%E5%AE%8C%E6%95%B4%EF%BC%8C%E6%B2%A1%E6%8E%A8%E5%AF%BC%E5%85%AC%E5%BC%8F"><span class="toc-number">8.2.7.</span> <span class="toc-text">GGX (不完整，没推导公式)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E9%81%AE%E6%8C%A1"><span class="toc-number">8.2.7.1.</span> <span class="toc-text">自遮挡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E6%80%A7%E9%87%87%E6%A0%B7-%E8%BF%98%E6%B2%A1%E5%81%9A"><span class="toc-number">8.2.8.</span> <span class="toc-text">重要性采样  (还没做)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%86%E7%B4%AF%E8%AE%A1%E5%88%86%E5%B8%83%E5%87%BD%E6%95%B0"><span class="toc-number">8.2.8.1.</span> <span class="toc-text">逆累计分布函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NDF"><span class="toc-number">8.2.8.2.</span> <span class="toc-text">NDF</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gamma%E7%9F%AB%E6%AD%A3-%E8%BF%98%E6%B2%A1%E5%81%9A"><span class="toc-number">8.2.9.</span> <span class="toc-text">Gamma矫正 (还没做)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%89%E8%BF%BD%E6%80%8E%E4%B9%88%E7%94%A8%E8%B4%B4%E5%9B%BE%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">光追怎么用贴图？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%89%E8%BF%BD%E7%9A%84%E7%9B%B8%E6%9C%BA%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">10.</span> <span class="toc-text">光追的相机的原理？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%B0%86%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E7%94%A8%E5%9C%A8%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93"><span class="toc-number">11.</span> <span class="toc-text">怎么将渲染方程用在实时渲染</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%89%E7%85%A7%E8%AE%A1%E7%AE%97%E7%9A%84%E6%A1%86%E6%9E%B6"><span class="toc-number">12.</span> <span class="toc-text">光照计算的框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BRDF%E5%92%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B"><span class="toc-number">12.1.</span> <span class="toc-text">BRDF和渲染方程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BRDF%E5%92%8C%E6%9D%90%E8%B4%A8"><span class="toc-number">12.2.</span> <span class="toc-text">BRDF和材质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%8F%E9%AA%8C-x2F-%E7%89%A9%E7%90%86BRDF"><span class="toc-number">12.3.</span> <span class="toc-text">什么是经验&#x2F;物理BRDF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E5%B1%95"><span class="toc-number">12.4.</span> <span class="toc-text">拓展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BSSRDF"><span class="toc-number">12.5.</span> <span class="toc-text">BSSRDF</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%89%E8%BF%BD"><span class="toc-number">12.5.1.</span> <span class="toc-text">光追</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF"><span class="toc-number">12.5.2.</span> <span class="toc-text">渲染管线</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E6%B8%B2%E6%9F%93-PBR-%EF%BC%9F"><span class="toc-number">13.</span> <span class="toc-text">什么是基于物理的渲染(PBR)？</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/11/03/Unity/" title="Unity"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity"/></a><div class="content"><a class="title" href="/2022/11/03/Unity/" title="Unity">Unity</a><time datetime="2022-11-03T12:44:35.000Z" title="Created 2022-11-03 20:44:35">2022-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/02/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/" title="Shader入门精要"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Shader入门精要"/></a><div class="content"><a class="title" href="/2022/11/02/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/" title="Shader入门精要">Shader入门精要</a><time datetime="2022-11-02T11:22:23.000Z" title="Created 2022-11-02 19:22:23">2022-11-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/02/OpenGL/" title="OpenGL"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OpenGL"/></a><div class="content"><a class="title" href="/2022/11/02/OpenGL/" title="OpenGL">OpenGL</a><time datetime="2022-11-02T08:35:45.000Z" title="Created 2022-11-02 16:35:45">2022-11-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/02/c-%E6%80%BB%E7%BB%93/" title="c++总结"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="c++总结"/></a><div class="content"><a class="title" href="/2022/11/02/c-%E6%80%BB%E7%BB%93/" title="c++总结">c++总结</a><time datetime="2022-11-02T05:49:40.000Z" title="Created 2022-11-02 13:49:40">2022-11-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/02/Dx11/" title="Dx11"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Dx11"/></a><div class="content"><a class="title" href="/2022/11/02/Dx11/" title="Dx11">Dx11</a><time datetime="2022-11-02T05:02:20.000Z" title="Created 2022-11-02 13:02:20">2022-11-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Moony</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>